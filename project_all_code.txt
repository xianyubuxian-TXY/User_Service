// ====================== ./CMakeLists.txt ======================

cmake_minimum_required(VERSION 3.16)
project(UserService
        VERSION 1.0.0
        LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 23)	# 指定使用 C++23 标准
set(CMAKE_CXX_STANDARD_REQUIRED ON) #强制要求编译器支持 C++23，若编译器不支持，直接报错
set(CMAKE_CXX_EXTENSIONS OFF) #禁用编译器扩展语法， 保证代码在不同编译器下行为一致

# 核心逻辑：若用户未指定 CMAKE_BUILD_TYPE（如编译时未加 -DCMAKE_BUILD_TYPE=Debug），
# 默认设置为 Release（优化编译，去除调试信息，适合部署）；
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the build type" FORCE)
endif()

option(BUILD_TESTS "Build unit tests" ON) # 控制是否编译单元测试代码（tests 子目录）
# 控制生成 “动态库（.so/.dll）” 还是 “静态库（.a/.lib）”，默认 OFF 即生成静态库；
option(BUILD_SHARED_LIBS "Build shared instead of static libs" OFF) 


# 输出目录
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)


# YAML 配置
find_package(yaml-cpp CONFIG REQUIRED)

# spdlog 日志
find_package(spdlog CONFIG REQUIRED)

# MySQL
find_package(PkgConfig REQUIRED)
pkg_check_modules(MYSQL REQUIRED mysqlclient)

# hiredis 库 
find_path(HIREDIS_HEADER hiredis)
find_library(HIREDIS_LIB hiredis)

# redis++ 库 
# 注意：这里是 sw，不是 redis++
find_path(REDIS_PLUS_PLUS_HEADER sw)
find_library(REDIS_PLUS_PLUS_LIB redis++)

# Protobuf
find_package(Protobuf REQUIRED)

# gRPC
pkg_check_modules(GRPC REQUIRED grpc++ grpc)

# 查找 protoc 和 grpc_cpp_plugin
find_program(PROTOC protoc REQUIRED)
find_program(GRPC_CPP_PLUGIN grpc_cpp_plugin REQUIRED)

# 查找 OpenSSL（jwt_service 需要）
find_package(OpenSSL REQUIRED)

# 查找 fmt
find_package(fmt REQUIRED)

# Zookeeper 依赖
find_path(ZOOKEEPER_INCLUDE_DIR zookeeper/zookeeper.h)
find_library(ZOOKEEPER_LIBRARY zookeeper_mt)

if(NOT ZOOKEEPER_INCLUDE_DIR OR NOT ZOOKEEPER_LIBRARY)
    message(FATAL_ERROR "ZooKeeper not found. Install libzookeeper-mt-dev")
endif()

message(STATUS "Found ZooKeeper: ${ZOOKEEPER_LIBRARY}")

add_subdirectory(api)
add_subdirectory(src)


# GTest 包
if(BUILD_TESTS)
    find_package(GTest REQUIRED)
    enable_testing()
    add_subdirectory(tests)
endif()

-----------------------------------------------------


// ====================== ./api/proto/CMakeLists.txt ======================

# api/proto/CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

find_program(PROTOC protoc REQUIRED)
find_program(GRPC_CPP_PLUGIN grpc_cpp_plugin REQUIRED)

# 使用 find_package 查找 Protobuf（更完整）
find_package(Protobuf REQUIRED)

# 使用 pkg-config 查找 gRPC
find_package(PkgConfig REQUIRED)
pkg_check_modules(GRPC REQUIRED grpc++ grpc)

set(PROTO_FILES
    ${CMAKE_CURRENT_SOURCE_DIR}/pb_common/result.proto
    ${CMAKE_CURRENT_SOURCE_DIR}/pb_auth/auth.proto
    ${CMAKE_CURRENT_SOURCE_DIR}/pb_user/user.proto
)

set(PROTO_OUTPUT_DIR ${CMAKE_CURRENT_BINARY_DIR}/generated)

set(PROTO_SRCS "")
set(GRPC_SRCS "")

foreach(PROTO_FILE ${PROTO_FILES})
    file(RELATIVE_PATH PROTO_REL_PATH ${CMAKE_CURRENT_SOURCE_DIR} ${PROTO_FILE})
    get_filename_component(PROTO_REL_DIR ${PROTO_REL_PATH} DIRECTORY)
    get_filename_component(PROTO_NAME ${PROTO_FILE} NAME_WE)
    
    file(MAKE_DIRECTORY "${PROTO_OUTPUT_DIR}/${PROTO_REL_DIR}")
    
    set(PROTO_CC "${PROTO_OUTPUT_DIR}/${PROTO_REL_DIR}/${PROTO_NAME}.pb.cc")
    set(PROTO_H  "${PROTO_OUTPUT_DIR}/${PROTO_REL_DIR}/${PROTO_NAME}.pb.h")
    set(GRPC_CC  "${PROTO_OUTPUT_DIR}/${PROTO_REL_DIR}/${PROTO_NAME}.grpc.pb.cc")
    set(GRPC_H   "${PROTO_OUTPUT_DIR}/${PROTO_REL_DIR}/${PROTO_NAME}.grpc.pb.h")
    
    list(APPEND PROTO_SRCS ${PROTO_CC})
    list(APPEND GRPC_SRCS ${GRPC_CC})
    
    add_custom_command(
        OUTPUT ${PROTO_CC} ${PROTO_H} ${GRPC_CC} ${GRPC_H}
        COMMAND ${PROTOC}
            --cpp_out=${PROTO_OUTPUT_DIR}
            --grpc_out=${PROTO_OUTPUT_DIR}
            --plugin=protoc-gen-grpc=${GRPC_CPP_PLUGIN}
            -I${CMAKE_CURRENT_SOURCE_DIR}
            ${PROTO_FILE}
        DEPENDS ${PROTO_FILE}
        COMMENT "Generating: ${PROTO_REL_PATH}"
        VERBATIM
    )
    
    set_source_files_properties(
        ${PROTO_CC} ${PROTO_H} ${GRPC_CC} ${GRPC_H}
        PROPERTIES GENERATED TRUE
    )
endforeach()

# 创建库
add_library(proto_lib STATIC 
    ${PROTO_SRCS} 
    ${GRPC_SRCS}
)

target_include_directories(proto_lib 
    PUBLIC 
        ${PROTO_OUTPUT_DIR}
        ${Protobuf_INCLUDE_DIRS}
        ${GRPC_INCLUDE_DIRS}
)

# 关键：正确链接所有 protobuf 库
target_link_libraries(proto_lib 
    PUBLIC 
        ${Protobuf_LIBRARIES}
        ${GRPC_LIBRARIES}
)

# 添加链接目录（pkg-config 可能需要）
target_link_directories(proto_lib
    PUBLIC
        ${GRPC_LIBRARY_DIRS}
)

target_compile_features(proto_lib PUBLIC cxx_std_17)

target_compile_options(proto_lib PRIVATE
    $<$<CXX_COMPILER_ID:GNU,Clang>:-Wno-unused-parameter -Wno-deprecated-declarations>
)


-----------------------------------------------------


// ====================== ./api/proto/pb_user/user.proto ======================

syntax = "proto3";

package pb_user;

import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "pb_common/result.proto";
import "pb_auth/auth.proto";
// ==================== 通用消息 ====================


message User {
    string id = 1;
    string mobile = 2;
    pb_auth.UserRole role = 3;
    string display_name = 4;
    bool disabled = 5;
    google.protobuf.Timestamp created_at = 6;
    google.protobuf.Timestamp updated_at = 7;
}

// 分页请求
message PageRequest {
    int32 page = 1;
    int32 page_size = 2;
}

// 分页响应
message PageResponse {
    int64 total_records = 1;
    int32 total_pages = 2;
    int32 page = 3;
    int32 page_size = 4;
}

// ==================== 获取用户信息 ====================

message GetCurrentUserRequest {
    // 无参数，从 Token 中获取 user_id
}

message GetCurrentUserResponse {
    pb_common.Result result = 1;
    User user = 2;
}

message GetUserRequest {
    string id = 1;
}

message GetUserResponse {
    pb_common.Result result = 1;
    User user = 2;
}

// ==================== 更新用户 ====================

message UpdateUserRequest {
    google.protobuf.StringValue display_name = 1;
    // 后续扩展：avatar_url, email 等
}

message UpdateUserResponse {
    pb_common.Result result = 1;
    User user = 2;
}

// ==================== 修改密码（已登录状态） ====================

message ChangePasswordRequest {
    string old_password = 1;
    string new_password = 2;
}

message ChangePasswordResponse {
    pb_common.Result result = 1;
}

// ==================== 删除用户（注销） ====================

message DeleteUserRequest {
    string verify_code = 1;     // 需要验证码确认
}

message DeleteUserResponse {
    pb_common.Result result = 1;
}

// ==================== 用户列表（管理员） ====================

message ListUsersRequest {
    PageRequest page = 1;
    string mobile_filter = 2;
    google.protobuf.BoolValue disabled_filter = 3;
}

message ListUsersResponse {
    pb_common.Result result = 1;
    repeated User users = 2;
    PageResponse page_info = 3;
}

// ==================== 服务定义 ====================

service UserService {
    // 当前用户
    rpc GetCurrentUser(GetCurrentUserRequest) returns (GetCurrentUserResponse);
    rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse);
    // 用户已登录，知道旧密码，想改成新密码
    rpc ChangePassword(ChangePasswordRequest) returns (ChangePasswordResponse);
    rpc DeleteUser(DeleteUserRequest) returns (DeleteUserResponse);
    
    // 管理员接口
    rpc GetUser(GetUserRequest) returns (GetUserResponse);
    rpc ListUsers(ListUsersRequest) returns (ListUsersResponse);
}
    

-----------------------------------------------------


// ====================== ./api/proto/pb_common/result.proto ======================

syntax = "proto3";

package pb_common;

// 错误码 - 与内部 C++ ErrorCode 保持一致
enum ErrorCode {
    // ========== 成功 ==========
    OK = 0;

    // ==================== 通用错误（100~999） ====================
    // 系统错误（1xx）
    UNKNOWN             = 100;  // 未知错误
    INTERNAL            = 101;  // 内部服务器异常
    NOT_IMPLEMENTED     = 102;  // 功能未实现
    SERVICE_UNAVAILABLE = 103;  // 服务不可用
    TIMEOUT             = 104;  // 请求超时

    // 参数错误（2xx）
    INVALID_ARGUMENT    = 200;  // 参数无效
    INVALID_PAGE        = 210;  // 无效的分页参数
    INVALID_PAGE_SIZE   = 211;  // 无效的分页大小

    // 限流（3xx）
    RATE_LIMITED        = 300;  // 请求过于频繁
    QUOTA_EXCEEDED      = 301;  // 配额超限

    // ==================== 认证错误（1000~1999） ====================
    // Token 相关（100x）
    UNAUTHENTICATED     = 1000; // 未认证（通用）
    TOKEN_MISSING       = 1001; // Token 缺失
    TOKEN_INVALID       = 1002; // Token 无效
    TOKEN_EXPIRED       = 1003; // Token 已过期
    TOKEN_REVOKED       = 1004; // Token 已注销

    // 登录相关（101x~102x）
    LOGIN_FAILED        = 1010; // 登录失败（通用）
    WRONG_PASSWORD      = 1011; // 密码错误
    ACCOUNT_LOCKED      = 1012; // 账号已锁定（多次密码错误）

    // 验证码相关（102x）
    CAPTCHA_WRONG       = 1021; // 验证码错误
    CAPTCHA_EXPIRED     = 1022; // 验证码已过期

    // ==================== 用户错误（2000~2999） ====================
    // 用户查询（200x）
    USER_NOT_FOUND      = 2000; // 用户不存在
    USER_DELETED        = 2001; // 用户已删除

    // 用户创建（201x）
    USER_ALREADY_EXISTS = 2010; // 用户已存在（通用）
    MOBILE_TAKEN        = 2013; // 手机号已被占用

    // 用户状态（202x）
    USER_DISABLED       = 2020; // 用户已禁用
    USER_NOT_VERIFIED   = 2021; // 用户未验证

    // ==================== 权限错误（3000~3999） ====================
    PERMISSION_DENIED   = 3000; // 无权限（通用）
    ADMIN_REQUIRED      = 3001; // 需要管理员权限
    OWNER_REQUIRED      = 3002; // 需要是资源所有者
}


message Result {
    ErrorCode code              = 1;
    string    msg               = 2;
}

-----------------------------------------------------


// ====================== ./api/proto/pb_auth/auth.proto ======================

syntax = "proto3";

package pb_auth;

import "google/protobuf/timestamp.proto";
import "pb_common/result.proto";

// ==================== 枚举定义 ====================

// 短信验证码使用场景
enum SmsScene {
    SMS_SCENE_UNKNOWN = 0;       // 未知场景（默认值，禁止业务使用）
    SMS_SCENE_REGISTER = 1;      // 注册场景
    SMS_SCENE_LOGIN = 2;         // 登录场景
    SMS_SCENE_RESET_PASSWORD = 3;// 重置密码
    SMS_SCENE_DELETE_USER = 4;   // 注销账号
}

// 用户角色枚举（新增）
enum UserRole {
    USER_ROLE_USER = 0;          // 普通用户（默认）
    USER_ROLE_ADMIN = 1;         // 管理员
    USER_ROLE_SUPER_ADMIN = 2;   // 超级管理员
}

// ==================== 通用消息体定义 ====================

// 用户核心信息体
message UserInfo {
    string id = 1;                              // 用户UUID
    string mobile = 2;                          // 手机号
    string display_name = 3;                    // 昵称
    UserRole role = 4;                          // 用户角色（改为枚举类型）
    bool disabled = 5;                          // 是否禁用
    google.protobuf.Timestamp created_at = 6;   // 创建时间
}

// JWT双令牌对
message TokenPair {
    string access_token = 1;
    string refresh_token = 2;
    int64 expires_in = 3;     // access_token过期时间（秒）
}

// ==================== 短信验证码接口 ====================

message SendVerifyCodeRequest {
    string mobile = 1;
    SmsScene scene = 2;
}

message SendVerifyCodeResponse {
    pb_common.Result result = 1;
    int32 retry_after = 2;        // 重发冷却时间（秒）
}

// ==================== 注册接口 ====================

message RegisterRequest {
    string mobile = 1;
    string verify_code = 2;
    string password = 3;
    string display_name = 4;      // 可选
}

message RegisterResponse {
    pb_common.Result result = 1;
    UserInfo user = 2;
    TokenPair tokens = 3;
}

// ==================== 登录接口 ====================

message LoginByPasswordRequest {
    string mobile = 1;
    string password = 2;
}

message LoginByPasswordResponse {
    pb_common.Result result = 1;
    UserInfo user = 2;
    TokenPair tokens = 3;
}

message LoginByCodeRequest {
    string mobile = 1;
    string verify_code = 2;
}

message LoginByCodeResponse {
    pb_common.Result result = 1;
    UserInfo user = 2;
    TokenPair tokens = 3;
}

// ==================== Token管理接口 ====================

message RefreshTokenRequest {
    string refresh_token = 1;
}

message RefreshTokenResponse {
    pb_common.Result result = 1;
    TokenPair tokens = 2;
}

message LogoutRequest {
    string refresh_token = 1;
}

message LogoutResponse {
    pb_common.Result result = 1;
}

// ==================== 密码管理接口 ====================

message ResetPasswordRequest {
    string mobile = 1;
    string verify_code = 2;
    string new_password = 3;
}

message ResetPasswordResponse {
    pb_common.Result result = 1;
}

// ==================== 内部服务调用 - Token验证接口 ====================

message ValidateTokenRequest {
    string access_token = 1;
}

message ValidateTokenResponse {
    pb_common.Result result = 1;
    string user_id = 2;                          // 用户数据库ID（内部使用）
    string user_uuid = 3;                        // 用户UUID（对外标识）
    string mobile = 4;                           // 手机号
    UserRole role = 5;                           // 用户角色（新增）
    google.protobuf.Timestamp expires_at = 6;   // 过期时间
}

// ==================== 服务定义 ====================

service AuthService {
    // 验证码
    rpc SendVerifyCode(SendVerifyCodeRequest) returns (SendVerifyCodeResponse);
    
    // 注册
    rpc Register(RegisterRequest) returns (RegisterResponse);
    
    // 登录
    rpc LoginByPassword(LoginByPasswordRequest) returns (LoginByPasswordResponse);
    rpc LoginByCode(LoginByCodeRequest) returns (LoginByCodeResponse);
    
    // Token管理
    rpc RefreshToken(RefreshTokenRequest) returns (RefreshTokenResponse);
    rpc Logout(LogoutRequest) returns (LogoutResponse);
    
    // 密码重置
    rpc ResetPassword(ResetPasswordRequest) returns (ResetPasswordResponse);
    
    // 内部服务Token验证（禁止客户端调用）
    rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);
}


-----------------------------------------------------


// ====================== ./api/CMakeLists.txt ======================

add_subdirectory(proto)

-----------------------------------------------------


// ====================== ./.gitignore ======================

# 构建目录
build/
cmake-build-*/

# 日志（保留目录结构）
logs/*
!logs/.gitkeep

# Docker 数据卷（如果用绑定挂载）
mysql_data/
redis_data/

# 生成的 proto 文件
*.pb.cc
*.pb.h


-----------------------------------------------------


// ====================== ./docker-compose.yml ======================

# ============================================================
# Docker Compose 版本声明
# ============================================================
# 3.8 是较新的稳定版本，支持 healthcheck 的 condition 语法
version: '3.8'

services:
  # ==========================================================
  # ZooKeeper 服务注册中心
  # ==========================================================
  zookeeper:
    image: zookeeper:3.8                      # 官方 ZooKeeper 镜像
    container_name: user-service-zookeeper
    ports:
      - "2181:2181"                           # 客户端连接端口
      - "8080:8080"                           # AdminServer 端口（可选）
    environment:
      ZOO_MY_ID: 1                            # 节点 ID（单节点设为 1）
      ZOO_TICK_TIME: 2000                     # 基本时间单位（毫秒）
      ZOO_INIT_LIMIT: 5                       # 初始化连接超时（tick 数）
      ZOO_SYNC_LIMIT: 2                       # 同步超时（tick 数）
    volumes:
      - zookeeper_data:/data                  # 数据持久化
      - zookeeper_logs:/datalog               # 事务日志持久化
    networks:
      - user-network
    healthcheck:
      test: ["CMD-SHELL", "echo ruok | nc localhost 2181 | grep imok"]
        # ↑ 发送 ruok 命令，期望返回 imok
      interval: 10s
      timeout: 5s
      retries: 5

  # ==========================================================
  # MySQL 数据库服务
  # ==========================================================
  mysql:
    image: mysql:8.0                          # 使用官方 MySQL 8.0 镜像
    container_name: user-service-mysql        # 容器名称（方便识别）
    environment:
      MYSQL_ROOT_PASSWORD: root123            # root 用户密码
      MYSQL_DATABASE: user_service            # 启动时自动创建的数据库
    ports:
      - "3307:3306"                           # 主机端口:容器端口，允许外部连接
    volumes:
      - mysql_data:/var/lib/mysql             # 数据持久化到命名卷
      - ./scripts/init_db.sql:/docker-entrypoint-initdb.d/init.sql:ro
        # ↑ 初始化脚本，首次启动时自动执行（:ro = 只读挂载）
    networks:
      - user-network                          # 加入自定义网络
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
        # ↑ 健康检查命令：用 mysqladmin ping 测试连接
      interval: 10s                           # 每 10 秒检查一次
      timeout: 5s                             # 超时时间
      retries: 5                              # 连续失败 5 次才判定不健康

  # ==========================================================
  # Redis 缓存服务
  # ==========================================================
  redis:
    image: redis:7-alpine                     # alpine 版本更小（~30MB）
    container_name: user-service-redis
    ports:
      - "6380:6379"
    volumes:
      - redis_data:/data                      # 持久化 RDB/AOF 文件
    command: redis-server --appendonly yes    # 启用 AOF 持久化
      # ↑ 覆盖默认启动命令，保证数据不丢失
    networks:
      - user-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]      # PONG 表示健康
      interval: 10s
      timeout: 5s
      retries: 5

  # ==========================================================
  # User Service 用户服务
  # ==========================================================
  user-service:
    build:
      context: .                              # 构建上下文为当前目录
      dockerfile: deploy/docker/Dockerfile    # Dockerfile 路径
    container_name: user-service
    depends_on:
      # ↓ 依赖的服务必须健康才启动（避免连接失败）
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
      zookeeper:
        condition: service_healthy
    environment:
      - CONFIG_PATH=/app/configs/config.docker.yaml
        # ↑ 告诉应用配置文件位置
      - SERVICE_NAME=user-service
      - MYSQL_HOST=mysql                      # 用容器名作为主机名
      - REDIS_HOST=redis
      - ZK_HOSTS=zookeeper:2181               # ZooKeeper 地址
      - ZK_ROOT_PATH=/services
      - ZK_SERVICE_NAME=user-service          # 服务名称
      - ZK_ENABLED=true
      - ZK_REGISTER_SELF=true
    ports:
      - "50051:50051"                         # gRPC 端口映射
      - "9091:9090"                           # Metrics 端口映射
    volumes:
      - ./configs:/app/configs:ro             # 挂载配置目录（只读）
      - ./logs/user-service:/app/logs         # 挂载日志目录（可写）
    networks:
      - user-network
    healthcheck:
      test: ["CMD", "grpc_health_probe", "-addr=:50051"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ==========================================================
  # Auth Service 认证服务
  # ==========================================================
  auth-service:
    build:
      context: .                              # 构建上下文为当前目录
      dockerfile: deploy/docker/Dockerfile    # Dockerfile 路径（可共用或单独）
    container_name: auth-service
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
      zookeeper:
        condition: service_healthy
    environment:
      - CONFIG_PATH=/app/configs/config.docker.yaml
      - SERVICE_NAME=auth-service
      - MYSQL_HOST=mysql
      - REDIS_HOST=redis
      - ZK_HOSTS=zookeeper:2181
      - ZK_ROOT_PATH=/services
      - ZK_SERVICE_NAME=auth-service          # ← 区分服务名称
      - ZK_ENABLED=true
      - ZK_REGISTER_SELF=true
    ports:
      - "50052:50051"                         # gRPC 端口（主机用不同端口）
      - "9092:9090"                           # Metrics 端口
    volumes:
      - ./configs:/app/configs:ro
      - ./logs/auth-service:/app/logs         # 日志分开存放
    networks:
      - user-network
    healthcheck:
      test: ["CMD", "grpc_health_probe", "-addr=:50051"]
      interval: 10s
      timeout: 5s
      retries: 5


# ==============================================================
# 命名卷（Docker 管理的持久化存储）
# ==============================================================
volumes:
  mysql_data:       # MySQL 数据
  redis_data:       # Redis 数据
  zookeeper_data:   # ZooKeeper 数据
  zookeeper_logs:   # ZooKeeper 事务日志

# ==============================================================
# 自定义网络
# ==============================================================
networks:
  user-network:
    driver: bridge    # 桥接网络，容器间可通过容器名互访


-----------------------------------------------------


// ====================== ./deploy/docker/Dockerfile ======================

# deploy/docker/Dockerfile

FROM ubuntu:24.04 AS builder

ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update && apt-get install -y \
    build-essential cmake pkg-config ca-certificates \
    libgrpc++-dev libprotobuf-dev \
    protobuf-compiler protobuf-compiler-grpc \
    libmysqlclient-dev libhiredis-dev uuid-dev \
    libzookeeper-mt-dev \
    libyaml-cpp-dev \
    libspdlog-dev libfmt-dev libssl-dev \
    && rm -rf /var/lib/apt/lists/*

# 从 thirdparty 目录复制
COPY thirdparty/redis-plus-plus-1.3.10.tar.gz /tmp/

# 编译 redis-plus-plus
RUN cd /tmp && tar xzf redis-plus-plus-1.3.10.tar.gz && \
    cd redis-plus-plus-1.3.10 && mkdir build && cd build && \
    cmake .. -DCMAKE_BUILD_TYPE=Release -DREDIS_PLUS_PLUS_CXX_STANDARD=17 && \
    make -j$(nproc) && make install && ldconfig && \
    rm -rf /tmp/redis-plus-plus*

WORKDIR /build
COPY . .

# 构建项目
RUN rm -rf build && mkdir build && cd build && \
    cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=OFF && \
    make -j$(nproc)

# ==================== 运行时镜像 ====================
FROM ubuntu:24.04

ENV DEBIAN_FRONTEND=noninteractive

# Ubuntu 24.04 库版本
RUN apt-get update && apt-get install -y \
    libgrpc++1.51t64 libprotobuf32t64 libmysqlclient21 \
    libhiredis1.1.0 libuuid1 libzookeeper-mt2 \
    libyaml-cpp0.8 libspdlog1.12 libfmt9 libssl3t64 \
    curl netcat-openbsd \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /usr/local/lib/libredis++.so* /usr/local/lib/
RUN ldconfig

RUN curl -fsSL https://github.com/grpc-ecosystem/grpc-health-probe/releases/download/v0.4.24/grpc_health_probe-linux-amd64 \
    -o /usr/local/bin/grpc_health_probe && chmod +x /usr/local/bin/grpc_health_probe || true

RUN useradd -m -s /bin/bash appuser
WORKDIR /app

COPY --from=builder /build/build/bin/user_server .
COPY --from=builder /build/build/bin/auth_server .

COPY deploy/docker/entrypoint.sh .
RUN chmod +x entrypoint.sh
COPY configs/ /app/configs/

RUN mkdir -p /app/logs && chown -R appuser:appuser /app
USER appuser

EXPOSE 50051 9090
ENV CONFIG_PATH=/app/configs/config.docker.yaml
ENV SERVICE_NAME=user-service

ENTRYPOINT ["./entrypoint.sh"]


-----------------------------------------------------


// ====================== ./scripts/init_db.sql ======================

-- scripts/init_db.sql

CREATE DATABASE IF NOT EXISTS user_service 
    CHARACTER SET utf8mb4 
    COLLATE utf8mb4_unicode_ci;

USE user_service;

-- 用户表
CREATE TABLE IF NOT EXISTS `users` (
    `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增主键',
    `uuid` CHAR(36) NOT NULL COMMENT '对外暴露的用户ID',
    `mobile` VARCHAR(20) DEFAULT NULL COMMENT '手机号',
    `display_name` VARCHAR(128) DEFAULT NULL COMMENT '显示名称',
    `password_hash` VARCHAR(256) NOT NULL COMMENT '密码哈希',
    `role` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '角色: 0-普通用户, 1-管理员, 2-超级管理员',
    `disabled` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否禁用: 0-否, 1-是',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_uuid` (`uuid`),
    UNIQUE KEY `uk_mobile` (`mobile`),
    KEY `idx_role` (`role`),
    KEY `idx_disabled` (`disabled`),
    KEY `idx_created_at` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户表';

-- 用户会话表
CREATE TABLE IF NOT EXISTS `user_sessions` (
    `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    `user_id` BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
    `token_hash` VARCHAR(64) NOT NULL COMMENT 'Token哈希(SHA256)',
    `expires_at` DATETIME NOT NULL COMMENT '过期时间',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_token_hash` (`token_hash`),
    KEY `idx_user_id` (`user_id`),
    KEY `idx_expires_at` (`expires_at`),
    CONSTRAINT `fk_session_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户会话表';

-- ============================================================================
-- 初始化超级管理员（可选）
-- ============================================================================
-- 密码: Admin@123456（需要用你的 PasswordHelper::Hash 生成实际哈希值）
-- INSERT INTO `users` (`uuid`, `mobile`, `display_name`, `password_hash`, `role`) 
-- VALUES (UUID(), '13800000000', '超级管理员', '$2a$10$...', 2);


-----------------------------------------------------


// ====================== ./src/common/CMakeLists.txt ======================

add_library(user_common STATIC logger.cpp)

target_include_directories(user_common PUBLIC
    ${PROJECT_SOURCE_DIR}/include
)

target_link_libraries(user_common PUBLIC
    spdlog::spdlog
)

-----------------------------------------------------


// ====================== ./src/common/logger.cpp ======================

#include "common/logger.h"

#include <spdlog/sinks/stdout_color_sinks.h>    //带颜色的终端输出，多线程安全
#include <spdlog/sinks/rotating_file_sink.h>    //按文件大小轮转，保留N个备份
#include <spdlog/async.h>
#include <filesystem>
#include <memory>
#include <vector>
#include <iostream>

namespace user_service {

bool Logger::initialized = false;

void Logger::Init(const std::string& log_path,
                  const std::string& filename,
                  const std::string& level,
                  size_t max_size,
                  int max_files,
                  bool console_output)
{
    if (initialized) return;

    try {
        std::vector<spdlog::sink_ptr> sinks;

        // ==================== 控制台输出 ====================
        if (console_output) {
            auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
            console_sink->set_level(spdlog::level::debug);
            console_sink->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%t] %v");
            sinks.push_back(console_sink);
        }

        // ==================== 创建日志目录 ====================
        std::filesystem::path dir_path(log_path);
        if (!std::filesystem::exists(dir_path)) {
            if (!std::filesystem::create_directories(dir_path)) {
                std::cerr << "Logger Error: 无法创建日志目录: " << log_path << std::endl;
                // 降级：仅使用控制台输出
                if (!sinks.empty()) {
                    auto logger = std::make_shared<spdlog::logger>("user_service", sinks.begin(), sinks.end());
                    logger->set_level(ParseLevel(level));
                    spdlog::set_default_logger(logger);
                    initialized = true;
                    SPDLOG_WARN("日志目录创建失败，仅输出到控制台");
                }
                return;
            }
            std::cout << ">>> 日志目录已创建: " << std::filesystem::absolute(dir_path) << std::endl;
        }

        // ==================== 文件输出（轮转） ====================
        std::string full_path = (dir_path / filename).string();
        auto rfile_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            full_path, max_size, max_files
        );
        rfile_sink->set_level(spdlog::level::trace);
        rfile_sink->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%l] [%t] [%s:%#] %v");
        sinks.push_back(rfile_sink);

        // ==================== 创建异步日志系统 ====================
        spdlog::init_thread_pool(8192, 1);  // 日志队列大小 8K, 后台线程 1
        auto logger = std::make_shared<spdlog::async_logger>(
            "user_service",
            sinks.begin(),
            sinks.end(),
            spdlog::thread_pool(),
            spdlog::async_overflow_policy::block
        );

        // 设置日志级别
        logger->set_level(ParseLevel(level));

        // 设置为默认日志器
        spdlog::set_default_logger(logger);

        // 每3秒自动刷新一次
        spdlog::flush_every(std::chrono::seconds(3));

        initialized = true;

        // ==================== 立即刷新初始化日志 ====================
        SPDLOG_INFO("Logger initialized, level={}, path={}", level, full_path);
        logger->flush();  // 立即写入，确保初始化日志不丢失

        std::cout << ">>> 日志文件: " << std::filesystem::absolute(full_path) << std::endl;

    } catch (const spdlog::spdlog_ex& ex) {
        std::cerr << "Logger Error: spdlog 初始化失败: " << ex.what() << std::endl;
    } catch (const std::exception& ex) {
        std::cerr << "Logger Error: " << ex.what() << std::endl;
    }
}

void Logger::Shutdown() {
    if (initialized) {
        SPDLOG_INFO("Logger shutting down...");

        // 确保所有日志写入
        if (auto logger = spdlog::default_logger()) {
            logger->flush();
        }

        spdlog::shutdown();
        initialized = false;
    }
}

spdlog::level::level_enum Logger::ParseLevel(const std::string& level) {
    if (level == "trace") return spdlog::level::trace;
    if (level == "debug") return spdlog::level::debug;
    if (level == "info") return spdlog::level::info;
    if (level == "warn") return spdlog::level::warn;
    if (level == "error") return spdlog::level::err;
    if (level == "critical") return spdlog::level::critical;
    return spdlog::level::info;
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./src/auth/token_repository.cpp ======================

#include "token_repository.h"
#include "exception/mysql_exception.h"

namespace user_service {

// 数据库连接校验宏：校验连接有效性，无效则返回服务不可用结果
// Conn: 数据库连接指针  ResultType: 统一返回结果类型
#define CHECK_CONN(Conn, ResultType)                                            \
    if (!Conn->Valid()) {                                              \
        LOG_ERROR("mysql_conn is invalid");                                     \
        return ResultType::Fail(ErrorCode::ServiceUnavailable,                  \
                                GetErrorMessage(ErrorCode::ServiceUnavailable));\
    }

// ==================== 构造函数 ====================
/// 构造函数：注入MySQL连接池，用于获取数据库连接
/// @param pool MySQL连接池智能指针，全局单例复用
TokenRepository::TokenRepository(std::shared_ptr<MySQLPool> pool)
    : pool_(std::move(pool))
{}

// ==================== 新增操作 ====================
/// 保存刷新令牌哈希到数据库（用户会话表）
/// @param user_id 用户唯一标识
/// @param token_hash 刷新令牌的SHA256哈希值（非明文存储）
/// @param expires_in_seconds 令牌有效期（秒）
/// @return 统一结果对象：成功/失败（含错误码+信息）
Result<void> TokenRepository::SaveRefreshToken(int64_t user_id,
                                                const std::string& token_hash,
                                                int expires_in_seconds) {
    try {
        auto conn = pool_->CreateConnection(); // 从连接池获取连接
        CHECK_CONN(conn, Result<void>);        // 校验连接有效性

        // 计算令牌过期时间点，转换为MySQL标准时间字符串（%Y-%m-%d %H:%M:%S）
        auto expires_at = std::chrono::system_clock::now() 
                        + std::chrono::seconds(expires_in_seconds);
        std::string expires_at_str = FormatDatetime(expires_at);

        // 插入用户会话SQL：防注入，使用参数化查询
        std::string sql = 
            "INSERT INTO user_sessions (user_id, token_hash, expires_at) "
            "VALUES (?, ?, ?)";

        // 执行参数化插入
        conn->Execute(sql, {
            std::to_string(user_id),
            token_hash,
            expires_at_str
        });

        LOG_INFO("Token saved for user_id={}, expires_at={}", user_id, expires_at_str);
        return Result<void>::Ok(); // 保存成功

    } catch (const MySQLDuplicateKeyException& e) {
        // 令牌哈希冲突（理论上SHA256几乎不会发生，做容错处理）
        LOG_ERROR("Duplicate token hash: {}", e.what());
        return Result<void>::Fail(ErrorCode::Internal, "Token 保存失败");

    } catch (const std::exception& e) {
        // 通用异常：数据库操作失败、连接异常等
        LOG_ERROR("SaveRefreshToken failed: {}", e.what());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable,
                                   GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

// ==================== 查询操作 ====================
/// 根据令牌哈希查询用户会话信息
/// @param token_hash 刷新令牌的SHA256哈希值
/// @return 统一结果对象：成功返回TokenSession，失败返回错误信息
Result<TokenSession> TokenRepository::FindByTokenHash(const std::string& token_hash) {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<TokenSession>);

        // 查询会话SQL：根据哈希精准查询
        std::string sql = 
            "SELECT id, user_id, token_hash, expires_at, created_at "
            "FROM user_sessions "
            "WHERE token_hash = ?";

        // 执行参数化查询
        auto res = conn->Query(sql, {token_hash});

        // 存在则解析行数据，返回会话信息
        if (res.Next()) {
            TokenSession session = ParseRow(res);
            LOG_DEBUG("Token found for user_id={}", session.user_id);
            return Result<TokenSession>::Ok(session);
        }

        // 令牌哈希不存在
        LOG_DEBUG("Token not found: hash={}", token_hash.substr(0, 8) + "...");
        return Result<TokenSession>::Fail(ErrorCode::TokenInvalid,
                                           GetErrorMessage(ErrorCode::TokenInvalid));

    } catch (const std::exception& e) {
        LOG_ERROR("FindByTokenHash failed: {}", e.what());
        return Result<TokenSession>::Fail(ErrorCode::ServiceUnavailable,
                                           GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

/// 校验令牌哈希是否有效（存在且未过期）
/// @param token_hash 刷新令牌的SHA256哈希值
/// @return 统一结果对象：成功返回bool（true=有效/false=无效）
Result<bool> TokenRepository::IsTokenValid(const std::string& token_hash) {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<bool>);

        // 校验SQL：存在且过期时间大于当前时间，LIMIT 1提升查询效率
        std::string sql = 
            "SELECT 1 FROM user_sessions "
            "WHERE token_hash = ? AND expires_at > NOW() "  // expires_at > NOW() ：未过期
            "LIMIT 1";

        auto res = conn->Query(sql, {token_hash});
        bool valid = res.Next(); // 有结果则有效，无则无效

        LOG_DEBUG("Token valid check: hash={}..., valid={}", 
                  token_hash.substr(0, 8), valid);
        return Result<bool>::Ok(valid);

    } catch (const std::exception& e) {
        LOG_ERROR("IsTokenValid failed: {}", e.what());
        return Result<bool>::Fail(ErrorCode::ServiceUnavailable,
                                   GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

/// 统计用户的有效会话数（未过期的刷新令牌数）
/// @param user_id 用户唯一标识
/// @return 统一结果对象：成功返回有效会话数
Result<int64_t> TokenRepository::CountActiveSessionsByUserId(int64_t user_id) {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<int64_t>);

        // 统计SQL：按用户ID查询未过期会话数
        std::string sql = 
            "SELECT COUNT(*) FROM user_sessions "
            "WHERE user_id = ? AND expires_at > NOW()";

        auto res = conn->Query(sql, {std::to_string(user_id)});

        int64_t count = 0;
        if (res.Next()) {
            count = res.GetInt(0).value_or(0); // 解析统计结果，默认0
        }

        LOG_DEBUG("Active sessions for user_id={}: {}", user_id, count);
        return Result<int64_t>::Ok(count);

    } catch (const std::exception& e) {
        LOG_ERROR("CountActiveSessionsByUserId failed: {}", e.what());
        return Result<int64_t>::Fail(ErrorCode::ServiceUnavailable,
                                      GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

// ==================== 删除操作 ====================
/// 根据令牌哈希删除会话（令牌失效/登出时调用）
/// @param token_hash 刷新令牌的SHA256哈希值
/// @return 统一结果对象：成功/失败（幂等性：删除不存在的令牌也算成功）
Result<void> TokenRepository::DeleteByTokenHash(const std::string& token_hash) {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<void>);

        // 删除SQL：根据哈希精准删除
        std::string sql = "DELETE FROM user_sessions WHERE token_hash = ?";
        auto affected = conn->Execute(sql, {token_hash}); // 受影响行数

        if (affected == 0) {
            LOG_DEBUG("Token not found for deletion: hash={}...", 
                      token_hash.substr(0, 8));
            // 幂等性设计：删除不存在的令牌，不返回错误
        } else {
            LOG_INFO("Token deleted: hash={}...", token_hash.substr(0, 8));
        }

        return Result<void>::Ok();

    } catch (const std::exception& e) {
        LOG_ERROR("DeleteByTokenHash failed: {}", e.what());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable,
                                   GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

/// 根据用户ID删除所有会话（用户登出所有设备/账号注销时调用）
/// @param user_id 用户唯一标识
/// @return 统一结果对象：成功/失败
Result<void> TokenRepository::DeleteByUserId(int64_t user_id) {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<void>);

        // 删除SQL：删除用户所有会话
        std::string sql = "DELETE FROM user_sessions WHERE user_id = ?";
        auto affected = conn->Execute(sql, {std::to_string(user_id)});

        LOG_INFO("Deleted {} sessions for user_id={}", affected, user_id);
        return Result<void>::Ok();

    } catch (const std::exception& e) {
        LOG_ERROR("DeleteByUserId failed: {}", e.what());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable,
                                   GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

/// 清理数据库中所有过期的令牌会话（定时任务调用，如每天凌晨）
/// @return 统一结果对象：成功返回清理的过期令牌数
Result<int64_t> TokenRepository::CleanExpiredTokens() {
    try {
        auto conn = pool_->CreateConnection();
        CHECK_CONN(conn, Result<int64_t>);

        // 清理SQL：删除过期时间小于等于当前时间的会话
        std::string sql = "DELETE FROM user_sessions WHERE expires_at <= NOW()";
        auto affected = conn->Execute(sql, {});

        LOG_INFO("Cleaned {} expired tokens", affected);
        return Result<int64_t>::Ok(static_cast<int64_t>(affected));

    } catch (const std::exception& e) {
        LOG_ERROR("CleanExpiredTokens failed: {}", e.what());
        return Result<int64_t>::Fail(ErrorCode::ServiceUnavailable,
                                      GetErrorMessage(ErrorCode::ServiceUnavailable));
    }
}

// ==================== 私有工具方法 ====================
/// 解析MySQL查询结果行，转换为TokenSession对象
/// @param res MySQL查询结果对象
/// @return 封装后的TokenSession会话对象
TokenSession TokenRepository::ParseRow(MySQLResult& res) {
    TokenSession session;
    session.id         = res.GetInt("id").value_or(0);        // 会话ID，默认0
    session.user_id    = res.GetInt("user_id").value_or(0);   // 用户ID，默认0
    session.token_hash = res.GetString("token_hash").value_or(""); // 令牌哈希，默认空
    session.expires_at = res.GetString("expires_at").value_or(""); // 过期时间字符串
    session.created_at = res.GetString("created_at").value_or(""); // 创建时间字符串
    return session;
}

/// 将系统时间戳转换为MySQL标准datetime字符串（%Y-%m-%d %H:%M:%S）
/// @param tp 系统时间点（chrono）
/// @return 格式化后的时间字符串，适配MySQL datetime类型
std::string TokenRepository::FormatDatetime(std::chrono::system_clock::time_point tp) {
    auto time_t_val = std::chrono::system_clock::to_time_t(tp);
    std::tm tm_val{};
    
    // 线程安全的本地时间转换：Windows用localtime_s，POSIX系统用localtime_r
#ifdef _WIN32
    localtime_s(&tm_val, &time_t_val);
#else
    localtime_r(&time_t_val, &tm_val);
#endif

    std::ostringstream oss;
    oss << std::put_time(&tm_val, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

/// 获取当前系统时间的MySQL标准datetime字符串
/// @return 格式化后的当前时间字符串
std::string TokenRepository::NowDatetime() {
    return FormatDatetime(std::chrono::system_clock::now());
}

#undef CHECK_CONN // 释放连接校验宏

} // namespace user_service

-----------------------------------------------------


// ====================== ./src/auth/token_cleanup_task.cpp ======================

// src/auth/token_cleanup_task.cpp

#include "auth/token_cleanup_task.h"

namespace user_service {

TokenCleanupTask::TokenCleanupTask(std::shared_ptr<TokenRepository> token_repo, int interval_minutes)
    : token_repo_(std::move(token_repo))
    , interval_(interval_minutes)
    , running_(false) {
}

TokenCleanupTask::~TokenCleanupTask() {
    Stop();  // 确保析构时停止线程
}

void TokenCleanupTask::Start() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 关键修复：如果已经在运行，直接返回
    if (running_.load()) {
        LOG_INFO("TokenCleanupTask already running, ignoring Start()");
        return;
    }
    
    // 关键修复：如果之前的线程还存在，先等待它结束
    if (thread_.joinable()) {
        thread_.join();
    }
    
    running_.store(true);
    
    thread_ = std::thread([this] {
        LOG_INFO("TokenCleanupTask started, interval = {} minutes", interval_);
        
        while (running_.load()) {
            // 清理过期 token
            try {
                auto result = token_repo_->CleanExpiredTokens();
                if (result.Success()) {
                    LOG_INFO("Token cleanup: removed {} expired tokens", *result.data);
                } else {
                    LOG_ERROR("Token cleanup failed: {}", result.message);
                }
            } catch (const std::exception& e) {
                LOG_ERROR("Token cleanup exception: {}", e.what());
            }
            
            // 等待下次执行（分段睡眠以便快速响应停止请求）
            for (int i = 0; i < interval_ * 60 && running_.load(); ++i) {
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }
        }
        
        LOG_INFO("TokenCleanupTask stopped");
    });
}

void TokenCleanupTask::Stop() {
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 设置停止标志
    running_.store(false);
    
    // 等待线程结束
    if (thread_.joinable()) {
        thread_.join();
    }
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./src/auth/CMakeLists.txt ======================

add_library(user_auth token_cleanup_task.cpp token_repository.cpp jwt_service.cpp sms_service.cpp)

target_include_directories(user_auth PUBLIC
    ${PROJECT_SOURCE_DIR}/include
    ${PROJECT_SOURCE_DIR}/include/auth
)

target_link_libraries(user_auth PUBLIC
    user_db
    user_common
    user_cache
    fmt::fmt
    OpenSSL::SSL
    OpenSSL::Crypto
)


-----------------------------------------------------


// ====================== ./src/auth/jwt_service.cpp ======================

#include "jwt_service.h"
#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <stdexcept>
#include <random>

namespace user_service {

// ============================================================================
// 构造函数
// ============================================================================

/// @brief 初始化 JWT 服务
/// @param config 安全配置，包含：
///   - jwt_secret: HMAC-SHA256 签名密钥（建议 32 字节以上）
///   - jwt_issuer: 签发者标识（如 "user-service"）
///   - access_token_ttl_seconds: Access Token 有效期（秒）
///   - refresh_token_ttl_seconds: Refresh Token 有效期（秒）
JwtService::JwtService(const SecurityConfig& config) : config_(config) {}

// ============================================================================
// Base64URL 编解码
// ============================================================================

/// @brief JWT 专用 Base64URL 编码
/// @details 与标准 Base64 的区别：
///   1. 字符集：使用 '-' 替代 '+'，'_' 替代 '/'（URL 安全）
///   2. 无 Padding：不添加末尾的 '=' 字符（JWT 标准要求）
/// @param input 原始二进制数据
/// @return Base64URL 编码字符串
/// @example "Hello" -> "SGVsbG8"
std::string JwtService::Base64UrlEncode(const std::string& input) {
    // Base64URL 字符表（64 个字符）
    static const char table[] = 
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    
    std::string encoded;
    encoded.reserve(((input.size() + 2) / 3) * 4);  // 预分配空间，3 字节 → 4 字符
    
    int val = 0, valb = -6;
    for (unsigned char c : input) {
        val = (val << 8) + c;       // 累积输入字节
        valb += 8;                   // 记录累积的位数
        while (valb >= 0) {
            encoded.push_back(table[(val >> valb) & 0x3F]);  // 取 6 位编码
            valb -= 6;
        }
    }
    // 处理剩余位（不足 6 位时补 0）
    if (valb > -6) {
        encoded.push_back(table[((val << 8) >> (valb + 8)) & 0x3F]);
    }
    // JWT 标准：不添加 '=' padding
    return encoded;
}

/// @brief JWT 专用 Base64URL 解码
/// @details 将 Base64URL 编码字符串还原为原始二进制数据
/// @param input Base64URL 编码字符串
/// @return 解码后的原始数据
/// @example "SGVsbG8" -> "Hello"
std::string JwtService::Base64UrlDecode(const std::string& input) {
    // 反向查找表：字符 → 6 位值，-1 表示非法字符
    static const int table[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  // 0x00-0x0F
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  // 0x10-0x1F
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,  // 0x20-0x2F ('-' = 62)
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  // 0x30-0x3F ('0'-'9' = 52-61)
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  // 0x40-0x4F ('A'-'O' = 0-14)
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,63,  // 0x50-0x5F ('P'-'Z' = 15-25, '_' = 63)
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  // 0x60-0x6F ('a'-'o' = 26-40)
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  // 0x70-0x7F ('p'-'z' = 41-51)
        // 0x80-0xFF 全部为 -1（非 ASCII 字符）
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    };
    
    std::string decoded;
    int val = 0, valb = -8;
    for (unsigned char c : input) {
        if (table[c] == -1) break;   // 遇到非法字符停止
        val = (val << 6) + table[c]; // 累积 6 位
        valb += 6;
        if (valb >= 0) {
            decoded.push_back(char((val >> valb) & 0xFF));  // 取 8 位输出
            valb -= 8;
        }
    }
    return decoded;
}

// ============================================================================
// HMAC-SHA256 签名
// ============================================================================

/// @brief 使用 HMAC-SHA256 算法生成消息认证码
/// @details JWT 签名算法 HS256 的核心实现：
///   签名 = HMAC-SHA256(密钥, Header.Payload)
/// @param key 签名密钥（jwt_secret）
/// @param data 待签名数据（Header.Payload 的 Base64URL 拼接）
/// @return 32 字节的二进制签名（需再经 Base64URL 编码）
std::string JwtService::HmacSha256(const std::string& key, const std::string& data) {
    unsigned char hash[EVP_MAX_MD_SIZE];  // 存储哈希结果
    unsigned int len = 0;
    
    // OpenSSL HMAC 函数
    HMAC(EVP_sha256(),                                              // 哈希算法：SHA-256
         key.c_str(), static_cast<int>(key.length()),               // 密钥
         reinterpret_cast<const unsigned char*>(data.c_str()),      // 待签名数据
         data.length(),
         hash, &len);                                                // 输出
    
    return std::string(reinterpret_cast<char*>(hash), len);  // 返回二进制签名
}

// ============================================================================
// 简易 JSON 工具（不依赖外部库）
// ============================================================================

/// @brief JSON 字符串转义
/// @details 处理 JSON 中的特殊字符，避免格式错误
/// @param s 原始字符串
/// @return 转义后的字符串
static std::string EscapeJsonString(const std::string& s) {
    std::string result;
    for (char c : s) {
        switch (c) {
            case '"':  result += "\\\""; break;  // 双引号
            case '\\': result += "\\\\"; break;  // 反斜杠
            case '\b': result += "\\b";  break;  // 退格
            case '\f': result += "\\f";  break;  // 换页
            case '\n': result += "\\n";  break;  // 换行
            case '\r': result += "\\r";  break;  // 回车
            case '\t': result += "\\t";  break;  // 制表符
            default:   result += c;      break;
        }
    }
    return result;
}

/// @brief 从键值对构建 JSON 字符串
/// @details 自动区分数字和字符串值：
///   - 数字值不加引号：{"exp": 1234567890}
///   - 字符串值加引号：{"uid": "abc-123"}
/// @param claims JWT 载荷的键值对
/// @return JSON 字符串
static std::string BuildJson(const std::map<std::string, std::string>& claims) {
    std::ostringstream oss;
    oss << "{";
    bool first = true;
    for (const auto& [key, value] : claims) {
        if (!first) oss << ",";
        first = false;
        oss << "\"" << EscapeJsonString(key) << "\":";
        
        // 判断是否为数字（以数字开头，或负号+数字）
        bool is_number = !value.empty() && 
            (isdigit(value[0]) || (value[0] == '-' && value.size() > 1));
        if (is_number) {
            oss << value;  // 数字不加引号
        } else {
            oss << "\"" << EscapeJsonString(value) << "\"";  // 字符串加引号
        }
    }
    oss << "}";
    return oss.str();
}

/// @brief 解析简单 JSON 对象为键值对
/// @details 仅支持 JWT 载荷的基础 JSON 格式：
///   - 单层对象
///   - 值为字符串或数字
///   - 不支持嵌套对象、数组
/// @param json JSON 字符串
/// @return 解析后的键值对
static std::map<std::string, std::string> ParseJson(const std::string& json) {
    std::map<std::string, std::string> result;
    
    size_t i = 0;
    
    // 跳过空白字符
    auto skip_whitespace = [&]() {
        while (i < json.size() && isspace(json[i])) i++;
    };
    
    // 解析 JSON 字符串（处理转义）
    auto parse_string = [&]() -> std::string {
        if (json[i] != '"') return "";
        i++;  // 跳过左引号
        std::string s;
        while (i < json.size() && json[i] != '"') {
            if (json[i] == '\\' && i + 1 < json.size()) {
                i++;
                switch (json[i]) {
                    case '"':  s += '"';  break;
                    case '\\': s += '\\'; break;
                    case 'n':  s += '\n'; break;
                    case 'r':  s += '\r'; break;
                    case 't':  s += '\t'; break;
                    default:   s += json[i]; break;
                }
            } else {
                s += json[i];
            }
            i++;
        }
        if (i < json.size()) i++;  // 跳过右引号
        return s;
    };
    
    // 解析值（字符串或数字）
    auto parse_value = [&]() -> std::string {
        skip_whitespace();
        if (i >= json.size()) return "";
        if (json[i] == '"') {
            return parse_string();  // 字符串值
        }
        // 数字/布尔值（直接读取到分隔符）
        std::string val;
        while (i < json.size() && json[i] != ',' && json[i] != '}') {
            if (!isspace(json[i])) val += json[i];
            i++;
        }
        return val;
    };
    
    skip_whitespace();
    if (i >= json.size() || json[i] != '{') return result;
    i++;  // 跳过 '{'
    
    while (i < json.size()) {
        skip_whitespace();
        if (json[i] == '}') break;
        if (json[i] == ',') { i++; continue; }
        
        std::string key = parse_string();
        skip_whitespace();
        if (i < json.size() && json[i] == ':') i++;
        std::string value = parse_value();
        
        if (!key.empty()) {
            result[key] = value;
        }
    }
    
    return result;
}

// ============================================================================
// JWT 核心操作
// ============================================================================

/// @brief 创建 JWT 令牌
/// @details JWT 结构（三段式，用 '.' 分隔）：
///   ┌──────────────────────────────────────────────────────────────┐
///   │  Header.Payload.Signature                                    │
///   ├──────────────────────────────────────────────────────────────┤
///   │  Header (固定):                                               │
///   │    {"alg":"HS256","typ":"JWT"}                               │
///   │    → Base64URL 编码后约 36 字符                                │
///   ├──────────────────────────────────────────────────────────────┤
///   │  Payload (可变):                                              │
///   │    由 claims 参数决定，见 GenerateAccessToken/RefreshToken    │
///   │    → Base64URL 编码后长度随内容变化                            │
///   ├──────────────────────────────────────────────────────────────┤
///   │  Signature:                                                  │
///   │    HMAC-SHA256(secret, Header.Payload)                       │
///   │    → Base64URL 编码后约 43 字符                                │
///   └──────────────────────────────────────────────────────────────┘
/// 
/// @param claims JWT 载荷（键值对）
/// @param secret 签名密钥
/// @return 完整的 JWT 字符串
std::string JwtService::CreateJwt(const std::map<std::string, std::string>& claims,
                                   const std::string& secret) {
    // 1. JWT Header（固定值）
    //    alg: 签名算法，使用 HMAC-SHA256
    //    typ: 令牌类型，固定为 JWT
    std::string header = R"({"alg":"HS256","typ":"JWT"})";
    std::string header_b64 = Base64UrlEncode(header);
    
    // 2. JWT Payload（由 claims 构建）
    std::string payload = BuildJson(claims);
    std::string payload_b64 = Base64UrlEncode(payload);
    
    // 3. JWT Signature
    //    签名输入 = Header_Base64 + "." + Payload_Base64
    //    签名 = Base64URL(HMAC-SHA256(secret, 签名输入))
    std::string signature_input = header_b64 + "." + payload_b64;
    std::string signature = Base64UrlEncode(HmacSha256(secret, signature_input));
    
    // 4. 拼接完整 JWT
    return signature_input + "." + signature;
}

/// @brief 验证 JWT 令牌
/// @details 验证流程：
///   1. 格式检查：必须包含两个 '.' 分隔符
///   2. 签名验证：重新计算签名并比对
///   3. 过期检查：比对 exp 字段与当前时间
/// @param token 待验证的 JWT 字符串
/// @param secret 签名密钥
/// @return 验证结果（包含 success 标志和解析后的 claims）
JwtService::JwtVerifyResult JwtService::VerifyJwt(
    const std::string& token, const std::string& secret) {
    
    JwtVerifyResult result;
    result.success = false;
    
    // ========== 1. 格式校验 ==========
    // JWT 格式：Header.Payload.Signature（必须有两个 '.'）
    size_t dot1 = token.find('.');
    size_t dot2 = token.find('.', dot1 + 1);
    if (dot1 == std::string::npos || dot2 == std::string::npos) {
        result.error_code = ErrorCode::TokenInvalid;
        return result;
    }
    
    // 分割三段
    std::string header_b64 = token.substr(0, dot1);
    std::string payload_b64 = token.substr(dot1 + 1, dot2 - dot1 - 1);
    std::string signature = token.substr(dot2 + 1);
    
    // ========== 2. 签名验证 ==========
    // 重新计算签名，与令牌中的签名比对
    std::string signature_input = header_b64 + "." + payload_b64;
    std::string expected_signature = Base64UrlEncode(HmacSha256(secret, signature_input));
    if (signature != expected_signature) {
        result.error_code = ErrorCode::TokenInvalid;  // 签名不匹配，令牌被篡改
        return result;
    }
    
    // ========== 3. 解析 Payload ==========
    std::string payload_json = Base64UrlDecode(payload_b64);
    result.claims = ParseJson(payload_json);
    
    // ========== 4. 过期时间校验 ==========
    if (result.claims.count("exp")) {
        try {
            int64_t exp = std::stoll(result.claims["exp"]);
            auto now = std::chrono::system_clock::now();
            auto exp_time = std::chrono::system_clock::from_time_t(exp);
            if (now > exp_time) {
                result.error_code = ErrorCode::TokenExpired;  // 令牌已过期
                return result;
            }
        } catch (...) {
            result.error_code = ErrorCode::TokenInvalid;  // exp 格式错误
            return result;
        }
    }
    
    result.success = true;
    result.error_code = ErrorCode::Ok;
    return result;
}

// ============================================================================
// Token 生成接口
// ============================================================================

/// @brief 生成 Access Token 和 Refresh Token 令牌对
/// @details 双令牌机制说明：
///   ┌────────────────────────────────────────────────────────────────┐
///   │  Access Token                                                  │
///   │  ├─ 用途：业务接口鉴权（放在 Authorization: Bearer xxx）        │
///   │  ├─ 有效期：短（如 2 小时），减少泄露风险                        │
///   │  └─ 载荷：包含完整用户信息（id, uuid, mobile）                  │
///   ├────────────────────────────────────────────────────────────────┤
///   │  Refresh Token                                                 │
///   │  ├─ 用途：仅用于刷新 Access Token                              │
///   │  ├─ 有效期：长（如 7 天），支持用户长期在线                      │
///   │  └─ 载荷：仅包含用户 ID，最小化信息暴露                         │
///   └────────────────────────────────────────────────────────────────┘
/// 
/// @param user 用户实体（包含 id, uuid, mobile 等字段）
/// @return TokenPair 包含两个令牌和 Access Token 过期时间（秒）
TokenPair JwtService::GenerateTokenPair(const UserEntity& user) {
    TokenPair result;
    result.access_token = GenerateAccessToken(user);
    result.refresh_token = GenerateRefreshToken(user);
    result.expires_in = config_.access_token_ttl_seconds;  // Access Token 有效期（秒）
    return result;
}

/// @brief 生成 Access Token（访问令牌）
/// @details
///   ┌────────────────────────────────────────────────────────────────┐
///   │  Access Token JWT Payload 结构                                 │
///   ├──────────┬─────────────────────────────────────────────────────┤
///   │  字段    │  说明                                               │
///   ├──────────┼─────────────────────────────────────────────────────┤
///   │  iss     │  签发者（Issuer），如 "user-service"                 │
///   │  sub     │  主题（Subject），固定为 "access" 标识令牌类型        │
///   │  id      │  用户数据库 ID（int64_t），用于内部快速查库           │
///   │  uid     │  用户 UUID，对外暴露的用户标识（API 返回用）          │
///   │  mobile  │  用户手机号，业务需要时可直接从令牌获取               │
///   │  iat     │  签发时间（Issued At），Unix 时间戳（秒）             │
///   │  exp     │  过期时间（Expiration），Unix 时间戳（秒）            │
///   │  jti     │  JWT ID，随机数，确保每次生成的令牌唯一               │
///   └──────────┴─────────────────────────────────────────────────────┘
/// 
///   示例 Payload（解码后）：
///   {
///     "iss": "user-service",
///     "sub": "access",
///     "id": "12345",
///     "uid": "550e8400-e29b-41d4-a716-446655440000",
///     "mobile": "13800138000",
///     "iat": 1704067200,
///     "exp": 1704074400,
///     "jti": "582943"
///   }
/// 
/// @param user_id 用户数据库 ID（字符串格式）
/// @param user_uuid 用户 UUID
/// @param mobile 用户手机号
/// @return JWT 格式的 Access Token 字符串
std::string JwtService::GenerateAccessToken(const UserEntity& user) {
    
    auto now = std::chrono::system_clock::now();
    auto exp = now + std::chrono::seconds(config_.access_token_ttl_seconds);
    
    // 随机数生成器（用于 jti 字段，确保令牌唯一性）
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(100000, 999999);
    
    // 构建 JWT Claims
    std::map<std::string, std::string> claims;
    claims["iss"] = config_.jwt_issuer;   // 签发者
    claims["sub"] = "access";              // 令牌类型标识
    claims["id"]  = std::to_string(user.id);               // 数据库用户 ID（内部使用）
    claims["uid"] = user.uuid;             // 用户 UUID（对外暴露）
    claims["mobile"] = user.mobile;        // 手机号
    claims["role"] = UserRoleToString(user.role);
    claims["iat"] = std::to_string(std::chrono::system_clock::to_time_t(now));  // 签发时间
    claims["exp"] = std::to_string(std::chrono::system_clock::to_time_t(exp));  // 过期时间
    claims["jti"] = std::to_string(dis(gen));  // JWT ID（6 位随机数）
    
    return CreateJwt(claims, config_.jwt_secret);
}

/// @brief 生成 Refresh Token（刷新令牌）
/// @details
///   ┌────────────────────────────────────────────────────────────────┐
///   │  Refresh Token JWT Payload 结构                                │
///   ├──────────┬─────────────────────────────────────────────────────┤
///   │  字段    │  说明                                               │
///   ├──────────┼─────────────────────────────────────────────────────┤
///   │  iss     │  签发者（Issuer），如 "user-service"                 │
///   │  sub     │  主题（Subject），固定为 "refresh" 标识令牌类型       │
///   │  uid     │  用户数据库 ID，用于查库获取用户信息生成新令牌        │
///   │  iat     │  签发时间（Issued At），Unix 时间戳（秒）             │
///   │  exp     │  过期时间（Expiration），Unix 时间戳（秒）            │
///   │  jti     │  JWT ID，随机数，确保每次生成的令牌唯一               │
///   └──────────┴─────────────────────────────────────────────────────┘
/// 
///   示例 Payload（解码后）：
///   {
///     "iss": "user-service",
///     "sub": "refresh",
///     "uid": "12345",
///     "iat": 1704067200,
///     "exp": 1704672000,
///     "jti": "847291"
///   }
/// 
///   与 Access Token 的区别：
///   1. sub = "refresh"（用于区分令牌类型）
///   2. 仅包含 uid（数据库 ID），不包含 uuid、mobile
///   3. 有效期更长（如 7 天 vs 2 小时）
///   4. 仅用于调用 RefreshToken 接口，不能用于业务鉴权
/// 
/// @param user_id 用户数据库 ID（字符串格式）
/// @return JWT 格式的 Refresh Token 字符串
std::string JwtService::GenerateRefreshToken(const UserEntity& user) {
    auto now = std::chrono::system_clock::now();
    auto exp = now + std::chrono::seconds(config_.refresh_token_ttl_seconds);
    
    // 随机数生成器（确保同一秒内生成的 token 不同）
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(100000, 999999);
    
    // 构建 JWT Claims（最小化载荷）
    std::map<std::string, std::string> claims;
    claims["iss"] = config_.jwt_issuer;   // 签发者
    claims["sub"] = "refresh";             // 令牌类型标识
    claims["uid"] = std::to_string(user.id);      // 用户数据库 ID（注意：这里是数据库 ID，不是 UUID）
    claims["iat"] = std::to_string(std::chrono::system_clock::to_time_t(now));  // 签发时间
    claims["exp"] = std::to_string(std::chrono::system_clock::to_time_t(exp));  // 过期时间
    claims["jti"] = std::to_string(dis(gen));  // JWT ID（6 位随机数）
    
    return CreateJwt(claims, config_.jwt_secret);
}

// ============================================================================
// Token 验证/解析接口
// ============================================================================

/// @brief 验证 Access Token 并解析载荷
/// @details 验证流程：
///   1. 空值检查
///   2. JWT 签名和过期时间验证（调用 VerifyJwt）
///   3. 签发者校验（iss 必须匹配配置）
///   4. 令牌类型校验（sub 必须为 "access"）
///   5. 必要字段检查（id, uid 必须存在）
///   6. 解析并返回结构化载荷
/// 
/// @param token Access Token 字符串
/// @return Result<AccessTokenPayload> 成功时返回解析后的载荷
///         载荷包含：user_id, user_uuid, mobile, expires_at
Result<AccessTokenPayload> JwtService::VerifyAccessToken(const std::string& token) {
    // ========== 1. 参数校验 ==========
    if (token.empty()) {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenMissing, "Token 不能为空");
    }
    
    // ========== 2. JWT 验证（签名 + 过期时间）==========
    auto verify_result = VerifyJwt(token, config_.jwt_secret);
    if (!verify_result.success) {
        return Result<AccessTokenPayload>::Fail(verify_result.error_code);
    }
    
    const auto& claims = verify_result.claims;
    
    // ========== 3. 签发者校验 ==========
    auto iss_it = claims.find("iss");
    if (iss_it != claims.end() && iss_it->second != config_.jwt_issuer) {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "令牌签发者不匹配");
    }
    
    // ========== 4. 令牌类型校验 ==========
    // 确保是 Access Token，而不是 Refresh Token
    auto sub_it = claims.find("sub");
    if (sub_it != claims.end() && sub_it->second != "access") {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "令牌类型不匹配");
    }
    
    // ========== 5. 必要字段检查 ==========
    auto id_it = claims.find("id");       // 数据库 ID
    auto uid_it = claims.find("uid");     // UUID
    auto mobile_it = claims.find("mobile");
    auto role_it = claims.find("role");
    
    if (id_it == claims.end() || id_it->second.empty()) {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "令牌缺少用户ID");
    }
    if (uid_it == claims.end() || uid_it->second.empty()) {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "令牌缺少用户UUID");
    }
    if(role_it==claims.end() || role_it->second.empty()){
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "令牌缺少用户ROLE");
    }
    
    // ========== 6. 解析为结构化载荷 ==========
    AccessTokenPayload payload;
    
    // 解析 user_id (int64_t)
    try {
        payload.user_id = std::stoll(id_it->second);
    } catch (...) {
        return Result<AccessTokenPayload>::Fail(ErrorCode::TokenInvalid, "用户ID格式错误");
    }
    
    // 解析 user_uuid (string)
    payload.user_uuid = uid_it->second;
    
    // 解析 mobile (可选字段)
    if (mobile_it != claims.end()) {
        payload.mobile = mobile_it->second;
    }
    
    // 解析 role
    payload.role=StringToUserRole(role_it->second);

    // 解析过期时间
    auto exp_it = claims.find("exp");
    if (exp_it != claims.end()) {
        try {
            int64_t exp = std::stoll(exp_it->second);
            payload.expires_at = std::chrono::system_clock::from_time_t(exp);
        } catch (...) {
            payload.expires_at = std::chrono::system_clock::now();  // 解析失败使用当前时间
        }
    }
    
    return Result<AccessTokenPayload>::Ok(payload);
}

/// @brief 验证 Refresh Token 并提取用户 ID
/// @details 验证流程：
///   1. 空值检查
///   2. JWT 签名和过期时间验证
///   3. 签发者校验
///   4. 令牌类型校验（sub 必须为 "refresh"）
///   5. 提取用户数据库 ID
/// 
///   注意：返回的是数据库 ID（用于查库生成新令牌），不是 UUID
/// 
/// @param token Refresh Token 字符串
/// @return Result<std::string> 成功时返回用户数据库 ID
Result<std::string> JwtService::ParseRefreshToken(const std::string& token) {
    // ========== 1. 参数校验 ==========
    if (token.empty()) {
        return Result<std::string>::Fail(ErrorCode::TokenMissing, "Token 不能为空");
    }
    
    // ========== 2. JWT 验证 ==========
    auto verify_result = VerifyJwt(token, config_.jwt_secret);
    if (!verify_result.success) {
        return Result<std::string>::Fail(verify_result.error_code);
    }
    
    const auto& claims = verify_result.claims;
    
    // ========== 3. 签发者校验 ==========
    auto iss_it = claims.find("iss");
    if (iss_it != claims.end() && iss_it->second != config_.jwt_issuer) {
        return Result<std::string>::Fail(ErrorCode::TokenInvalid, "令牌签发者不匹配");
    }
    
    // ========== 4. 令牌类型校验 ==========
    // 确保是 Refresh Token，而不是 Access Token
    auto sub_it = claims.find("sub");
    if (sub_it != claims.end() && sub_it->second != "refresh") {
        return Result<std::string>::Fail(ErrorCode::TokenInvalid, "令牌类型不匹配");
    }
    
    // ========== 5. 提取用户 ID ==========
    auto uid_it = claims.find("uid");
    if (uid_it != claims.end() && !uid_it->second.empty()) {
        return Result<std::string>::Ok(uid_it->second);  // 返回数据库 ID
    }
    
    return Result<std::string>::Fail(ErrorCode::TokenInvalid, "令牌缺少用户标识");
}

// ============================================================================
// Token 哈希（用于安全存储）
// ============================================================================

/// @brief 对 Token 进行 SHA256 哈希
/// @details 用于服务端存储 Token 时避免明文：
///   1. 数据库存储 Refresh Token 时，存哈希值而非原文
///   2. 验证时：Hash(用户传的Token) == 数据库存储的哈希值
///   3. 即使数据库泄露，攻击者也无法还原原始 Token
/// 
/// @param token 原始 Token 字符串
/// @return 64 字符的十六进制哈希字符串（SHA256 = 32 字节 = 64 hex）
/// @example "eyJhbG..." → "a1b2c3d4e5f6..."
std::string JwtService::HashToken(const std::string& token) {
    unsigned char hash[SHA256_DIGEST_LENGTH];  // 32 字节
    SHA256(reinterpret_cast<const unsigned char*>(token.c_str()), 
           token.length(), hash);
    
    // 转换为十六进制字符串
    std::stringstream ss;
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }
    return ss.str();  // 64 字符
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/auth/sms_service.cpp ======================

#include "sms_service.h"
#include "common/logger.h"

#include <random>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>

namespace user_service{

SmsService::SmsService(std::shared_ptr<RedisClient> redis, const SmsConfig& config)
    : redis_(std::move(redis)), config_(config) {
}

// 发送验证码
Result<int32_t> SmsService::SendCaptcha(SmsScene scene,
                                    const std::string& mobile){

    // 辅助 lambda：安全获取 TTL（秒）
    auto safeTTLSeconds = [this](const std::string& key, int64_t default_val = 60) -> int64_t {
        auto r = redis_->PTTL(key);
        if (r.IsOk() && r.Value() > 0) {
            return r.Value() / 1000;
        }
        return default_val;
    };

    // 1.检查是否被锁定（如：验证失败超出限度，被锁的）
    auto lock_exists=redis_->Exists(LockKey(scene,mobile));
    if(!lock_exists.IsOk()){
        // Redis 故障，保守起见拒绝发送
        LOG_ERROR("Redis error when checking lock: {}", lock_exists.message);
        return Result<int32_t>::Fail(ErrorCode::ServiceUnavailable, 
                                            "服务暂时不可用，请稍后重试");
    }
    
    if(lock_exists.Value()){
        // 被锁的
        int64_t ttl = safeTTLSeconds(LockKey(scene, mobile), config_.lock_seconds);
        return Result<int32_t>::Fail(
                        ErrorCode::RateLimited,
                        fmt::format("操作过于频繁，请{}秒后再试", ttl));
    }

    // 2.检查发送间隔
    auto interval_exists=redis_->Exists(IntervalKey(mobile));
    if(!interval_exists.IsOk()){
        LOG_ERROR("Redis error when checking interval: {}", interval_exists.message);
        return Result<int32_t>::Fail(ErrorCode::ServiceUnavailable,
                                            "服务暂时不可用，请稍后重试");
    }
    if(interval_exists.Value()){
        int64_t ttl = safeTTLSeconds(IntervalKey(mobile), config_.send_interval_seconds);
        return Result<int32_t>::Fail(
                        ErrorCode::RateLimited,
                        fmt::format("操作过于频繁，请{}秒后再试", ttl));               
    }

    // 3.生成验证码
    std::string code=GenerateCaptcha();

    // 4.存储到Redis（原子操作）
    // 存储验证码（关键操作，必须成功）
    auto set_code=redis_->SetPx(CaptchaKey(scene,mobile),code,
                    std::chrono::milliseconds(config_.code_ttl_seconds*1000));
    
    if (!set_code.IsOk()) {
        LOG_ERROR("Failed to store sms code: {}", set_code.message);
        return Result<int32_t>::Fail(ErrorCode::ServiceUnavailable,
                                            "服务暂时不可用，请稍后重试");
    }
    

    // 存储发送间隔（非关键，失败可忽略）
    auto set_interval=redis_->SetPx(IntervalKey(mobile),"1",
                    std::chrono::milliseconds(config_.send_interval_seconds*1000));

    if (!set_interval.IsOk()) {
        LOG_WARN("Failed to set interval key: {}", set_interval.message);
        // 不影响主流程，继续
    }

    // 5.发送短信
    auto send_result = DoSend(mobile, code, scene);

    if(!send_result.IsOk()){
        // 内部错误，进行日志输出
        LOG_ERROR("SMS send failed: mobile={}", mobile);
        // 发送失败，清理已存储的验证码（回滚）
        redis_->Del(CaptchaKey(scene, mobile));
        return Result<int32_t>::Fail(ErrorCode::ServiceUnavailable,
                                        "短信发送失败，请稍后重试");
    }

    LOG_INFO("SMS sent: mobile={}, scene={}", mobile, SceneName(scene));

    int32_t result=config_.send_interval_seconds;
    return Result<int32_t>::Ok(result);
}

// 验证验证码
Result<void> SmsService::VerifyCaptcha(SmsScene scene,
                        const std::string& mobile,
                        const std::string& input_code){
    
    // 辅助 lambda：安全获取 TTL（秒）
    auto safeTTLSeconds = [this](const std::string& key, int64_t default_val = 60) -> int64_t {
        auto r = redis_->PTTL(key);
        if (r.IsOk() && r.Value() > 0) {
            return r.Value() / 1000;
        }
        return default_val;
    };


    // 1.检查是否被锁定（如：验证失败超出限度，被锁的）
    auto lock_exists=redis_->Exists(LockKey(scene,mobile));
    if(!lock_exists.IsOk()){
         // Redis 故障，保守起见拒绝验证（防止暴力破解绕过）
        LOG_ERROR("Redis error when checking lock: {}", lock_exists.message);
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, 
                                            "服务暂时不可用，请稍后重试");
    }
    
    if(lock_exists.Value()){
        // 被锁定
        int64_t ttl= safeTTLSeconds(LockKey(scene, mobile), config_.retry_ttl_seconds);
        return Result<void>::Fail(
                        ErrorCode::RateLimited,
                        fmt::format("操作过于频繁，请{}秒后再试", ttl));
    }

    // 2.获取正确的验证码
    auto stored_code_result = redis_->Get(CaptchaKey(scene, mobile));
    if (!stored_code_result.IsOk()) {
        LOG_ERROR("Redis error when getting code: {}", stored_code_result.message);
        return Result<void>::Fail(ErrorCode::ServiceUnavailable,
                                  "服务暂时不可用，请稍后重试");
    }
    if (!stored_code_result.Value().has_value()) {
        // 未找到验证码
        return Result<void>::Fail(
            ErrorCode::CaptchaExpired,
            "验证码已过期，请重新获取");
    }
    const std::string& stored_code = stored_code_result.Value().value();

    // 3.对比验证码
    if(input_code!=stored_code){
        // 增加错误计数
        auto count_result = redis_->Incr(VerifyCountKey(scene, mobile));
        if (!count_result.IsOk()) {
            // 计数失败，保守拒绝（防止无限尝试）
            LOG_ERROR("Redis INCR failed: {}", count_result.message);
            return Result<void>::Fail(ErrorCode::ServiceUnavailable,
                                      "服务暂时不可用，请稍后重试");
        }

        int64_t count = count_result.Value();

        // 设置计数器过期时间（失败可忽略）
        redis_->PExpire(VerifyCountKey(scene, mobile),
                        std::chrono::milliseconds(config_.retry_ttl_seconds * 1000));

        // 失败次数超出最大限度
        if (count >= config_.max_retry_count) {
            // 触发锁定
            redis_->SetPx(LockKey(scene, mobile), "1",
                          std::chrono::milliseconds(config_.lock_seconds * 1000));
            redis_->Del(CaptchaKey(scene, mobile));       // 删除验证码
            redis_->Del(VerifyCountKey(scene, mobile)); // 删除计数器
            // “间隔”不能删，因为是全局的，会影响其它场景

            LOG_WARN("SMS verify locked: mobile={}, scene={}", mobile, SceneName(scene));

            return Result<void>::Fail(
                ErrorCode::AccountLocked,
                fmt::format("错误次数过多，请{}分钟后再试", config_.lock_seconds / 60));
        }
        // 验证码错误的返回
        return Result<void>::Fail(ErrorCode::CaptchaWrong, 
            fmt::format("验证码错误，还剩{}次机会", 
                        config_.max_retry_count - count));
    }

    // 4. 验证成功，清理错误计数
    /* 不删除验证码，如：
        验证码正确 → 创建用户（可能失败：用户名冲突、数据库异常）
                 ↓ 失败
           用户想用同一个验证码重试
    */
    redis_->Del(VerifyCountKey(scene, mobile));

    LOG_INFO("SMS verify success: mobile={}, scene={}", mobile, SceneName(scene));
    return Result<void>::Ok();
}

// 消费验证码（业务成功后调用，防止重复使用）
Result<void> SmsService::ConsumeCaptcha(SmsScene scene, const std::string& mobile){
    redis_->Del(CaptchaKey(scene, mobile));
    LOG_INFO("SMS code consumed: mobile={}, scene={}", mobile, SceneName(scene));
    return Result<void>::Ok();
}


// ==================== 实际发送短信 ====================
// 实际发送短信（对接服务商）
Result<void> SmsService::DoSend(const std::string& mobile, const std::string& code, SmsScene scene){
    // TODO: 对接实际短信服务商
    
    // 开发环境：打印到日志
    LOG_INFO("[DEV SMS] mobile={}, code={}, scene={}", 
        mobile, code, SceneName(scene));

    // 模拟随机失败（测试用）
    // if (rand() % 10 == 0) {
    //     return Result<void>::Fail(ErrorCode::ServiceUnavailable, "模拟发送失败");
    // }

    return Result<void>::Ok();
}

// 生成随机验证码
std::string SmsService::GenerateCaptcha() {

    LOG_INFO("测试模式“验证码”：123456。");
    return "123456";  // 临时：固定验证码用于测试

    // 静态局部变量：仅初始化一次，提升性能，避免频繁创建随机数对象
    static std::random_device rd;                // 随机数种子源，获取硬件/系统随机数
    static std::mt19937 gen(rd());               // 梅森旋转算法生成器，高性能、高随机性
    static std::uniform_int_distribution<> dis(0, 9); // 均匀分布，确保0-9每个数字概率均等
    
    std::string code;
    code.reserve(config_.code_len); // 预分配内存，避免字符串拼接时多次扩容，提升效率
    for (int i = 0; i < config_.code_len; ++i) {
        code += std::to_string(dis(gen)); // 循环生成单个数字，拼接为验证码
    }
    return code;
}



// ==================== Key 生成 ====================

// 场景名称
std::string SmsService::SceneName(SmsScene scene){
    switch(scene){
        case SmsScene::Register:        return "register";
        case SmsScene::Login:           return "login";
        case SmsScene::ResetPassword:   return "reset_password";
        case SmsScene::DeleteUser:      return "delete_user";
        default:                        return "unknown";
    }
}

/*
作用：生成短信验证码本身的缓存 Key
存储值：实际的短信验证码（如682915）+ 过期时间（通常 5-10 分钟，验证码有效期）
绑定 scene 原因：同一个手机号在不同场景的验证码独立（比如登录发了682915，注册可同时发954278，不会覆盖）
典型 Key 示例：sms:code:login:13812345678、sms:code:find_pwd:13812345678
*/
std::string SmsService::CaptchaKey(SmsScene scene, const std::string& mobile){
    return "sms:code:"+SceneName(scene)+":"+mobile;
}

/*
作用：生成短信发送间隔的缓存 Key（防频繁发送）
存储值：最后一次发送短信的时间戳（如1735689600）
设计原因：基础限流规则 —— 无论哪个场景，同一个手机号短时间内不能反复发验证码（比如默认 60 秒内只能发 1 次），无需绑定 scene（全局间隔限制）
典型 Key 示例：sms:interval:13812345678
*/
std::string SmsService::IntervalKey(const std::string& mobile){
    return "sms:interval:"+mobile;
}

/*
作用：生成单场景验证码验证失败次数的缓存 Key（防暴力破解）
存储值：该场景下，手机号累计验证验证码失败的次数（如2）
绑定 scene 原因：不同场景的验证失败次数独立（比如登录验证失败 2 次，不影响注册场景）
设计原因：防暴力破解验证码 —— 限制单场景下的失败次数（比如最多失败 3 次），超过则临时锁定该场景的短信发送 / 验证，避免攻击者枚举验证码
典型 Key 示例：sms:verify_count:login:13812345678
*/
std::string SmsService::VerifyCountKey(SmsScene scene, const std::string& mobile){
    return "sms:verify_count:"+SceneName(scene)+":"+mobile;
}

/*
作用：生成单场景短信临时锁定的缓存 Key（风控兜底）
存储值：锁定状态（如1）+ 锁定过期时间（比如 10 分钟，自动解锁）
绑定 scene 原因：锁定仅针对当前场景（比如登录场景被锁，注册场景仍可正常使用）
设计原因：兜底风控 —— 当满足「验证失败次数超限」「发送间隔频繁突破」等风险条件时，临时锁定该场景的短信服务，避免进一步的恶意操作，且非全局锁定，不影响用户其他业务操作，兼顾风控和用户体验
典型 Key 示例：sms:lock:login:13812345678
*/
std::string SmsService::LockKey(SmsScene scene, const std::string& mobile){
    return "sms:lock:"+SceneName(scene)+":"+mobile;
}


}

-----------------------------------------------------


// ====================== ./src/CMakeLists.txt ======================

add_subdirectory(config)
add_subdirectory(common)
add_subdirectory(db)
add_subdirectory(cache)
add_subdirectory(services)
add_subdirectory(auth)
add_subdirectory(handlers)
add_subdirectory(discovery)
add_subdirectory(server)
add_subdirectory(client)

# add_executable(user_service_server
#     main.cpp
# )

# target_link_libraries(user_service_server   
#     proto_lib          # proto
#     user_handler      # auth_handler, user_handler
#     user_service       # auth_service, user_service
#     user_auth          # jwt_service, sms_service, authenticator, token_repository
#     user_db            # user_db, mysql_connection
#     user_cache         # redis_client
#     user_common        # logger, validator, error_codes
#     user_config        # config
#     ${GRPC_LIBRARIES}
#     ${PROTOBUF_LIBRARIES}
# )

# target_include_directories(user_service_server PRIVATE
#     ${PROJECT_SOURCE_DIR}/include
#     ${PROJECT_SOURCE_DIR}/src
# )

-----------------------------------------------------


// ====================== ./src/services/CMakeLists.txt ======================

add_library(user_service auth_service.cpp user_service.cpp)


target_include_directories(user_service 
    PUBLIC
    ${PROJECT_SOURCE_DIR}/include
    ${PROJECT_SOURCE_DIR}/include/service
    ${CMAKE_CURRENT_SOURCE_DIR}

)

target_link_libraries(user_service 
    PUBLIC
    user_auth
    user_cache
    user_common
    user_config
    user_db
)

-----------------------------------------------------


// ====================== ./src/services/auth_service.cpp ======================

#include "auth_service.h"

#include "common/logger.h"
#include "common/validator.h"
#include "common/password_helper.h"
#include "entity/user_entity.h"
#include "common/time_utils.h"

namespace user_service{

AuthService::AuthService(std::shared_ptr<Config> config,
                            std::shared_ptr<UserDB> user_db,
                            std::shared_ptr<RedisClient> redis_cli,
                            std::shared_ptr<TokenRepository> token_repo,
                            std::shared_ptr<JwtService> jwt_srv,
                            std::shared_ptr<SmsService> sms_srv)
    : config_(config),
      user_db_(user_db),
      redis_cli_(redis_cli),
      token_repo_(token_repo),
      jwt_srv_(jwt_srv),
      sms_srv_(sms_srv)
    {}

// 发送验证码
Result<int32_t> AuthService::SendVerifyCode(const std::string& mobile, SmsScene scene) {
    std::string error;
    
    // 1. 手机格式校验
    if (!IsValidMobile(mobile, error)) {
        return Result<int32_t>::Fail(ErrorCode::InvalidArgument, error);
    }

    // 2. 业务校验
    if (scene == SmsScene::Register) {
        // 注册：手机号不能已存在
        auto res = user_db_->ExistsByMobile(mobile);
        if (!res.IsOk()) {
            return Result<int32_t>::Fail(res.code, res.message);
        }
        if (res.Value()) {
            return Result<int32_t>::Fail(ErrorCode::MobileTaken, "该手机号已被用于注册");
        }
    } else if (scene == SmsScene::Login || 
               scene == SmsScene::ResetPassword || 
               scene == SmsScene::DeleteUser) {
        // 登录/重置密码/注销：手机号必须已存在
        auto res = user_db_->ExistsByMobile(mobile);
        if (!res.IsOk()) {
            return Result<int32_t>::Fail(res.code, res.message);
        }
        if (!res.Value()) {
            return Result<int32_t>::Fail(ErrorCode::UserNotFound, "该手机号未注册");
        }
    }
    // 其他场景不做额外校验

    // 3. 发送短信
    auto send_captcha_result = sms_srv_->SendCaptcha(scene, mobile);
    return send_captcha_result;
}

// 注册 
Result<AuthResult> AuthService::Register(const std::string& mobile,
    const std::string& verify_code,
    const std::string& password,
    const std::string& display_name){
    
    std::string error;
    // 1.参数校验
    if (!IsValidMobile(mobile,error)) {
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,error);
    }
    if (!IsValidPassword(password,error,config_->password)) {
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,error);
    }
    if (!IsValidVerifyCode(verify_code,error,config_->sms)) {
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,error);
    }
    if(!IsValidDisplayName(display_name,error)){
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,error);
    }

    // 2.验证“验证码”
    auto verify_result=sms_srv_->VerifyCaptcha(SmsScene::Register,mobile,verify_code);
    if(!verify_result.IsOk()){
        return Result<AuthResult>::Fail(verify_result.code,verify_result.message);
    }

    // 3.构建用户
    UserEntity user;
    user.mobile=mobile;
    user.password_hash=PasswordHelper::Hash(password);
    user.display_name=display_name;

    // 4.创建用户
    auto create_res=user_db_->Create(user);
    if(!create_res.IsOk()){
        // 创建失败
        return Result<AuthResult>::Fail(create_res.code,create_res.message);
    }

    auto& created_user=create_res.data.value();    // 创建的user

    // 5.生成Token
    auto token_pair=jwt_srv_->GenerateTokenPair(created_user);

    // 6.存储Refresh Token
    auto store_res=StoreRefreshToken(created_user.id,token_pair.refresh_token);

    // 7.返回结果
    AuthResult  result;
    result.user=created_user;
    result.user.password_hash.clear(); // 清除密码（不返回密码）
    result.tokens=token_pair;

    LOG_INFO("User registered: mobile={}, uuid={}", mobile, created_user.uuid);
    return Result<AuthResult>::Ok(result);
}

// 
Result<AuthResult> AuthService::LoginByPassword(const std::string& mobile,
                                    const std::string& password){

    // 1.参数校验                                    
    std::string err;
    if(!IsValidMobile(mobile,err)){
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,err);
    }

    if(!IsValidPassword(password,err,config_->password)){
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument,err);
    }

    // 2.检查登录失败次数（防暴力破解）
    auto attempt_res=CheckLoginFailedAttempts(mobile);
    if(!attempt_res.IsOk()){
        return Result<AuthResult>::Fail(attempt_res.code, attempt_res.message);
    }

    // 3.查询用户
    auto user_res=user_db_->FindByMobile(mobile);
    if(!user_res.IsOk()){
              // 用户不存在也返回"账号或密码错误"，避免泄露用户是否存在
              if (user_res.code == ErrorCode::UserNotFound) {
                RecordLoginFailure(mobile);
                return Result<AuthResult>::Fail(ErrorCode::WrongPassword, "账号或密码错误");
            }
            return Result<AuthResult>::Fail(user_res.code, user_res.message);
    }

    auto& user=user_res.data.value();

    // 4.检查账号状态
    if(user.disabled){
        return Result<AuthResult>::Fail(ErrorCode::UserDisabled, "账号已被禁用");
    }

    // 5.验证密码
    if(!PasswordHelper::Verify(password,user.password_hash)){
        // 登录失败，记录失败次数
        RecordLoginFailure(mobile);
        return Result<AuthResult>::Fail(ErrorCode::WrongPassword, "账号或密码错误");
    }

    // 6.登录成功，清除记录
    ClearLoginFailure(mobile);

    // 7.生成Token
    auto token_pair=jwt_srv_->GenerateTokenPair(user);

    // 8.存储Refresh Token
    auto store_res=StoreRefreshToken(user.id,token_pair.refresh_token);

    // 9.返回结果
    AuthResult result;
    result.user=user;
    result.user.password_hash.clear();  // 清空密码，不返回密码
    result.tokens=token_pair;

    LOG_INFO("User login by password: mobile={}, uuid={}", mobile, user.uuid);
    return Result<AuthResult>::Ok(result);
}

Result<AuthResult> AuthService::LoginByCode(const std::string& mobile,
                                const std::string& verify_code){
    std::string error;

    // 1. 参数校验
    if (!IsValidMobile(mobile, error)) {
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument, error);
    }
    if (!IsValidVerifyCode(verify_code, error,config_->sms)) {
        return Result<AuthResult>::Fail(ErrorCode::InvalidArgument, error);
    }

    // 2.验证码验证
    auto verify_res=sms_srv_->VerifyCaptcha(SmsScene::Login,mobile,verify_code);
    if(!verify_res.IsOk()){
        return Result<AuthResult>::Fail(verify_res.code,verify_res.message);
    }

    // 3.查询用户
    auto user_res=user_db_->FindByMobile(mobile);
    if(!user_res.IsOk()){
        // 用户不存在
        if (user_res.code == ErrorCode::UserNotFound) {
            return Result<AuthResult>::Fail(ErrorCode::UserNotFound, "用户不存在，请先注册");
        }

        return Result<AuthResult>::Fail(user_res.code, user_res.message);
    }

    auto& user=user_res.data.value();

    // 4.检查账户状态
    if(user.disabled){
        return Result<AuthResult>::Fail(ErrorCode::UserDisabled, "账号已被禁用");
    }

    // 5.清除登录失败记录（验证码登录成功也清除）
    ClearLoginFailure(mobile);

    // 6. 生成 Token
    auto token_pair = jwt_srv_->GenerateTokenPair(user);

    // 7. 存储 Refresh Token
    auto store_res = StoreRefreshToken(user.id, token_pair.refresh_token);
    if (!store_res) {
        LOG_WARN("Store refresh token failed for user {}: {}", user.uuid, store_res.message);
    }

    // 8. 返回结果
    AuthResult result;
    result.user = user;
    result.user.password_hash.clear();
    result.tokens = token_pair;

    LOG_INFO("User login by code: mobile={}, uuid={}", mobile, user.uuid);
    return Result<AuthResult>::Ok(result);
}

// ============================================================================
// 重置密码
// ============================================================================

Result<void> AuthService::ResetPassword(const std::string& mobile,
    const std::string& verify_code,
    const std::string& new_password) {
    
    std::string error;

    // 1. 参数校验
    if (!IsValidMobile(mobile, error)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, error);
    }
    if (!IsValidVerifyCode(verify_code, error,config_->sms)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, error);
    }
    if (!IsValidPassword(new_password, error,config_->password)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, error);
    }

    // 2.验证码验证
    auto verify_res=sms_srv_->VerifyCaptcha(SmsScene::ResetPassword,mobile,verify_code);
    if(!verify_res.IsOk()){
        return Result<void>::Fail(verify_res.code, verify_res.message);
    }

    // 3.查询用户
    auto user_res=user_db_->FindByMobile(mobile);
    if(!user_res.IsOk()){
        if (user_res.code == ErrorCode::UserNotFound) {
            return Result<void>::Fail(ErrorCode::UserNotFound, "用户不存在");
        }
        return Result<void>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 4. 更新密码
    user.password_hash = PasswordHelper::Hash(new_password);
    auto update_res = user_db_->Update(user);
    if (!update_res) {
        return Result<void>::Fail(update_res.code, update_res.message);
    }

    // 5. 使该用户所有 Refresh Token 失效（强制重新登录）
    auto revoke_res = token_repo_->DeleteByUserId(user.id);
    if (!revoke_res) {
        LOG_WARN("Revoke tokens failed for user {}: {}", user.uuid, revoke_res.message);
    }

    // 6. 清除登录失败记录
    ClearLoginFailure(mobile);

    LOG_INFO("User reset password: mobile={}, uuid={}", mobile, user.uuid);
    return Result<void>::Ok();
}


// ============================================================================
// 刷新 Token
// ============================================================================

Result<TokenPair> AuthService::RefreshToken(const std::string& refresh_token){
    // 1. 参数校验
    if (refresh_token.empty()) {
        return Result<TokenPair>::Fail(ErrorCode::InvalidArgument, "refresh_token 不能为空");
    }

    // 2.解析Token，获取user_id
    auto verify_res = jwt_srv_->ParseRefreshToken(refresh_token);
    if (!verify_res.IsOk()) {
        return Result<TokenPair>::Fail(verify_res.code, verify_res.message);
    }

    std::string user_id_str=verify_res.Value();
    int64_t user_id = std::stoll(user_id_str);

    // 3.查询用户，检查状态
    auto user_res=user_db_->FindById(user_id);
    if(!user_res.IsOk()){
        return Result<TokenPair>::Fail(user_res.code, user_res.message);
    }
    if(user_res.data.value().disabled){
        return Result<TokenPair>::Fail(ErrorCode::UserDisabled, "账号已被禁用");
    }

    auto& user=user_res.Value();

    // 4.校验令牌哈希是否有效（数据库中存在且未过期）
    std::string token_hash=jwt_srv_->HashToken(refresh_token);

    auto exists_res=token_repo_->IsTokenValid(token_hash);
    if(!exists_res.IsOk()){
        // 执行失败
        return Result<TokenPair>::Fail(exists_res.code,exists_res.message);
    }else if(!exists_res.data.value_or(false)){
        // Token不存在
        return Result<TokenPair>::Fail(ErrorCode::TokenRevoked, "Token 已失效");
    }
    
    // 5.删除旧的Refresh Token 的哈希值
    token_repo_->DeleteByTokenHash(token_hash);

    // 6.生成新的Token对
    auto new_tokens=jwt_srv_->GenerateTokenPair(user);

    // 7.存储新的Refresh Token的哈希值
    auto store_res=StoreRefreshToken(user_id,new_tokens.refresh_token);
    if (!store_res) {
        LOG_WARN("Store new refresh token failed for user_id={}: {}", user_id, store_res.message);
    }

    LOG_DEBUG("Token refreshed for user_id={}", user_id);
    return Result<TokenPair>::Ok(new_tokens);

}


Result<void> AuthService::Logout(const std::string& refresh_token){
    // 1.空 Token 直接返回成功（幂等性）
    if(refresh_token.empty()){
        return Result<void>::Ok();
    }

    // 2.获取 refresh_token 的哈希值
    std::string token_hash = jwt_srv_->HashToken(refresh_token);

    // 3.删除 token （无论存在与否都返回成功，保证幂等性）
    auto del_res=token_repo_->DeleteByTokenHash(token_hash);
    if(!del_res.IsOk()){
        // 删除失败只记录日志，仍然返回成功
        LOG_WARN("Delete refresh token failed: {}", del_res.message);
    }

    LOG_DEBUG("User logged out, token_hash={}", token_hash.substr(0, 8) + "...");
    return Result<void>::Ok();
}


Result<void> AuthService::LogoutAll(const std::string& user_uuid){
    // 1. 获取 user_id
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<void>::Fail(user_res.code, user_res.message);
    }

    int64_t user_id = user_res.data.value().id;

    // 2. 删除该用户所有 token
    auto del_res = token_repo_->DeleteByUserId(user_id);
    if (!del_res.IsOk()) {
        LOG_WARN("Delete all tokens failed for user_id={}: {}", user_id, del_res.message);
    }

    LOG_INFO("User logged out from all devices, user_id={}", user_id);
    return Result<void>::Ok();
}

Result<TokenValidationResult> AuthService::ValidateAccessToken(const std::string& access_token) {
    TokenValidationResult validation;
    
    // 空 token 快速返回
    if (access_token.empty()) {
        return Result<TokenValidationResult>::Fail(ErrorCode::TokenMissing, "Access token is required");
    }
    
    // 1. 解析 JWT
    auto payload_result = jwt_srv_->VerifyAccessToken(access_token);
    if (!payload_result.IsOk()) {
        return Result<TokenValidationResult>::Fail(payload_result.code, payload_result.message);
    }
    
    const auto& payload = payload_result.Value();
    
    // 2. 检查是否在黑名单中（可选）
    // std::string blacklist_key = "token:blacklist:" + payload.user_uuid;
    // if (redis_cli_->Exists(blacklist_key)) {
    //     return Result<TokenValidationResult>::Fail(ErrorCode::TokenRevoked, "Token has been revoked");
    // }
    
    // 3. 填充验证结果
    validation.user_id = payload.user_id;
    validation.user_uuid = payload.user_uuid;
    validation.mobile = payload.mobile;
    validation.expires_at = payload.expires_at;
    
    return Result<TokenValidationResult>::Ok(validation);
}

// ============================================================================
// 私有方法：检查登录失败次数
// ============================================================================

Result<void> AuthService::CheckLoginFailedAttempts(const std::string& mobile) {
    std::string key = "login:fail:" + mobile;
    
    auto count_res = redis_cli_->Get(key);
    if (!count_res.IsOk()) {
        // Redis 错误，记录日志但不阻止登录
        LOG_WARN("Check login attempts failed: {}", count_res.message);
        return Result<void>::Ok();
    }

    if (count_res.data.has_value() && count_res.data.value().has_value()) {  //有值：说明在失败窗口期或被锁定中（注意：嵌套optional要双层检查）
        int count = std::stoi(count_res.data.value().value());

        // 登录失败次数最大限度
        if (count >= config_->login.max_failed_attempts) {
            // 获取剩余锁定时间（毫秒）
            auto ttl_res = redis_cli_->PTTL(key);
            
            int64_t ttl_ms;
            if (ttl_res.IsOk() && ttl_res.data.has_value() && ttl_res.data.value() > 0) {
                ttl_ms = ttl_res.data.value();
            } else {
                // PTTL 失败或 key 无过期时间，使用配置值（转毫秒）
                ttl_ms = config_->login.lock_duration_seconds * 1000;
            }

            // 毫秒转分钟（向上取整）
            int minutes = static_cast<int>((ttl_ms + 59999) / 60000);
            if (minutes < 1) minutes = 1;  // 至少显示1分钟

            return Result<void>::Fail(
                ErrorCode::AccountLocked,
                "登录失败次数过多，请" + std::to_string(minutes) + "分钟后再试"
            );
        }
    }

    return Result<void>::Ok();
}

// ============================================================================
// 私有方法：记录登录失败
// ============================================================================

void AuthService::RecordLoginFailure(const std::string& mobile) {
    std::string key = "login:fail:" + mobile;
    
    // 1.失败次数 +1
    auto incr_res = redis_cli_->Incr(key);
    if (!incr_res.IsOk()) {
        LOG_WARN("Record login failure failed: {}", incr_res.message);
        return;
    }

    // 2.判断是否触发锁定
    int64_t count=incr_res.data.value_or(1);
    if(count == config_->login.max_failed_attempts){
        // 刚好达到上限（第一次触发），设置锁定时间
        std::chrono::milliseconds ttl{config_->login.lock_duration_seconds*1000};
        redis_cli_->PExpire(key,ttl);
        LOG_WARN("Account locked: mobile={}, duration={}s", 
            mobile, config_->login.lock_duration_seconds);
    }else if(count < config_->login.max_failed_attempts){
        // 未达上限 -> 设置窗口期（只在第一次失败时设置）
        auto ttl_res=redis_cli_->PTTL(key);
        if(!ttl_res.IsOk() || ttl_res.data.value_or(-1)<0){
            // key 不存在/没有过期时间，设置窗口期
            std::chrono::milliseconds ttl{config_->login.failed_attempts_window*1000};
            redis_cli_->PExpire(key,ttl);
        }
        // 如果已有过期时间，不刷新（保持原窗口期）
    }
}

// ============================================================================
// 私有方法：清除登录失败记录
// ============================================================================

void AuthService::ClearLoginFailure(const std::string& mobile) {
    std::string key = "login:fail:" + mobile;
    
    auto del_res = redis_cli_->Del(key);
    if (!del_res) {
        LOG_WARN("Clear login failure failed: {}", del_res.message);
    }
}

// ============================================================================
// 私有方法：存储 Refresh Token
// ============================================================================

Result<void> AuthService::StoreRefreshToken(int64_t user_id, const std::string& refresh_token) {
    auto token_hash=jwt_srv_->HashToken(refresh_token);
    return token_repo_->SaveRefreshToken(user_id,token_hash,config_->security.refresh_token_ttl_seconds);
}



}

-----------------------------------------------------


// ====================== ./src/services/user_service.cpp ======================

#include "user_service.h"

#include "common/logger.h"
#include "common/validator.h"
#include "common/password_helper.h"
#include "common/error_codes.h"

namespace user_service{

// ============================================================================
// 构造函数
// ============================================================================

UserService::UserService(std::shared_ptr<Config> config,
                            std::shared_ptr<UserDB> user_db,
                            std::shared_ptr<TokenRepository> token_repo,
                            std::shared_ptr<SmsService> sms_srv)
    : config_(std::move(config)),
    user_db_(std::move(user_db)),
    token_repo_(std::move(token_repo)),
    sms_srv_(std::move(sms_srv))
{}

// 获取当前用户
Result<UserEntity> UserService::GetCurrentUser(const std::string& user_uuid){
    // 1. 参数校验
    if (user_uuid.empty()) {
        return Result<UserEntity>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    // 2. 查询用户
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<UserEntity>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3. 清除敏感信息
    user.password_hash.clear();

    return Result<UserEntity>::Ok(user);
}

// 更新用户信息（可选更新：后续扩展：avatar_url, email 等）
Result<UserEntity> UserService::UpdateUser(const std::string& user_uuid,
                                            std::optional<std::string> display_name){
    // 1.参数校验
    if (user_uuid.empty()) {
        return Result<UserEntity>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    // 2.查询用户
    auto user_res=user_db_->FindByUUID(user_uuid);
    if(!user_res.IsOk()){
        return Result<UserEntity>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3.检查账户状态
    if(user.disabled){
        return Result<UserEntity>::Fail(ErrorCode::UserDisabled, "账号已被禁用");
    }

    // 4.更新字段
    bool has_update=false;
    if(display_name.has_value()){
        std::string error;
        // 检查名称是否符合格式
        if(!IsValidDisplayName(display_name.value(),error)){
            return Result<UserEntity>::Fail(ErrorCode::InvalidArgument, error);
        }
        user.display_name=display_name.value();
        has_update=true;
    }

    // 后续扩展：avatar_url, email 等
    // if (req.avatar_url.has_value()) { ... }

    // 5.没有需要更新的字段
    if(!has_update){
        user.password_hash.clear(); // 清除敏感字段
        return Result<UserEntity>::Ok(user);
    }

    // 6.保留更新
    auto update_res = user_db_->Update(user);
    if (!update_res.IsOk()) {
        return Result<UserEntity>::Fail(update_res.code, update_res.message);
    }

    // 7.返回更新后的用户
    user.password_hash.clear(); // 清除敏感字段

    LOG_INFO("User updated: uuid={}", user_uuid);
    return Result<UserEntity>::Ok(user);
}

// 修改密码（已登录，需要旧密码）
Result<void> UserService::ChangePassword(const std::string& user_uuid,
                                            const std::string& old_password,
                                            const std::string& new_password){
                                            std::string error;

    // 1. 参数校验
    if (user_uuid.empty()) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    if (!IsValidPassword(old_password, error, config_->password)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, "旧密码格式错误");
    }

    if (!IsValidPassword(new_password, error, config_->password)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, error);
    }

    // 旧密码不可以与新密码一致
    if (old_password == new_password) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, "新密码不能与旧密码相同");
    }

    // 2. 查询用户
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<void>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3. 检查账号状态
    if (user.disabled) {
        return Result<void>::Fail(ErrorCode::UserDisabled, "账号已被禁用");
    }

    // 4. 验证旧密码
    if (!PasswordHelper::Verify(old_password, user.password_hash)) {
        return Result<void>::Fail(ErrorCode::WrongPassword, "旧密码错误");
    }

    // 5. 更新密码
    // 获取密码哈希值，再存入
    user.password_hash = PasswordHelper::Hash(new_password);
    auto update_res = user_db_->Update(user);
    if (!update_res.IsOk()) {
        return Result<void>::Fail(update_res.code, update_res.message);
    }

    // 6. 可选：使其他设备的 Token 失效（当前设备保持登录）
    // 这里暂不实现，如需要可以传入当前 token_hash 排除
    // token_repo_->DeleteByUserIdExcept(user.id, current_token_hash);

    LOG_INFO("User changed password: uuid={}", user_uuid);
    return Result<void>::Ok();
}

// 删除用户（注销账号）
Result<void> UserService::DeleteUser(const std::string& user_uuid,
                                        const std::string verify_code){
    std::string error;

    // 1. 参数校验
    if (user_uuid.empty()) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    if (!IsValidVerifyCode(verify_code, error, config_->sms)) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, error);
    }

    // 2. 查询用户
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<void>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3. 验证验证码
    auto verify_res = sms_srv_->VerifyCaptcha(SmsScene::DeleteUser, user.mobile,verify_code);
    if (!verify_res.IsOk()) {
        return Result<void>::Fail(verify_res.code, verify_res.message);
    }

    // 4. 删除用户所有 Token（强制登出）
    auto revoke_res = token_repo_->DeleteByUserId(user.id);
    if (!revoke_res.IsOk()) {
        LOG_WARN("Revoke tokens failed for user {}: {}", user.uuid, revoke_res.message);
    }

    // 5. 删除用户（软删除或硬删除，根据业务需求）
    // 方案A：软删除（推荐，保留数据用于审计）
    user.disabled = true;
    user.mobile = "deleted_" + std::to_string(user.id) + "_" + user.mobile;  // 释放手机号
    auto update_res = user_db_->Update(user);
    
    // 方案B：硬删除
    // auto delete_res = user_db_->Delete(user.id);

    if (!update_res.IsOk()) {
        return Result<void>::Fail(update_res.code, update_res.message);
    }

    LOG_INFO("User deleted (soft): uuid={}, mobile={}", user_uuid, user.mobile);
    return Result<void>::Ok();
}

// ==================== 管理员操作 ====================

// 获取指定用户
Result<UserEntity> UserService::GetUser(const std::string& user_uuid){
    // 1. 参数校验
    if (user_uuid.empty()) {
        return Result<UserEntity>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    // 2. 查询用户
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<UserEntity>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3. 清除敏感信息
    user.password_hash.clear();

    return Result<UserEntity>::Ok(user);
}

// 获取用户列表（可按条件筛选）
Result<ListUsersResult> UserService::ListUsers(std::optional<std::string> mobile_filter,
                                                std::optional<bool> disabled_filter,
                                                int32_t page,
                                                int32_t page_size){
    // 1. 参数校验和默认值
    page = page > 0 ? page : 1;
    page_size = page_size > 0 ? page_size : 20;
    
    // 限制最大分页大小
    if (page_size > 100) {
        page_size = 100;
    }
    // 2. 构建查询条件
    UserQueryParams params;
    params.page_params.page = page;
    params.page_params.page_size = page_size;
    
    if (mobile_filter.has_value() && !mobile_filter.value().empty()) {
        params.mobile_like = mobile_filter.value();
    }
    
    if (disabled_filter.has_value()) {
        params.disabled = disabled_filter;
    }

    // 3. 查询总数
    auto count_res = user_db_->Count(params);
    if (!count_res.IsOk()) {
        return Result<ListUsersResult>::Fail(count_res.code, count_res.message);
    }
    int64_t total_records = count_res.data.value();

    // 4. 查询列表
    auto list_res = user_db_->FindAll(params);
    if (!list_res.IsOk()) {
        return Result<ListUsersResult>::Fail(list_res.code, list_res.message);
    }

    auto& users = list_res.data.value();

    // 5. 清除敏感信息
    for (auto& user : users) {
        user.password_hash.clear();
    }

    // 6. 构建分页信息
    ListUsersResult result;
    result.users = std::move(users);
    result.page_res.total_records = total_records;
    result.page_res.total_pages = (total_records + page_size - 1) / page_size;
    result.page_res.page = page;
    result.page_res.page_size = page_size;

    return Result<ListUsersResult>::Ok(result);
}

// 禁用/启用用户
Result<void> UserService::SetUserDisabled(const std::string& user_uuid, bool disabled){
    // 1. 参数校验
    if (user_uuid.empty()) {
        return Result<void>::Fail(ErrorCode::InvalidArgument, "用户ID不能为空");
    }

    // 2. 查询用户
    auto user_res = user_db_->FindByUUID(user_uuid);
    if (!user_res.IsOk()) {
        return Result<void>::Fail(user_res.code, user_res.message);
    }

    auto& user = user_res.data.value();

    // 3. 状态相同，无需更新
    if (user.disabled == disabled) {
        return Result<void>::Ok();
    }

    // 4. 更新状态
    user.disabled = disabled;
    auto update_res = user_db_->Update(user);
    if (!update_res.IsOk()) {
        return Result<void>::Fail(update_res.code, update_res.message);
    }

    // 5. 如果是禁用，使所有 Token 失效
    if (disabled) {
        auto revoke_res = token_repo_->DeleteByUserId(user.id);
        if (!revoke_res.IsOk()) {
            LOG_WARN("Revoke tokens failed for disabled user {}: {}", user.uuid, revoke_res.message);
        }
    }

    LOG_INFO("User {} : uuid={}", disabled ? "disabled" : "enabled", user_uuid);
    return Result<void>::Ok();
}


}

-----------------------------------------------------


// ====================== ./src/cache/CMakeLists.txt ======================

add_library(user_cache STATIC redis_client.cpp)

target_include_directories(user_cache PUBLIC
                ${PROJECT_SOURCE_DIR}/include
                ${HIREDIS_HEADER}
                ${REDIS_PLUS_PLUS_HEADER}
)

target_link_libraries(user_cache PUBLIC
        ${REDIS_PLUS_PLUS_LIB}
        ${HIREDIS_LIB}
        user_config
        pthread
)

-----------------------------------------------------


// ====================== ./src/cache/redis_client.cpp ======================

#include "cache/redis_client.h"
#include "common/logger.h"
#include <iostream>

namespace user_service {


// 类型别名（避免宏参数中的逗号问题）
namespace{
    using StringMap = std::unordered_map<std::string, std::string>;
}



// ============================================================================
// 辅助宏：统一错误处理
// ============================================================================

#define REDIS_CATCH_RETURN(ResultType, operation, key)                         \
    catch (const sw::redis::Error& e) {                                        \
        LOG_WARN("Redis {} failed: key={}, err={}", operation, key, e.what()); \
        return ResultType::Fail(ErrorCode::ServiceUnavailable, e.what());      \
    }

#define REDIS_CATCH_RETURN_2(ResultType, operation, key, field)                \
    catch (const sw::redis::Error& e) {                                        \
        LOG_WARN("Redis {} failed: key={}, field={}, err={}",                  \
                 operation, key, field, e.what());                             \
        return ResultType::Fail(ErrorCode::ServiceUnavailable, e.what());      \
    }

// ============================================================================
// 构造函数
// ============================================================================

RedisClient::RedisClient(const std::string& host, int port,
                         const std::string& password, int db) {
    sw::redis::ConnectionOptions conn_opt;
    conn_opt.host = host;
    conn_opt.port = port;

    if (!password.empty()) {
        conn_opt.password = password;
    }

    conn_opt.db = db;
    
    sw::redis::ConnectionPoolOptions pool_opt;
    pool_opt.size = 5;
    pool_opt.wait_timeout = std::chrono::milliseconds(100);

    try {
        redis_ = std::make_unique<sw::redis::Redis>(conn_opt, pool_opt);
        std::cout << "✓ Redis 连接成功" << std::endl;
    } catch (const sw::redis::Error& e) {
        std::cerr << "✗ Redis 连接失败: " << e.what() << std::endl;
        LOG_ERROR("Redis connection failed: {}", e.what());
        throw;  // 构造函数是唯一允许抛异常的地方
    }
}

RedisClient::RedisClient(const RedisConfig& config) {
    sw::redis::ConnectionOptions conn_opt;
    conn_opt.host = config.host;
    conn_opt.port = config.port;
    
    if (!config.password.empty()) {
        conn_opt.password = config.password;
    }
    
    conn_opt.db = config.db;
    
    if (config.connect_timeout_ms) {
        conn_opt.connect_timeout = std::chrono::milliseconds(*config.connect_timeout_ms);
    }
    if (config.socket_timeout_ms) {
        conn_opt.socket_timeout = std::chrono::milliseconds(*config.socket_timeout_ms);
    }

    sw::redis::ConnectionPoolOptions pool_opt;
    pool_opt.size = config.pool_size;
    pool_opt.wait_timeout = std::chrono::milliseconds(config.wait_timeout_ms);

    try {
        redis_ = std::make_unique<sw::redis::Redis>(conn_opt, pool_opt);
        std::cout << "✓ Redis 连接成功" << std::endl;
    } catch (const sw::redis::Error& e) {
        std::cerr << "✗ Redis 连接失败: " << e.what() << std::endl;
        LOG_ERROR("Redis connection failed: {}", e.what());
        throw;
    }
}

// ============================================================================
// 字符串操作
// ============================================================================

Result<void> RedisClient::Set(const std::string& key, const std::string& value) noexcept {
    try {
        redis_->set(key, value);
        return Result<void>::Ok();
    }
    REDIS_CATCH_RETURN(Result<void>, "SET", key)
}

Result<void> RedisClient::SetPx(const std::string& key, const std::string& value,
                                 std::chrono::milliseconds ttl) noexcept {
    if (ttl.count() <= 0) {
        LOG_WARN("Redis PSETEX: invalid ttl={}ms for key={}", ttl.count(), key);
        return Result<void>::Fail(ErrorCode::InvalidArgument, "TTL must be positive");
    }

    try {
        redis_->psetex(key, ttl, value);
        return Result<void>::Ok();
    }
    REDIS_CATCH_RETURN(Result<void>, "PSETEX", key)
}

Result<std::optional<std::string>> RedisClient::Get(const std::string& key) noexcept {
    try {
        // redis_->get() 返回 std::optional<std::string>
        // 无论有值还是无值，都是"执行成功"
        auto val = redis_->get(key);
        return Result<std::optional<std::string>>::Ok(std::move(val));
    }
    REDIS_CATCH_RETURN(Result<std::optional<std::string>>, "GET", key)
}

Result<bool> RedisClient::SetNx(const std::string& key, const std::string& value) noexcept {
    try {
        bool set = redis_->setnx(key, value);
        return Result<bool>::Ok(set);
    }
    REDIS_CATCH_RETURN(Result<bool>, "SETNX", key)
}

Result<bool> RedisClient::SetNxPx(const std::string& key, const std::string& value,
                                   std::chrono::milliseconds ttl) noexcept {
    if (ttl.count() <= 0) {
        return Result<bool>::Fail(ErrorCode::InvalidArgument, "TTL must be positive");
    }

    try {
        // SET key value NX PX milliseconds
        bool set = redis_->set(key, value, ttl, sw::redis::UpdateType::NOT_EXIST);
        return Result<bool>::Ok(set);
    }
    REDIS_CATCH_RETURN(Result<bool>, "SET NX PX", key)
}

// ============================================================================
// 通用操作
// ============================================================================

Result<bool> RedisClient::Exists(const std::string& key) noexcept {
    try {
        bool exists = redis_->exists(key) > 0;
        return Result<bool>::Ok(exists);
    }
    REDIS_CATCH_RETURN(Result<bool>, "EXISTS", key)
}

Result<bool> RedisClient::Del(const std::string& key) noexcept {
    try {
        // 返回是否真的删除了（key 不存在时返回 false，但这不是错误）
        bool deleted = redis_->del(key) > 0;
        return Result<bool>::Ok(deleted);
    }
    REDIS_CATCH_RETURN(Result<bool>, "DEL", key)
}

Result<bool> RedisClient::PExpire(const std::string& key, 
                                   std::chrono::milliseconds ttl) noexcept {
    try {
        bool set = redis_->pexpire(key, ttl);
        return Result<bool>::Ok(set);
    }
    REDIS_CATCH_RETURN(Result<bool>, "PEXPIRE", key)
}

Result<int64_t> RedisClient::PTTL(const std::string& key) noexcept {
    try {
        // pttl 返回：
        // -2: key 不存在
        // -1: key 存在但无过期时间
        // >0: 剩余毫秒数
        long long ttl = redis_->pttl(key);
        return Result<int64_t>::Ok(static_cast<int64_t>(ttl));
    }
    REDIS_CATCH_RETURN(Result<int64_t>, "PTTL", key)
}

Result<std::vector<std::string>> RedisClient::Keys(const std::string& pattern) noexcept {
    try {
        std::vector<std::string> keys;
        redis_->keys(pattern, std::back_inserter(keys));
        return Result<std::vector<std::string>>::Ok(std::move(keys));
    } catch (const sw::redis::Error& e) {
        LOG_WARN("Redis KEYS failed: pattern={}, err={}", pattern, e.what());
        return Result<std::vector<std::string>>::Fail(ErrorCode::ServiceUnavailable, e.what());
    }
}

Result<std::vector<std::string>> RedisClient::Scan(const std::string& pattern,
                                                    int64_t count) noexcept {
    try {
        std::vector<std::string> keys;
        long long cursor = 0;
        
        // SCAN 是增量迭代，需要循环直到 cursor 返回 0
        do {
            cursor = redis_->scan(cursor, pattern, count, std::back_inserter(keys));
        } while (cursor != 0);
        
        return Result<std::vector<std::string>>::Ok(std::move(keys));
    } catch (const sw::redis::Error& e) {
        LOG_WARN("Redis SCAN failed: pattern={}, err={}", pattern, e.what());
        return Result<std::vector<std::string>>::Fail(ErrorCode::ServiceUnavailable, e.what());
    }
}

// ============================================================================
// Hash 操作
// ============================================================================

Result<void> RedisClient::HSet(const std::string& key,
                                const std::string& field,
                                const std::string& value) noexcept {
    try {
        redis_->hset(key, field, value);
        return Result<void>::Ok();
    }
    REDIS_CATCH_RETURN_2(Result<void>, "HSET", key, field)
}

Result<void> RedisClient::HMSet(
    const std::string& key,
    const std::vector<std::pair<std::string, std::string>>& fields) noexcept {
    
    if (fields.empty()) {
        return Result<void>::Ok();  // 空操作视为成功
    }

    try {
        redis_->hset(key, fields.begin(), fields.end());
        return Result<void>::Ok();
    }
    REDIS_CATCH_RETURN(Result<void>, "HMSET", key)
}

Result<std::optional<std::string>> RedisClient::HGet(const std::string& key,
                                                      const std::string& field) noexcept {
    try {
        auto val = redis_->hget(key, field);
        return Result<std::optional<std::string>>::Ok(std::move(val));
    }
    REDIS_CATCH_RETURN_2(Result<std::optional<std::string>>, "HGET", key, field)
}

Result<StringMap> RedisClient::HGetAll(const std::string& key) noexcept {
    try {
        std::unordered_map<std::string, std::string> result;
        redis_->hgetall(key, std::inserter(result, result.begin()));
        // key 不存在时返回空 map，这是正常情况
        return Result<std::unordered_map<std::string, std::string>>::Ok(std::move(result));
    }
    REDIS_CATCH_RETURN(Result<StringMap>, "HGETALL",key)
}

Result<bool> RedisClient::HDel(const std::string& key, const std::string& field) noexcept {
    try {
        bool deleted = redis_->hdel(key, field) > 0;
        return Result<bool>::Ok(deleted);
    }
    REDIS_CATCH_RETURN_2(Result<bool>, "HDEL", key, field)
}

Result<bool> RedisClient::HExists(const std::string& key, const std::string& field) noexcept {
    try {
        bool exists = redis_->hexists(key, field);
        return Result<bool>::Ok(exists);
    }
    REDIS_CATCH_RETURN_2(Result<bool>, "HEXISTS", key, field)
}

// ============================================================================
// 原子操作
// ============================================================================

Result<int64_t> RedisClient::Incr(const std::string& key) noexcept {
    try {
        long long val = redis_->incr(key);
        return Result<int64_t>::Ok(static_cast<int64_t>(val));
    }
    REDIS_CATCH_RETURN(Result<int64_t>, "INCR", key)
}

Result<int64_t> RedisClient::IncrBy(const std::string& key, int64_t increment) noexcept {
    try {
        long long val = redis_->incrby(key, increment);
        return Result<int64_t>::Ok(static_cast<int64_t>(val));
    } catch (const sw::redis::Error& e) {
        LOG_WARN("Redis INCRBY failed: key={}, increment={}, err={}", 
                 key, increment, e.what());
        return Result<int64_t>::Fail(ErrorCode::ServiceUnavailable, e.what());
    }
}

Result<int64_t> RedisClient::Decr(const std::string& key) noexcept {
    try {
        long long val = redis_->decr(key);
        return Result<int64_t>::Ok(static_cast<int64_t>(val));
    }
    REDIS_CATCH_RETURN(Result<int64_t>, "DECR", key)
}

// ============================================================================
// 健康检查
// ============================================================================

Result<void> RedisClient::Ping() noexcept {
    try {
        redis_->ping();
        return Result<void>::Ok();
    } catch (const sw::redis::Error& e) {
        LOG_WARN("Redis PING failed: {}", e.what());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, e.what());
    }
}

#undef REDIS_CATCH_RETURN
#undef REDIS_CATCH_RETURN_2

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/db/CMakeLists.txt ======================

add_library(user_db user_db.cpp mysql_connection.cpp mysql_result.cpp)

target_include_directories(user_db PUBLIC
            ${PROJECT_SOURCE_DIR}/include/db
            ${PROJECT_SOURCE_DIR}/include
            ${MYSQL_INCLUDE_DIRS} #MYSQL 头文件                    
)

target_link_libraries(user_db
    PUBLIC
        ${MYSQL_LIBRARIES}
        user_config
        uuid
)

-----------------------------------------------------


// ====================== ./src/db/mysql_result.cpp ======================

#include "db/mysql_result.h"
#include "exception/exception.h"

#include <cstdlib>

namespace user_service {

// ==================== 构造与析构 ====================

MySQLResult::MySQLResult(MYSQL_RES* res)
    : result_(res),
      field_count_(res ? mysql_num_fields(res) : 0) {
    // 构造时立即构建列名映射，支持后续按列名查询
    BuildColumnMap(); 
}

MySQLResult::~MySQLResult() {
    // RAII: 确保 MYSQL_RES 资源被正确释放
    if (result_) {
        mysql_free_result(result_);
        result_ = nullptr;
    }
}

// ==================== 移动语义 ====================

MySQLResult::MySQLResult(MySQLResult&& other) noexcept
    : result_(other.result_),
      current_row_(other.current_row_),
      lengths_(other.lengths_),
      field_count_(other.field_count_),
      col_name_map_(std::move(other.col_name_map_)) {
    // 将源对象置为"空壳"状态，防止其析构时释放资源
    other.result_ = nullptr;
    other.current_row_ = nullptr;
    other.lengths_ = nullptr;
    other.field_count_ = 0;
    // col_name_map_ 已被 move，自动变为空
}

MySQLResult& MySQLResult::operator=(MySQLResult&& other) noexcept {
    // 自赋值检查：防止 a = std::move(a) 导致资源丢失
    if (&other != this) {
        // 先释放自己持有的资源
        if (result_) {
            mysql_free_result(result_);
        }
        
        // 接管 other 的资源
        result_ = other.result_;
        current_row_ = other.current_row_;
        lengths_ = other.lengths_;
        field_count_ = other.field_count_;
        col_name_map_ = std::move(other.col_name_map_);

        // 将 other 置空
        other.result_ = nullptr;
        other.current_row_ = nullptr;
        other.lengths_ = nullptr;
        other.field_count_ = 0;
    }
    return *this;
}

// ==================== 遍历接口 ====================

bool MySQLResult::Next() {
    if (!result_) return false;
    
    // mysql_fetch_row: 获取当前行并自动将游标后移
    // 返回 NULL 表示没有更多数据或发生错误
    current_row_ = mysql_fetch_row(result_);
    
    if (current_row_) {
        // mysql_fetch_lengths: 获取当前行各字段的实际字节长度
        // 对于二进制数据和含 '\0' 的字符串，必须使用长度而非 strlen
        lengths_ = mysql_fetch_lengths(result_);
        return true;
    }
    return false;
}

// ==================== 元信息接口 ====================

size_t MySQLResult::RowCount() const {
    // 注意：对于 unbuffered 查询，mysql_num_rows 可能返回 0
    return result_ ? static_cast<size_t>(mysql_num_rows(result_)) : 0;
}

size_t MySQLResult::FieldCount() const {
    return field_count_;
}

// ==================== 按索引获取字段值 ====================

bool MySQLResult::IsNull(size_t col) const {
    CheckColumn(col);
    return current_row_[col] == nullptr;
}

std::optional<std::string> MySQLResult::GetString(size_t col) const {
    CheckColumn(col);
    
    // MySQL 中 NULL 值需要特殊处理
    if (current_row_[col] == nullptr) {
        return std::nullopt;
    }
    
    // 重要：使用 lengths_ 构造 string，而非直接用 char*
    // 原因：1. 二进制数据可能包含 '\0'
    //       2. BLOB 类型不以 '\0' 结尾
    if (lengths_) {
        return std::string(current_row_[col], lengths_[col]);
    }
    
    // 降级处理（lengths_ 为空的罕见情况）
    return current_row_[col];
}

std::optional<int64_t> MySQLResult::GetInt(size_t col) const {
    CheckColumn(col);
    
    if (current_row_[col] == nullptr) {
        return std::nullopt;
    }
    
    // strtoll: 字符串转 long long，比 atoi 更安全
    // 参数：源字符串, 未转换部分指针(不需要), 进制(10进制)
    return std::strtoll(current_row_[col], nullptr, 10);
}

std::optional<double> MySQLResult::GetDouble(size_t col) const {
    CheckColumn(col);
    
    if (current_row_[col] == nullptr) {
        return std::nullopt;
    }
    
    return std::strtod(current_row_[col], nullptr);
}

// ==================== 按列名获取（委托给按索引版本） ====================

bool MySQLResult::IsNull(const std::string& col_name) const {
    return IsNull(GetColumnIndex(col_name));
}

std::optional<std::string> MySQLResult::GetString(const std::string& col_name) const {
    return GetString(GetColumnIndex(col_name));
}

std::optional<int64_t> MySQLResult::GetInt(const std::string& col_name) const {
    return GetInt(GetColumnIndex(col_name));
}

std::optional<double> MySQLResult::GetDouble(const std::string& col_name) const {
    return GetDouble(GetColumnIndex(col_name));
}

// ==================== 私有辅助方法 ====================

void MySQLResult::CheckColumn(size_t col) const {
    // 检查1：是否已调用 Next() 获取行数据
    if (!current_row_) {
        throw MySQLResultException("No current row, call Next() first");
    }
    
    // 检查2：列索引是否越界
    if (col >= field_count_) {
        throw MySQLResultException(
            "Column index " + std::to_string(col) +
            " out of range, max is " + std::to_string(field_count_ - 1));
    }
}

void MySQLResult::BuildColumnMap() {
    if (!result_) return;

    // mysql_fetch_fields: 一次性获取所有字段的元信息数组
    // 注意：不是 mysql_fetch_field（单数），那个是逐个获取
    MYSQL_FIELD* fields = mysql_fetch_fields(result_);
    
    // 构建 列名 -> 索引 的映射,方便按列名查找
    for (size_t i = 0; i < field_count_; ++i) {
        col_name_map_[fields[i].name] = i;
    }
}

size_t MySQLResult::GetColumnIndex(const std::string& col_name) const {
    auto it = col_name_map_.find(col_name);
    
    if (it == col_name_map_.end()) {
        // 列名不存在，抛出异常（常见原因：拼写错误、表结构变更）
        throw std::out_of_range("Column not found: " + col_name);
    }
    
    return it->second;
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/db/mysql_connection.cpp ======================

#include "db/mysql_connection.h"
#include "exception/exception.h"

#include <chrono>
#include <vector>
#include <thread>

namespace user_service {

// ==================== 构造与析构 ====================

MySQLConnection::MySQLConnection(const MySQLConfig& config) {
    /*
     * 连接流程：
     * 1. 初始化句柄并设置选项
     * 2. 尝试首次连接
     * 3. 失败且可重试 → 进入重试逻辑
     * 4. 失败且不可重试 → 直接抛异常
     */
    try {
        InitAndSetOptions(config);
    } catch (...) {
        // 确保异常时资源被释放（RAII 补充）
        if (mysql_) {
            mysql_close(mysql_);
            mysql_ = nullptr;
        }
        throw;
    }

    if (!mysql_real_connect(mysql_,
                            config.host.c_str(),
                            config.username.c_str(),
                            config.password.c_str(),
                            config.database.c_str(),
                            config.port,
                            nullptr,    // unix_socket: 使用 TCP 连接时传 nullptr
                            0)) {       // client_flag: 默认选项
        // 重要：必须在 mysql_close 之前保存错误信息！
        // mysql_close 后 mysql_ 指向的内存被释放，再调用 mysql_error 是未定义行为
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);

        mysql_close(mysql_);
        mysql_ = nullptr;

        // 判断是否需要重试
        MySQLException ex(err_code, err_msg);
        bool should_retry = config.auto_reconnect.value_or(false) &&
                            config.max_retries > 0 &&
                            ex.IsRetryable();

        if (!should_retry) {
            throw ex;
        }

        // 进入重试逻辑
        ConnectWithRetry(config);
    }
}

MySQLConnection::~MySQLConnection() {
    if (mysql_) {
        mysql_close(mysql_);
        mysql_ = nullptr;
    }
}

// ==================== 查询与执行 ====================

MySQLResult MySQLConnection::Query(const std::string& sql, std::initializer_list<Param> params) {
    std::string new_sql = BuildSQL(sql, params.begin(),params.end());

    if (mysql_query(mysql_, new_sql.c_str()) != 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        ThrowMySQLException(err_code, err_msg);
    }

    // mysql_store_result: 将整个结果集拉取到客户端内存
    // 优点：可随机访问、可获取总行数
    // 缺点：大结果集占用内存多（大结果集应使用 mysql_use_result 流式获取）
    MYSQL_RES* res = mysql_store_result(mysql_);

    /*
     * res == nullptr 的三种情况：
     * 1. SELECT 返回空集 → field_count > 0，这是正常的空结果
     * 2. 非 SELECT 语句（如 UPDATE）→ field_count == 0，正常
     * 3. 发生错误 → field_count > 0 但 res 为空，需要抛异常
     * 
     * 因此判断条件是：res == nullptr && field_count > 0
     */
    if (res == nullptr && mysql_field_count(mysql_) > 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        ThrowMySQLException(err_code, err_msg);
    }

    return MySQLResult(res);
}

MySQLResult MySQLConnection::Query(const std::string& sql, const std::vector<Param>& params) {
    std::string new_sql = BuildSQL(sql, params.begin(),params.end());

    if (mysql_query(mysql_, new_sql.c_str()) != 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        ThrowMySQLException(err_code, err_msg);
    }

    // mysql_store_result: 将整个结果集拉取到客户端内存
    // 优点：可随机访问、可获取总行数
    // 缺点：大结果集占用内存多（大结果集应使用 mysql_use_result 流式获取）
    MYSQL_RES* res = mysql_store_result(mysql_);

    /*
     * res == nullptr 的三种情况：
     * 1. SELECT 返回空集 → field_count > 0，这是正常的空结果
     * 2. 非 SELECT 语句（如 UPDATE）→ field_count == 0，正常
     * 3. 发生错误 → field_count > 0 但 res 为空，需要抛异常
     * 
     * 因此判断条件是：res == nullptr && field_count > 0
     */
    if (res == nullptr && mysql_field_count(mysql_) > 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        ThrowMySQLException(err_code, err_msg);
    }

    return MySQLResult(res);
}

uint64_t MySQLConnection::Execute(const std::string& sql, std::initializer_list<Param> params) {
    std::string new_sql = BuildSQL(sql, params.begin(),params.end());

    if (mysql_query(mysql_, new_sql.c_str()) != 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        // INSERT 可能触发唯一键冲突（错误码 1062）
        // ThrowMySQLException 会根据错误码自动选择异常类型
        ThrowMySQLException(err_code, err_msg);
    }

    // 返回受影响的行数
    // 注意：UPDATE 即使值没变化也可能返回 0（取决于 CLIENT_FOUND_ROWS 标志）
    return mysql_affected_rows(mysql_);
}

uint64_t MySQLConnection::Execute(const std::string& sql, const std::vector<Param>& params) {
    std::string new_sql = BuildSQL(sql, params.begin(),params.end());

    if (mysql_query(mysql_, new_sql.c_str()) != 0) {
        unsigned int err_code = mysql_errno(mysql_);
        std::string err_msg = mysql_error(mysql_);
        // INSERT 可能触发唯一键冲突（错误码 1062）
        // ThrowMySQLException 会根据错误码自动选择异常类型
        ThrowMySQLException(err_code, err_msg);
    }

    // 返回受影响的行数
    // 注意：UPDATE 即使值没变化也可能返回 0（取决于 CLIENT_FOUND_ROWS 标志）
    return mysql_affected_rows(mysql_);
}

uint64_t MySQLConnection::LastInsertId() {
    // 返回最近一次 INSERT 生成的 AUTO_INCREMENT 值
    // 注意：必须在同一连接上、INSERT 之后立即调用
    return mysql_insert_id(mysql_);
}

// ==================== 初始化与连接 ====================

void MySQLConnection::InitAndSetOptions(const MySQLConfig& config) {
    mysql_ = mysql_init(nullptr);
    if (!mysql_) {
        // mysql_init 失败通常是内存不足
        // 此时 mysql_ 为空，不能调用 mysql_errno/mysql_error
        throw MySQLException(0, "mysql_init failed: out of memory");
    }

    // 设置超时参数（单位转换：ms → s，MySQL C API 只支持秒级精度）
    if (config.connection_timeout_ms.has_value()) {
        unsigned int timeout_sec = config.connection_timeout_ms.value() / 1000;
        mysql_options(mysql_, MYSQL_OPT_CONNECT_TIMEOUT, &timeout_sec);
    }
    if (config.read_timeout_ms.has_value()) {
        unsigned int timeout_sec = config.read_timeout_ms.value() / 1000;
        mysql_options(mysql_, MYSQL_OPT_READ_TIMEOUT, &timeout_sec);
    }
    if (config.write_timeout_ms.has_value()) {
        unsigned int timeout_sec = config.write_timeout_ms.value() / 1000;
        mysql_options(mysql_, MYSQL_OPT_WRITE_TIMEOUT, &timeout_sec);
    }
    
    // 自动重连设置
    // 注意：MySQL C API 用 unsigned int 表示 bool（0=false, 非0=true）
    if (config.auto_reconnect.has_value()) {
        unsigned int mybool = config.auto_reconnect.value() ? 1 : 0;
        mysql_options(mysql_, MYSQL_OPT_RECONNECT, &mybool);
    }

    // 字符集设置（必须在连接前设置）
    mysql_options(mysql_, MYSQL_SET_CHARSET_NAME, config.charset.c_str());
}

void MySQLConnection::ConnectWithRetry(const MySQLConfig& config) {
    unsigned int err_code = 0;
    std::string err_msg;

    for (unsigned int attempt = 1; attempt <= config.max_retries; ++attempt) {
        try {
            // 每次重试都需要重新初始化（上一次的句柄已被关闭）
            InitAndSetOptions(config);

            if (mysql_real_connect(mysql_,
                                   config.host.c_str(),
                                   config.username.c_str(),
                                   config.password.c_str(),
                                   config.database.c_str(),
                                   config.port,
                                   nullptr,
                                   0)) {
                return;  // 连接成功，直接返回
            }

            // 保存错误信息（同样要在 close 之前）
            err_code = mysql_errno(mysql_);
            err_msg = mysql_error(mysql_);

            mysql_close(mysql_);
            mysql_ = nullptr;

            // 判断是否值得继续重试
            if (!MySQLException(err_code, err_msg).IsRetryable()) {
                break;  // 不可重试的错误（如认证失败），立即退出
            }

            // 等待后重试（避免频繁请求加重服务器负担）
            std::this_thread::sleep_for(
                std::chrono::milliseconds(config.retry_interval_ms));

        } catch (...) {
            if (mysql_) {
                mysql_close(mysql_);
                mysql_ = nullptr;
            }
            throw;
        }
    }

    // 重试耗尽，抛出最后一次的错误
    throw MySQLException(err_code,
        "Failed after " + std::to_string(config.max_retries) +
        " retries: " + err_msg);
}

// ==================== SQL 构建辅助 ====================

std::string MySQLConnection::Escape(const std::string& str) {
    if (!mysql_) {
        throw MySQLException(0, "Connection not established");
    }

    // mysql_real_escape_string 官方建议：缓冲区大小 = 2 * 原长度 + 1
    // 最坏情况：每个字符都需要转义（如 ' → \'）
    std::vector<char> buffer(str.size() * 2 + 1);
    
    // 返回值是转义后的实际长度
    unsigned long len = mysql_real_escape_string(
        mysql_, 
        buffer.data(), 
        str.c_str(),
        static_cast<unsigned long>(str.size())
    );

    return std::string(buffer.data(), len);
}

// std::string MySQLConnection::BuildSQL(const std::string& sql, std::initializer_list<Param> params) {
//     // 预分配内存，减少扩容次数（经验值：每个参数平均 32 字符）
//     std::string result;
//     result.reserve(sql.size() + params.size() * 32);

//     auto param = params.begin();
    
//     for (const char& c : sql) {
//         if (c == '?') {
//             if (param == params.end()) {
//                 throw MySQLBuildException("Not enough parameters for SQL placeholders");
//             }

//             // std::visit + if constexpr：编译期类型分发
//             std::visit([&](auto&& val) {
//                 using T = std::decay_t<decltype(val)>;
                
//                 if constexpr (std::is_same_v<T, nullptr_t>) {
//                     result += "NULL";
//                 } else if constexpr (std::is_same_v<T, std::string>) {
//                     // 字符串：转义 + 加引号（防 SQL 注入的核心）
//                     result += '\'';
//                     result += Escape(val);
//                     result += '\'';
//                 } else if constexpr (std::is_same_v<T, bool>) {
//                     // MySQL 没有原生 bool，用 0/1 表示
//                     result += val ? "1" : "0";
//                 } else {
//                     // 数值类型：直接转字符串（无注入风险）
//                     result += std::to_string(val);
//                 }
//             }, *param);

//             ++param;
//         } else {
//             result.push_back(c);
//         }
//     }

//     if (param != params.end()) {
//         throw MySQLBuildException("Too many parameters for SQL placeholders");
//     }

//     return result;
// }

// 模板实现（放在 cpp 文件中，因为只在本文件内使用）
template<typename Iter>
std::string MySQLConnection::BuildSQL(const std::string& sql, Iter begin, Iter end) {
    std::string result;
    result.reserve(sql.size() + std::distance(begin, end) * 32);

    auto param = begin;
    
    for (const char& c : sql) {
        if (c == '?') {
            if (param == end) {
                throw MySQLBuildException("Not enough parameters for SQL placeholders");
            }

            std::visit([&](auto&& val) {
                using T = std::decay_t<decltype(val)>;
                
                if constexpr (std::is_same_v<T, nullptr_t>) {
                    result += "NULL";
                } else if constexpr (std::is_same_v<T, std::string>) {
                    result += '\'';
                    result += Escape(val);
                    result += '\'';
                } else if constexpr (std::is_same_v<T, bool>) {
                    result += val ? "1" : "0";
                } else {
                    result += std::to_string(val);
                }
            }, *param);

            ++param;
        } else {
            result.push_back(c);
        }
    }

    if (param != end) {
        throw MySQLBuildException("Too many parameters for SQL placeholders");
    }

    return result;
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/db/user_db.cpp ======================

#include "user_db.h"
#include "entity/user_entity.h"
#include "entity/page.h"
#include "common/uuid.h"
#include "exception/mysql_exception.h"
#include "db/mysql_result.h"
#include "common/result.h"
#include "common/error_codes.h"

namespace user_service {

// 定义一个宏，用来检查连接是否有效（减少重复代码）
#define CHECK_CONN(Conn, ResultType)                                            \
    if (!Conn->Valid()) {                                                       \
        LOG_ERROR("mysql_conn is invalid");                                     \
        return ResultType::Fail(ErrorCode::ServiceUnavailable,                  \
                                GetErrorMessage(ErrorCode::ServiceUnavailable));\
    }

UserDB::UserDB(std::shared_ptr<MySQLPool> pool)
    : pool_(pool)
{}

// ==================== Create ====================

Result<UserEntity> UserDB::Create(const UserEntity& user) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<UserEntity>);

        // 生成UUID（通用唯一识别码）
        std::string uuid = UUIDHelper::Generate();

        // 拼接并执行sql
        // 字段：uuid, mobile, display_name, password_hash
        std::string sql = "INSERT INTO users (uuid, mobile, display_name, password_hash, role) "
                          "VALUES (?, ?, ?, ?, ?)";
        conn->Execute(sql, {
            uuid, 
            user.mobile, 
            user.display_name, 
            user.password_hash,
            UserRoleToInt(user.role)
        });
        
        // 通过UUID查询用户（id、created_at等是插入后自动填写的，所以需要再次获取）
        LOG_INFO("Create user success, mobile={}", user.mobile);
        return FindByUUID(uuid);

    } catch (const MySQLDuplicateKeyException& e) {
        // 唯一键冲突：获取冲突的键，返回对应错误码
        LOG_ERROR("Duplicate key error: {}", e.what());
        
        std::string key_name = e.key_name();
        ErrorCode code;
        
        if (key_name == "uk_mobile") {
            code = ErrorCode::MobileTaken;          // 手机号已被注册
        } else if (key_name == "uk_uuid") {
            code = ErrorCode::UserAlreadyExists;    // UUID冲突（极小概率）
        } else {
            code = ErrorCode::UserAlreadyExists;
        }
        
        return Result<UserEntity>::Fail(code, GetErrorMessage(code));

    } catch (const std::exception& e) {
        // 后端执行发生错误，统一返回"模糊信息"给前端
        LOG_ERROR("Create user failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<UserEntity>::Fail(code, GetErrorMessage(code));
    }
}

// ==================== Read ====================

Result<UserEntity> UserDB::FindById(int64_t id) {
    return FindByField("id", std::to_string(id));
}

Result<UserEntity> UserDB::FindByUUID(const std::string& uuid) {
    return FindByField("uuid", uuid);
}

Result<UserEntity> UserDB::FindByMobile(const std::string& mobile) {
    return FindByField("mobile", mobile);
}

// ==================== Update ====================

Result<void> UserDB::Update(const UserEntity& user) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<void>);

        // 拼接sql并执行
        // 注意：mobile 一般不允许直接修改，需要通过换绑接口（后续实现）
        std::string sql = "UPDATE users SET display_name = ?, password_hash = ?, "
                          "disabled = ?, role = ? WHERE uuid = ?";
        
        int64_t affect_row = conn->Execute(sql, {
            user.display_name, 
            user.password_hash,
            user.disabled,
            UserRoleToInt(user.role),  // 新增
            user.uuid
        });
        
        // 通过影响的行数判断是否更新成功
        if (affect_row == 0) {
            LOG_INFO("User with uuid={} not found", user.uuid);
            ErrorCode code = ErrorCode::UserNotFound;
            return Result<void>::Fail(code, GetErrorMessage(code));
        }
        
        LOG_INFO("User with uuid={} update success", user.uuid);
        return Result<void>::Ok();

    } catch (const std::exception& e) {
        // 统一返回"模糊信息"
        LOG_ERROR("Update user failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<void>::Fail(code, GetErrorMessage(code));
    }
}

// ==================== Delete ====================

Result<void> UserDB::Delete(int64_t id) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<void>);

        std::string sql = "DELETE FROM users WHERE id = ?";
        auto affect_row = conn->Execute(sql, {std::to_string(id)});

        // 通过影响的行数判断是否删除成功
        if (affect_row == 0) {
            LOG_INFO("User with id={} not found or already deleted", id);
            ErrorCode code = ErrorCode::UserNotFound;
            return Result<void>::Fail(code, GetErrorMessage(code));
        }
        
        LOG_INFO("User with id={} delete success", id);
        return Result<void>::Ok();

    } catch (const std::exception& e) {
        // 统一返回"模糊信息"
        LOG_ERROR("Delete user failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<void>::Fail(code, GetErrorMessage(code));
    }
}

Result<void> UserDB::DeleteByUUID(const std::string& uuid) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<void>);

        std::string sql = "DELETE FROM users WHERE uuid = ?";
        auto affect_row = conn->Execute(sql, {uuid});

        // 通过影响的行数判断是否删除成功
        if (affect_row == 0) {
            LOG_INFO("User with uuid={} not found or already deleted", uuid);
            ErrorCode code = ErrorCode::UserNotFound;
            return Result<void>::Fail(code, GetErrorMessage(code));
        }
        
        LOG_INFO("User with uuid={} delete success", uuid);
        return Result<void>::Ok();

    } catch (const std::exception& e) {
        // 统一返回"模糊信息"
        LOG_ERROR("Delete user by uuid failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<void>::Fail(code, GetErrorMessage(code));
    }
}

// ==================== 分页查询 ====================

UserDB::UserListResult UserDB::FindAll(const PageParams& page, const std::string& mobile_filter) {
    std::pair<std::vector<UserEntity>, PageResult> result;
    
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, UserListResult);

        // 模糊查询模式
        std::string like_pattern = "%" + mobile_filter + "%";

        // 1. 先查询总记录数
        std::string count_sql = "SELECT COUNT(*) FROM users WHERE mobile LIKE ?";
        auto count_res = conn->Query(count_sql, {like_pattern});
        
        int64_t total_records = 0;
        if (count_res.Next()) {
            total_records = count_res.GetInt(0).value_or(0);
        }

        // 2. 填充分页信息
        result.second = PageResult::Create(page.page, page.page_size, total_records);

        // 3. 分页查询数据
        int64_t offset = static_cast<int64_t>(page.Offset());
        int64_t limit = static_cast<int64_t>(page.page_size);
        
        std::string data_sql = "SELECT * FROM users WHERE mobile LIKE ? "
                               "ORDER BY created_at DESC, id DESC "
                               "LIMIT ?, ?";
        auto data_res = conn->Query(data_sql, {
            like_pattern, 
            offset,
            limit
        });
        
        // 为 vector 预分配内存，避免频繁扩容
        result.first.reserve(page.page_size);
        
        // 解析结果
        while (data_res.Next()) {
            result.first.push_back(ParseRow(data_res));
        }

        return UserListResult::Ok(result);

    } catch (const std::exception& e) {
        LOG_ERROR("FindAll users failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return UserListResult::Fail(code, GetErrorMessage(code));
    }
}

Result<std::vector<UserEntity>> UserDB::FindAll(const UserQueryParams& params) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<std::vector<UserEntity>>);

        // 动态构建 SQL 和参数
        std::string sql = "SELECT * FROM users WHERE 1=1";
        std::vector<MySQLConnection::Param> bindings;

        // 手机号模糊查询
        if (params.mobile_like.has_value() && !params.mobile_like.value().empty()) {
            sql += " AND mobile LIKE ?";
            bindings.push_back("%" + params.mobile_like.value() + "%");
        }

        // 禁用状态过滤
        if (params.disabled.has_value()) {
            sql += " AND disabled = ?";
            bindings.push_back(params.disabled.value());
        }

        // 排序 + 分页
        sql += " ORDER BY created_at DESC, id DESC LIMIT ?, ?";
        bindings.push_back(static_cast<int64_t>(params.page_params.Offset()));
        bindings.push_back(static_cast<int64_t>(params.page_params.page_size));

        // 执行查询
        auto res = conn->Query(sql, bindings);

        // 解析结果
        std::vector<UserEntity> users;
        users.reserve(params.page_params.page_size);

        while (res.Next()) {
            users.push_back(ParseRow(res));
        }

        LOG_DEBUG("FindAll users with params, count={}", users.size());
        return Result<std::vector<UserEntity>>::Ok(users);

    } catch (const std::exception& e) {
        LOG_ERROR("FindAll users with params failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<std::vector<UserEntity>>::Fail(code, GetErrorMessage(code));
    }
}

// ==================== 辅助查询 ====================

Result<bool> UserDB::ExistsByMobile(const std::string& mobile) {
    return ExistsByField("mobile", mobile);
}

// 统计用户数量
Result<int64_t> UserDB::Count(const UserQueryParams& params) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<int64_t>);

        // 动态构建 SQL 和参数（与 FindAll 保持一致的过滤条件）
        std::string sql = "SELECT COUNT(*) FROM users WHERE 1=1";
        std::vector<MySQLConnection::Param> bindings;

        // 手机号模糊查询
        if (params.mobile_like.has_value() && !params.mobile_like.value().empty()) {
            sql += " AND mobile LIKE ?";
            bindings.push_back("%" + params.mobile_like.value() + "%");
        }

        // 禁用状态过滤
        if (params.disabled.has_value()) {
            sql += " AND disabled = ?";
            bindings.push_back(params.disabled.value());
        }

        // 执行查询
        auto res = conn->Query(sql, bindings);

        int64_t count = 0;
        if (res.Next()) {
            count = res.GetInt(0).value_or(0);
        }

        LOG_DEBUG("Count users with params, count={}", count);
        return Result<int64_t>::Ok(count);

    } catch (const std::exception& e) {
        LOG_ERROR("Count users failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<int64_t>::Fail(code, GetErrorMessage(code));
    }
}


// ==================== 私有方法 ====================

Result<UserEntity> UserDB::FindByField(const std::string& field_name, const std::string& field_val) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<UserEntity>);

        // 注意：字段名不能参数化，需要拼接（field_name 是内部传入的安全值）
        // 参数值通过 "?" 传入，避免 SQL 注入
        std::string sql = "SELECT * FROM users WHERE " + field_name + " = ?";

        auto res = conn->Query(sql, {field_val});
        
        // 解析结果
        if (res.Next()) {
            UserEntity user = ParseRow(res);
            LOG_DEBUG("Find user by {}={} success", field_name, field_val);
            return Result<UserEntity>::Ok(user);
        } else {
            LOG_DEBUG("User not found by {}={}", field_name, field_val);
            ErrorCode code = ErrorCode::UserNotFound;
            return Result<UserEntity>::Fail(code, GetErrorMessage(code));
        }

    } catch (const std::exception& e) {
        LOG_ERROR("FindByField failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<UserEntity>::Fail(code, GetErrorMessage(code));
    }
}

Result<bool> UserDB::ExistsByField(const std::string& field_name, const std::string& field_val) {
    try {
        auto conn = pool_->CreateConnection();

        // 检查连接是否有效
        CHECK_CONN(conn, Result<bool>);

        // 注意：字段名不能参数化，需要拼接（field_name 是内部传入的安全值）
        std::string sql = "SELECT 1 FROM users WHERE " + field_name + " = ? LIMIT 1";
        auto res = conn->Query(sql, {field_val});

        bool exists = res.Next();
        return Result<bool>::Ok(exists);

    } catch (const std::exception& e) {
        LOG_ERROR("ExistsByField failed: {}", e.what());
        ErrorCode code = ErrorCode::ServiceUnavailable;
        return Result<bool>::Fail(code, GetErrorMessage(code));
    }
}

UserEntity UserDB::ParseRow(MySQLResult& res) {
    UserEntity user;
    
    // 必填字段
    user.id            = res.GetInt("id").value_or(0);
    user.uuid          = res.GetString("uuid").value_or("");
    user.mobile        = res.GetString("mobile").value_or("");
    user.password_hash = res.GetString("password_hash").value_or("");
    user.role          = IntToUserRole(res.GetInt("role").value_or(0));
    user.disabled      = res.GetInt("disabled").value_or(0) != 0;
    user.created_at    = res.GetString("created_at").value_or("");
    user.updated_at    = res.GetString("updated_at").value_or("");
    
    // 可选字段
    user.display_name  = res.GetString("display_name").value_or("");
    
    return user;
}

#undef CHECK_CONN   // 用完取消宏定义：避免污染全局

}


-----------------------------------------------------


// ====================== ./src/handlers/user_handler.cpp ======================

#include "handlers/user_handler.h"
#include "common/logger.h"
#include "common/validator.h"
#include "common/proto_converter.h"
#include "common/error_codes.h"
#include "common/auth_type.h"
namespace user_service{

namespace {

// 检查是否是管理员
inline Result<void> RequireAdmin(const AuthContext& auth) {
    if (auth.role != UserRole::Admin && auth.role != UserRole::SuperAdmin) {
        return Result<void>::Fail(ErrorCode::AdminRequired, "需要管理员权限");
    }
    return Result<void>::Ok();
}

}  // namespace

// ============================================================================
// 构造函数
// ============================================================================

UserHandler::UserHandler(std::shared_ptr<UserService> user_service,
    std::shared_ptr<Authenticator> authenticator)
: user_service_(std::move(user_service)),
authenticator_(std::move(authenticator)) {  // 保存 authenticator
}

// ============================================================================
// 获取当前用户
// ============================================================================

::grpc::Status UserHandler::GetCurrentUser(
    ::grpc::ServerContext* context,
    const ::pb_user::GetCurrentUserRequest* request,
    ::pb_user::GetCurrentUserResponse* response) {
    
    LOG_DEBUG("GetCurrentUser requested");

    // 1. 认证（从 Token 解析用户信息）
    auto auth_ctx = authenticator_->Authenticate(context);
    if (!auth_ctx.IsOk()) {
        SetResultError(response->mutable_result(), auth_ctx.code, auth_ctx.message);
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = user_service_->GetCurrentUser(auth_ctx.Value().user_uuid);

    // 3. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    if (result.IsOk()) {
        ToProtoUser(result.Value(), response->mutable_user());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 更新用户信息
// ============================================================================

::grpc::Status UserHandler::UpdateUser(
    ::grpc::ServerContext* context,
    const ::pb_user::UpdateUserRequest* request,
    ::pb_user::UpdateUserResponse* response) {
    
    LOG_DEBUG("UpdateUser requested");

    // 1. 认证
    auto auth_ctx = authenticator_->Authenticate(context);
    if (!auth_ctx.IsOk()) {
        SetResultError(response->mutable_result(), auth_ctx.code, auth_ctx.message);
        return ::grpc::Status::OK;
    }

    // 2. 提取可选字段
    std::optional<std::string> display_name;
    if (request->has_display_name()) {
        display_name = request->display_name().value();
    }

    // 3. 调用业务逻辑
    auto result = user_service_->UpdateUser(auth_ctx.Value().user_uuid, display_name);

    // 4. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    if (result.IsOk()) {
        ToProtoUser(result.Value(), response->mutable_user());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 修改密码
// ============================================================================

::grpc::Status UserHandler::ChangePassword(
    ::grpc::ServerContext* context,
    const ::pb_user::ChangePasswordRequest* request,
    ::pb_user::ChangePasswordResponse* response) {
    
    LOG_INFO("ChangePassword requested");

    // 1. 认证
    auto auth_ctx = authenticator_->Authenticate(context);
    if (!auth_ctx.IsOk()) {
        SetResultError(response->mutable_result(), auth_ctx.code, auth_ctx.message);
        return ::grpc::Status::OK;
    }

    // 2. 参数校验
    if (request->old_password().empty()) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, "旧密码不能为空");
        return ::grpc::Status::OK;
    }
    if (request->new_password().empty()) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, "新密码不能为空");
        return ::grpc::Status::OK;
    }

    std::string error;
    if (!IsValidPassword(request->new_password(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }

    // 3. 调用业务逻辑
    auto result = user_service_->ChangePassword(
        auth_ctx.Value().user_uuid,
        request->old_password(),
        request->new_password()
    );

    // 4. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    return ::grpc::Status::OK;
}

// ============================================================================
// 删除用户（注销账号）
// ============================================================================

::grpc::Status UserHandler::DeleteUser(
    ::grpc::ServerContext* context,
    const ::pb_user::DeleteUserRequest* request,
    ::pb_user::DeleteUserResponse* response) {
    
    LOG_INFO("DeleteUser requested");

    // 1. 认证
    auto auth_ctx = authenticator_->Authenticate(context);
    if (!auth_ctx.IsOk()) {
        SetResultError(response->mutable_result(), auth_ctx.code, auth_ctx.message);
        return ::grpc::Status::OK;
    }

    // 2. 参数校验
    std::string error;
    if (!IsValidVerifyCode(request->verify_code(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }

    // 3. 调用业务逻辑
    auto result = user_service_->DeleteUser(
        auth_ctx.Value().user_uuid,
        request->verify_code()
    );

    // 4. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    return ::grpc::Status::OK;
}

// ============================================================================
// 获取指定用户（管理员接口）
// ============================================================================

::grpc::Status UserHandler::GetUser(
    ::grpc::ServerContext* context,
    const ::pb_user::GetUserRequest* request,
    ::pb_user::GetUserResponse* response) {
    
    LOG_INFO("GetUser requested: id={}", request->id());

    // 1. 认证（管理员也需要登录）
    auto auth_ctx = authenticator_->Authenticate(context);
    if (!auth_ctx.IsOk()) {
        SetResultError(response->mutable_result(), auth_ctx.code, auth_ctx.message);
        return ::grpc::Status::OK;
    }

    // 2. 检查管理员权限
    auto admin_check = RequireAdmin(auth_ctx.Value());
    if (!admin_check.IsOk()) {
        SetResultError(response->mutable_result(), admin_check.code, admin_check.message);
        return ::grpc::Status::OK;
    }

    // 3. 参数校验
    if (request->id().empty()) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, "用户ID不能为空");
        return ::grpc::Status::OK;
    }

    // 4. 调用业务逻辑
    auto result = user_service_->GetUser(request->id());

    // 5. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    if (result.IsOk()) {
        ToProtoUser(result.Value(), response->mutable_user());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 获取用户列表（管理员接口）
// ============================================================================

::grpc::Status UserHandler::ListUsers(
    ::grpc::ServerContext* context,
    const ::pb_user::ListUsersRequest* request,
    ::pb_user::ListUsersResponse* response) {
    
    LOG_INFO("ListUsers requested");

    // 1. 认证
    auto auth = authenticator_->Authenticate(context);
    if (!auth.IsOk()) {
        SetResultError(response->mutable_result(), auth.code, auth.message);
        return ::grpc::Status::OK;
    }

    // 2. 检查管理员权限
    auto admin_check = RequireAdmin(auth.Value());
    if (!admin_check.IsOk()) {
        SetResultError(response->mutable_result(), admin_check.code, admin_check.message);
        return ::grpc::Status::OK;
    }

    // 3. 提取参数
    int32_t page = request->has_page() ? request->page().page() : 1;
    int32_t page_size = request->has_page() ? request->page().page_size() : 20;

    std::optional<std::string> mobile_filter;
    if (!request->mobile_filter().empty()) {
        mobile_filter = request->mobile_filter();
    }

    std::optional<bool> disabled_filter;
    if (request->has_disabled_filter()) {
        disabled_filter = request->disabled_filter().value();
    }

    // 4. 调用业务逻辑
    auto result = user_service_->ListUsers(mobile_filter, disabled_filter, page, page_size);

    // 5. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    if (result.IsOk()) {
        const auto& list_result = result.Value();
        
        for (const auto& user : list_result.users) {
            ToProtoUser(user, response->add_users());
        }
        
        auto* page_info = response->mutable_page_info();
        page_info->set_total_records(list_result.page_res.total_records);
        page_info->set_total_pages(list_result.page_res.total_pages);
        page_info->set_page(list_result.page_res.page);
        page_info->set_page_size(list_result.page_res.page_size);
    }

    return ::grpc::Status::OK;
}

}

-----------------------------------------------------


// ====================== ./src/handlers/auth_handler.cpp ======================

#include "handlers/auth_handler.h"
#include "service/auth_service.h"
#include "common/validator.h"
#include "common/logger.h"
#include "common/auth_type.h"
#include "common/proto_converter.h"

namespace user_service{

AuthHandler::AuthHandler(std::shared_ptr<AuthService> auth_service)
    : auth_service_(std::move(auth_service)) {
}

// ============================================================================
// 发送验证码
// ============================================================================

::grpc::Status AuthHandler::SendVerifyCode(
    ::grpc::ServerContext* context,
    const ::pb_auth::SendVerifyCodeRequest* request,
    ::pb_auth::SendVerifyCodeResponse* response) {

    LOG_INFO("SendVerifyCode: mobile={}, scene={}", 
        request->mobile(), static_cast<int>(request->scene()));

    // 1.参数校验
    std::string error;
    if(!IsValidMobile(request->mobile(),error)){
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }

    auto scene=FromProtoSmsScene(request->scene());
    if(scene==SmsScene::UnKnow){
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,"无效的验证码");
        return ::grpc::Status::OK;
    }

    // 2.调用业务逻辑
    auto result=auth_service_->SendVerifyCode(request->mobile(),scene);

    // 3.设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    if(result.IsOk()){
        response->set_retry_after(result.Value());
    }

    return ::grpc::Status::OK;
}


// ============================================================================
// 注册
// ============================================================================

::grpc::Status AuthHandler::Register(
    ::grpc::ServerContext* context,
    const ::pb_auth::RegisterRequest* request,
    ::pb_auth::RegisterResponse* response) {
    
    LOG_INFO("Register: mobile={}", request->mobile());

    // 1. 参数校验
    std::string error;
    if (!IsValidMobile(request->mobile(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }
    if (!IsValidVerifyCode(request->verify_code(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }
    if (!IsValidPassword(request->password(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }
    // display_name 可选，但如果提供了就要校验
    if (!request->display_name().empty() && 
        !IsValidDisplayName(request->display_name(), error)) {
        SetResultError(response->mutable_result(), ErrorCode::InvalidArgument, error);
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->Register(
        request->mobile(),
        request->verify_code(),
        request->password(),
        request->display_name()
    );

    // 3. 设置响应
    SetResultError(response->mutable_result(), result.code, result.message);

    if (result.IsOk()) {
        const auto& auth_result = result.Value();
        // 将业务层结果转为proto结果
        ToProtoUserInfo(auth_result.user, response->mutable_user());
        ToProtoTokenPair(auth_result.tokens, response->mutable_tokens());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 密码登录
// ============================================================================

::grpc::Status AuthHandler::LoginByPassword(
    ::grpc::ServerContext* context,
    const ::pb_auth::LoginByPasswordRequest* request,
    ::pb_auth::LoginByPasswordResponse* response) {
    
    LOG_INFO("LoginByPassword: mobile={}", request->mobile());

    // 1. 参数校验
    std::string error;
    if (!IsValidMobile(request->mobile(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }
    if (request->password().empty()) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,"密码不能为空");
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->LoginByPassword(
        request->mobile(),
        request->password()
    );

    // 3. 设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    if (result.IsOk()) {
        const auto& auth_result = result.Value();
        // 将业务层结果转为proto结果
        ToProtoUserInfo(auth_result.user,response->mutable_user());
        ToProtoTokenPair(auth_result.tokens,response->mutable_tokens());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 验证码登录
// ============================================================================

::grpc::Status AuthHandler::LoginByCode(
    ::grpc::ServerContext* context,
    const ::pb_auth::LoginByCodeRequest* request,
    ::pb_auth::LoginByCodeResponse* response) {
    
    LOG_INFO("LoginByCode: mobile={}", request->mobile());

    // 1. 参数校验
    std::string error;
    if (!IsValidMobile(request->mobile(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }
    if (!IsValidVerifyCode(request->verify_code(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->LoginByCode(
        request->mobile(),
        request->verify_code()
    );

    // 3. 设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    if (result.IsOk()) {
        const auto& auth_result = result.Value();
        // 将业务层结果转为proto结果
        ToProtoUserInfo(auth_result.user,response->mutable_user());
        ToProtoTokenPair(auth_result.tokens,response->mutable_tokens());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 刷新 Token
// ============================================================================

::grpc::Status AuthHandler::RefreshToken(
    ::grpc::ServerContext* context,
    const ::pb_auth::RefreshTokenRequest* request,
    ::pb_auth::RefreshTokenResponse* response) {
    
    LOG_DEBUG("RefreshToken requested");

    // 1. 参数校验
    if (request->refresh_token().empty()) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,"refresh_token 不能为空");
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->RefreshToken(request->refresh_token());

    // 3. 设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    if (result.IsOk()) {
        const auto& token_pair = result.Value();
        ToProtoTokenPair(token_pair,response->mutable_tokens());
    }

    return ::grpc::Status::OK;
}

// ============================================================================
// 登出
// ============================================================================

::grpc::Status AuthHandler::Logout(
    ::grpc::ServerContext* context,
    const ::pb_auth::LogoutRequest* request,
    ::pb_auth::LogoutResponse* response) {
    
    LOG_INFO("Logout requested");

    // 1. 参数校验
    if (request->refresh_token().empty()) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,"refresh_token 不能为空");
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->Logout(request->refresh_token());

    // 3. 设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    return ::grpc::Status::OK;
}

// ============================================================================
// 重置密码
// ============================================================================

::grpc::Status AuthHandler::ResetPassword(
    ::grpc::ServerContext* context,
    const ::pb_auth::ResetPasswordRequest* request,
    ::pb_auth::ResetPasswordResponse* response) {
    
    LOG_INFO("ResetPassword: mobile={}", request->mobile());

    // 1. 参数校验
    std::string error;
    if (!IsValidMobile(request->mobile(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }
    if (!IsValidVerifyCode(request->verify_code(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }
    if (!IsValidPassword(request->new_password(), error)) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,error);
        return ::grpc::Status::OK;
    }

    // 2. 调用业务逻辑
    auto result = auth_service_->ResetPassword(
        request->mobile(),
        request->verify_code(),
        request->new_password()
    );

    // 3. 设置响应
    SetResultError(response->mutable_result(),result.code,result.message);

    return ::grpc::Status::OK;
}

// ============================================================================
// 验证 Token（内部服务调用）
// ============================================================================

::grpc::Status AuthHandler::ValidateToken(
    ::grpc::ServerContext* context,
    const ::pb_auth::ValidateTokenRequest* request,
    ::pb_auth::ValidateTokenResponse* response) {
    
    LOG_DEBUG("ValidateToken requested");

    // 1. 参数校验
    if (request->access_token().empty()) {
        SetResultError(response->mutable_result(),ErrorCode::InvalidArgument,"access_token 不能为空");
        return ::grpc::Status::OK;
    }

    // 2. 验证 Token
    auto verify_res=auth_service_->ValidateAccessToken(request->access_token());
    if(!verify_res.IsOk()){
        SetResultError(response->mutable_result(),verify_res.code,verify_res.message);
        return ::grpc::Status::OK;
    }

    // 3. 设置响应
    SetResultOk(response->mutable_result());
    SetValidateTokenResponse(verify_res.Value(),response);

    return ::grpc::Status::OK;
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./src/handlers/CMakeLists.txt ======================

add_library(user_handler auth_handler.cpp user_handler.cpp)

target_include_directories(user_handler PUBLIC
    ${PROJECT_SOURCE_DIR}/include
    ${PROJECT_SOURCE_DIR}/include/handlers
)

# 链接 proto_lib，自动继承其 include 路径
target_link_libraries(user_handler PUBLIC
    proto_lib
    user_auth
    user_service
)

add_dependencies(user_handler proto_lib)

-----------------------------------------------------


// ====================== ./src/discovery/CMakeLists.txt ======================

add_library(user_discovery 
    service_registry.cpp 
    service_discovery.cpp 
    zk_client.cpp
)

target_include_directories(user_discovery PUBLIC
    ${PROJECT_SOURCE_DIR}/include
    ${PROJECT_SOURCE_DIR}/include/discovery
    ${PROJECT_SOURCE_DIR}/thirdparty
    ${ZOOKEEPER_INCLUDE_DIRS}   # pkg_check_modules 设置的是 _DIRS（复数）
)

# 关键：定义 THREADED 宏，启用 ZooKeeper 同步 API
target_compile_definitions(user_discovery PUBLIC
    THREADED
)

target_link_libraries(user_discovery PUBLIC
    ${ZOOKEEPER_LIBRARIES}      # pkg_check_modules 设置的是 _LIBRARIES（复数）
    user_common
)


-----------------------------------------------------


// ====================== ./src/discovery/service_discovery.cpp ======================

#include "service_discovery.h"
#include "common/logger.h"

namespace user_service{

ServiceDiscovery::ServiceDiscovery(std::shared_ptr<ZooKeeperClient> zk_client,
    const std::string& root_path)
    : zk_client_(std::move(zk_client))
    , root_path_(root_path) {
}

ServiceDiscovery::~ServiceDiscovery() {
    // 取消所有订阅
    std::vector<std::string> services;
    {
        std::shared_lock<std::shared_mutex> lock(cache_mutex_);
        for (const auto& [name, _] : instance_cache_) {
            services.push_back(name);
        }
    }
    
    for (const auto& service : services) {
        Unsubscribe(service);
    }
}

void ServiceDiscovery::Subscribe(const std::string& service_name,
                                 ServiceChangeCallback callback) {
    
    // 检查zookeeper客户端句柄的有效性
    if (!zk_client_ || !zk_client_->IsConnected()) {
        LOG_ERROR("ZK client not connected, cannot subscribe: {}", service_name);
        return;
    }
    
    // 保存回调
    if (callback) {
        std::lock_guard<std::mutex> lock(callback_mutex_);
        callbacks_[service_name] = std::move(callback);
    }
    
    // 立即刷新一次实例列表
    RefreshInstances(service_name);
    
    // 设置 Watch
    std::string service_path = BuildServicePath(service_name);
    zk_client_->WatchChildren(service_path, 
        // 子节点改变是的“回调函数”
        [this](const std::string& path) {
            OnChildrenChanged(path);
        });
    
    LOG_INFO("Subscribed to service: {}", service_name);
}

void ServiceDiscovery::Unsubscribe(const std::string& service_name) {
    
    // 取消 Watch
    std::string service_path = BuildServicePath(service_name);
    if (zk_client_) {
        zk_client_->UnwatchChildren(service_path);
    }
    
    // 清理回调
    {
        std::lock_guard<std::mutex> lock(callback_mutex_);
        callbacks_.erase(service_name);
    }
    
    // 清理缓存
    {
        std::unique_lock<std::shared_mutex> lock(cache_mutex_);
        instance_cache_.erase(service_name);
    }
    
    LOG_INFO("Unsubscribed from service: {}", service_name);
}

// 获取服务的所有实例
std::vector<ServiceInstance> ServiceDiscovery::GetInstances(const std::string& service_name) {
    std::shared_lock<std::shared_mutex> lock(cache_mutex_);
    
    auto it = instance_cache_.find(service_name);
    if (it != instance_cache_.end()) {
        return it->second;
    }
    
    return {};
}

// 选择一个实例（随机负载均衡，自己实现）
std::shared_ptr<ServiceInstance> ServiceDiscovery::SelectInstance(const std::string& service_name) {
    // 获取实例列表
    auto instances = GetInstances(service_name);
    
    if (instances.empty()) {
        LOG_WARN("No available instance for service: {}", service_name);
        return nullptr;
    }
    
    // 随机选择一个实例
    std::uniform_int_distribution<size_t> dist(0, instances.size() - 1);
    size_t index = dist(rng_);
    
    return std::make_shared<ServiceInstance>(instances[index]);
}

// 选择一个实例（加权随机，自己实现）
std::shared_ptr<ServiceInstance> ServiceDiscovery::SelectInstanceWeighted(
    const std::string& service_name) {
    
    // 获取实例列表
    auto instances = GetInstances(service_name);
    
    if (instances.empty()) {
        LOG_WARN("No available instance for service: {}", service_name);
        return nullptr;
    }
    
    // 计算总权重
    int total_weight = 0;
    for (const auto& inst : instances) {
        total_weight += inst.weight;
    }
    
    if (total_weight <= 0) {
        // 权重都为0，退化为随机选择
        return SelectInstance(service_name);
    }
    
    // 加权随机
    std::uniform_int_distribution<int> dist(1, total_weight);
    int random_weight = dist(rng_);
    
    int current_weight = 0;
    for (const auto& inst : instances) {
        current_weight += inst.weight;
        if (random_weight <= current_weight) {
            return std::make_shared<ServiceInstance>(inst);
        }
    }
    
    // 理论上不会到这里
    return std::make_shared<ServiceInstance>(instances.back());
}

// 刷新指定服务的实例列表
void ServiceDiscovery::RefreshInstances(const std::string& service_name) {
    if (!zk_client_ || !zk_client_->IsConnected()) {
        return;
    }
    
    // 构造 服务路径名
    std::string service_path = BuildServicePath(service_name);
    
    // 获取子节点列表（实例ID列表，ip:port）
    auto children = zk_client_->GetChildren(service_path);
    
    std::vector<ServiceInstance> instances;
    instances.reserve(children.size());
    
    // 获取每个实例的详细信息
    for (const auto& child : children) {
        // 通过实例节点路径，获取实例节点数据（json存储）
        std::string instance_path = service_path + "/" + child;
        std::string data = zk_client_->GetData(instance_path);
        
        if (!data.empty()) {
            // 反序列化出“实例节点数据”
            ServiceInstance instance = ServiceInstance::FromJson(data);
            if (instance.IsValid()) {
                instances.push_back(std::move(instance));
            } else {
                LOG_WARN("Invalid instance data at: {}", instance_path);
            }
        }
    }
    
    // 更新缓存
    {
        std::unique_lock<std::shared_mutex> lock(cache_mutex_);
        instance_cache_[service_name] = std::move(instances);
    }
    
    LOG_DEBUG("Refreshed service {}: {} instances", 
              service_name, instance_cache_[service_name].size());
}

void ServiceDiscovery::OnChildrenChanged(const std::string& path) {
    
    // 获取服务名
    std::string service_name = ExtractServiceName(path);
    
    if (service_name.empty()) {
        LOG_WARN("Cannot extract service name from path: {}", path);
        return;
    }
    
    LOG_INFO("Service {} instances changed, refreshing...", service_name);
    
    // 刷新实例列表
    RefreshInstances(service_name);
    
    // 触发回调
    ServiceChangeCallback callback;
    {
        std::lock_guard<std::mutex> lock(callback_mutex_);
        auto it = callbacks_.find(service_name);
        if (it != callbacks_.end()) {
            callback = it->second;
        }
    }
    
    if (callback) {
        callback(service_name);
    }
}

std::string ServiceDiscovery::ExtractServiceName(const std::string& path) const {
    // /services/user-service -> user-service
    if (path.length() <= root_path_.length() + 1) {
        return "";
    }
    
    return path.substr(root_path_.length() + 1);  // +1 跳过 '/'
}

std::string ServiceDiscovery::BuildServicePath(const std::string& service_name) const {
    return root_path_ + "/" + service_name;
}

}

-----------------------------------------------------


// ====================== ./src/discovery/service_registry.cpp ======================

#include "service_registry.h"
#include "common/logger.h"

namespace user_service{


ServiceRegistry::ServiceRegistry(std::shared_ptr<ZooKeeperClient> zk_client,
    const std::string& root_path)
    : zk_client_(std::move(zk_client))
    , root_path_(root_path) {
}


ServiceRegistry::~ServiceRegistry() {
    Unregister();
}

bool ServiceRegistry::Register(const ServiceInstance& instance){
    std::lock_guard<std::mutex> lock(mutex_);

    // 检查zookeeper客户端句柄的有效性
    if(!zk_client_ || !zk_client_->IsConnected()){
        LOG_ERROR("ZK client not connected, cannot register service");
        return false;
    }

    // 检查 服务示例信息 的有效性
    if(!instance.IsValid()){
        LOG_ERROR("Invalid service instance: host={}, port={}", 
            instance.host, instance.port);
            return false;
    }

    // 1.确保服务路径存在（持久节点）
    std::string service_path=BuildServicePath(instance.service_name);
    if(!zk_client_->CreateServicePath(service_path)){
        LOG_ERROR("Failed to create service path: {}", service_path);
        return false;
    }

    // 2.创建实例节点（临时节点）
    std::string instance_path = BuildInstancePath(instance);
    std::string data=instance.ToJson();

    if(!zk_client_->CreateNode(instance_path,data,true)){
        LOG_ERROR("Failed to create instance node: {}", instance_path);
        return false;
    }

    // 3.保存状态（方便之后进行修改、取消注册）
    current_instance_ =instance;
    current_path_=instance_path;
    registered_=true;

    LOG_INFO("Service registered: {} at {}", 
        instance.service_name, instance.GetAddress());

    return true;
}

bool ServiceRegistry::Unregister(){
    std::lock_guard<std::mutex> lock(mutex_);

    // 检查是否注册
    if(!registered_.load()){
        return true;  // 未注册，视为成功
    }

    // 句柄失效，则服务实例也就失效了（因为是临时节点）
    if(!zk_client_){
        registered_ = false;
        return true;
    }

    // 删除实例节点
    bool success=zk_client_->DeleteNode(current_path_);

    if (success) {
        LOG_INFO("Service unregistered: {} at {}", 
                 current_instance_.service_name, 
                 current_instance_.GetAddress());
    } else {
        LOG_WARN("Failed to unregister service, node may already be deleted");
    }

    // 更新状态
    registered_=false;
    current_path_.clear();

    return true;
}



bool ServiceRegistry::Update(const ServiceInstance& instance){
    std::lock_guard<std::mutex> lock(mutex_);
    
    // 检查是否注册
    if(!registered_.load()){
        LOG_ERROR("Service not registered, cannot update");
        return false;
    }

    // 检查zookeeper客户端句柄的有效性
    if (!zk_client_ || !zk_client_->IsConnected()) {
        LOG_ERROR("ZK client not connected, cannot update");
        return false;
    }

    // 序列化节点数据
    std::string data = instance.ToJson();

    if (!zk_client_->SetData(current_path_, data)) {
        LOG_ERROR("Failed to update service instance: {}", current_path_);
        return false;
    }

    current_instance_ = instance;
    LOG_DEBUG("Service instance updated: {}", current_path_);
    
    return true;
}

std::string ServiceRegistry::BuildInstancePath(const ServiceInstance& instance) const {
    // 格式：/services/user-service/192.168.1.10:50051
    return root_path_ + "/" + instance.service_name + "/" + instance.GetAddress();
}

std::string ServiceRegistry::BuildServicePath(const std::string& service_name) const {
    // 格式：/services/user-service
    return root_path_ + "/" + service_name;
}

}

-----------------------------------------------------


// ====================== ./src/discovery/zk_client.cpp ======================

// src/discovery/zk_client.cpp
#include "zk_client.h"
#include "common/logger.h"
#include <sstream>
#include <cstring>
#include <zookeeper/zookeeper.h>

namespace user_service{

// ============================================================================
// 构造与析构
// ============================================================================

ZooKeeperClient::ZooKeeperClient(const std::string& hosts, int session_timeout_ms)
    : hosts_(hosts)
    , session_timeout_ms_(session_timeout_ms)
    , closing_(false) {
    
    // 设置 ZK 日志级别（可选）
    zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);
}

ZooKeeperClient::~ZooKeeperClient() {
    Close();
}

// ============================================================================
// 通用接口（gRPC 服务端 + gRPC 客户端 都使用）
// ============================================================================

bool ZooKeeperClient::Connect(int timeout_ms){
    std::unique_lock<std::mutex> lock(conn_mutex_);

    // 已连接
    if(zh_ && connected_.load()){
        return true;
    }

    // 关闭旧连接
    if(zh_){
        zookeeper_close(zh_);
        zh_=nullptr;
    }

    connected_=false;
    closing_ = false;

    // 初始化 ZK 句柄
    zh_=zookeeper_init(hosts_.c_str(),GlobalWatcher,session_timeout_ms_,nullptr,this,0);

    if (!zh_) {
        LOG_ERROR("zookeeper_init failed, hosts={}", hosts_);
        return false;
    }

    // 等待连接建立（使用条件变量）——> 连接建立成功时，会在”回调函数“中将connected_设置为true
    bool success = conn_cv_.wait_for(lock,
                std::chrono::milliseconds(timeout_ms),
                [this]{return connected_.load();});

    if(!success){
        LOG_ERROR("ZooKeeper connection timeout, hosts={}", hosts_);
        zookeeper_close(zh_);
        zh_ = nullptr;
        return false; 
    }

    LOG_INFO("ZooKeeper client connected, hosts={}", hosts_);
    return true;
}

void ZooKeeperClient::Close() {
    // 1. 标记正在关闭
    closing_.store(true);
    
    // 2. 先清空回调映射，阻止新回调执行
    {
        std::lock_guard<std::mutex> lock(watch_mutex_);
        watches_.clear();
    }
    
    // 3. 等待一小段时间，让正在执行的回调完成
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    
    // 4. 关闭 ZK 连接
    if (zh_) {
        zookeeper_close(zh_);
        zh_ = nullptr;
        connected_ = false;
        LOG_INFO("ZooKeeper connection closed");
    }
}

bool ZooKeeperClient::IsConnected() const {
    return zh_ && connected_.load() && !closing_.load() &&
           zoo_state(zh_) == ZOO_CONNECTED_STATE;
}

// ============================================================================
// gRPC 服务端使用的接口（服务注册）
// ============================================================================

// 创建节点
bool ZooKeeperClient::CreateNode(const std::string& path, 
                                const std::string& data,
                                bool ephemeral){
    if(!IsConnected()){
        LOG_ERROR("ZK not connected, cannot create node: {}", path);
        return false;
    }

    // 节点类型（临时节点/顺序节点/临时顺序节点）
    int flags=ephemeral ? ZOO_EPHEMERAL:0;

    // 创建节点
    int rc=zoo_create(zh_,path.c_str(),data.c_str(),data.size(),
                        &ZOO_OPEN_ACL_UNSAFE,flags,nullptr,0);
    
    if(rc==ZOK){    // 节点创建成功
        LOG_DEBUG("ZK node created: {} (ephemeral={})", path, ephemeral);
        return true;
    }else if(rc==ZNODEEXISTS){
        // 节点已存在，对于持久节点视为成功
        // 对于临时节点，可能是上次会话残留，需要特殊处理
        if(ephemeral){
            LOG_WARN("ZK ephemeral node already exists: {}, attempting recovery...", path);
            
            // 尝试删除旧节点后重新创建
            if(DeleteNode(path)){
                rc=zoo_create(zh_,path.c_str(),data.c_str(),data.size(),
                              &ZOO_OPEN_ACL_UNSAFE,flags,nullptr,0);
                if(rc==ZOK){
                    LOG_INFO("ZK ephemeral node recreated: {}", path);
                    return true;
                }
            }
            
            // 如果删除重建失败，尝试直接更新数据
            if(SetData(path,data)){
                LOG_INFO("ZK ephemeral node data updated: {}", path);
                return true;
            }
            
            LOG_ERROR("Failed to recover ephemeral node: {}", path);
            return false;
        }
        return true;
    }else{
        LOG_ERROR("ZK create failed: path={}, error={}", path, zerror(rc));
        return false;
    }
}

bool ZooKeeperClient::CreateServicePath(const std::string& path){
    if(!IsConnected()){
        return false;
    }

    // 使用stringstream 分割路径
    std::string current;
    std::istringstream ss(path);
    std::string token;

    /*
    输入：/services/user
    循环过程大概是：
        - token=services → current=/services → 不存在就创建
        - token=user → current=/services/user → 不存在就创建
    最终路径保证存在。
    */
    while(std::getline(ss,token,'/')){  
        if(token.empty()) continue;

        current += "/" + token;

        if(!Exists(current)){   // 节点不存在
            // 创建持久节点(节点值为空)
            if(!CreateNode(current,"",false)){
                return false;
            }
        }
    }

    return true;
}

// 删除节点
bool ZooKeeperClient::DeleteNode(const std::string& path){
    if(!IsConnected()){
        return false;
    }

    int rc = zoo_delete(zh_,path.c_str(),-1);    // -1 表示忽略版本

    if (rc == ZOK) {
        LOG_DEBUG("ZK node deleted: {}", path);
        return true;
    } else if (rc == ZNONODE) {
        // 节点不存在，视为删除成功
        return true;
    } else {
        LOG_ERROR("ZK delete failed: path={}, error={}", path, zerror(rc));
        return false;
    }
}

// 判断节点是否存在
bool ZooKeeperClient::Exists(const std::string& path) {
    if(!IsConnected()){
        return false;
    }

    struct Stat stat;
    int rc=zoo_exists(zh_,path.c_str(),0,&stat);
    return rc == ZOK;
}

// 设置节点数据
bool ZooKeeperClient::SetData(const std::string& path, const std::string& data) {
    if(!IsConnected()){
        return false;
    }

    int rc = zoo_set(zh_, path.c_str(), data.c_str(), data.size(), -1);

    if (rc == ZOK) {
        LOG_DEBUG("ZK set data: path={}, size={}", path, data.size());
        return true;
    } else {
        LOG_ERROR("ZK set data failed: path={}, error={}", path, zerror(rc));
        return false;
    }
}

// ============================================================================
// gRPC 客户端使用的接口（服务发现）
// ============================================================================

// 获取节点数据
std::string ZooKeeperClient::GetData(const std::string& path){
    if(!IsConnected()){
        return "";
    }

    // 使用 vector 在堆上分配内存，避免栈溢出风险
    constexpr int kMaxDataSize = 65536;  // 64KB
    std::vector<char> buffer(kMaxDataSize);
    int buffer_len = static_cast<int>(buffer.size());
    struct Stat stat;

    // 获取指定实例节点的数据，如"ip:port"
    int rc = zoo_get(zh_, path.c_str(), 0, buffer.data(), &buffer_len, &stat);

    if (rc == ZOK && buffer_len > 0) {
        return std::string(buffer.data(), buffer_len);
    } else if (rc != ZOK) {
        LOG_WARN("ZK get data failed: path={}, error={}", path, zerror(rc));
    }

    return "";
}

// 获取指定目录下所有子节点
std::vector<std::string> ZooKeeperClient::GetChildren(const std::string& path) {
    std::vector<std::string> result;
    
    if (!IsConnected()) {
        return result;
    }
    
    struct String_vector children;
    int rc = zoo_get_children(zh_, path.c_str(), 0, &children);
    
    if (rc == ZOK) {
        result.reserve(children.count);
        for (int i = 0; i < children.count; ++i) {
            result.emplace_back(children.data[i]);
        }
        deallocate_String_vector(&children);
    } else {
        LOG_WARN("ZK get children failed: path={}, error={}", path, zerror(rc));
    }
    
    return result;
}

// 监听子节点
void ZooKeeperClient::WatchChildren(const std::string& path, WatchCallback callback){
    if (!IsConnected() || closing_.load()) {
        LOG_ERROR("ZK not connected or closing, cannot watch: {}", path);
        return;
    }

    // 保存回调
    {
        std::lock_guard<std::mutex> lock(watch_mutex_);
        /* 存储客户端传入的回调函数
           - 每次触发watch后，都需要重新设置，也就需要再次使用“客户端传入的回调函数”
           - 故：需要存储 path ——> callback 的map映射，方便重复使用 
        */
        watches_[path] = std::move(callback);
    }

    // 设置 watch 并获取当前子节点
    struct String_vector children;
    int rc=zoo_wget_children(zh_, path.c_str(), GlobalWatcher, this, &children);

    if (rc == ZOK) {
        // ★ 释放 String_vector 内存（必须调用！）
        deallocate_String_vector(&children);
        LOG_DEBUG("ZK watch set: {}", path);
    } else {
        LOG_ERROR("ZK watch failed: path={}, error={}", path, zerror(rc));
    }
}

// 取消监听子节点
void ZooKeeperClient::UnwatchChildren(const std::string& path) {
    std::lock_guard<std::mutex> lock(watch_mutex_);
    /* watch是一次性的，触发后需要重新注册，即从watches_中通过path取出callback进行注册
        - 只要将对应的callback从watches_中移除，之后path对应的节点也就无法再注册watch
          也就达到了“取消监听子节点”的目的*/
    watches_.erase(path);
    LOG_DEBUG("ZK watch removed: {}", path);
}

// ============================================================================
// 内部实现（静态 Watcher 回调 + 事件处理）
// ============================================================================

// 全局 Watcher 回调（静态，供 C API 调用）
void ZooKeeperClient::GlobalWatcher(zhandle_t* zh, int type, int state,
                    const char* path, void* context){
    
    ZooKeeperClient* client = static_cast<ZooKeeperClient*>(context);

    // 安全检查
    if (!client) {
        return;
    }
    
    // 检查是否正在关闭
    if (client->closing_.load()) {
        return;
    }
    if(type==ZOO_SESSION_EVENT){
        // 会话事件：连接、断开、过期等
        client->HandleSessionEvent(state);
    }else if(type==ZOO_CHILD_EVENT && path){
        // 子节点变化事件
        client->HandleChildEvent(path);
    }
}

// 处理会话状态变化
void ZooKeeperClient::HandleSessionEvent(int state) {
    if (closing_.load()) return;

    if (state == ZOO_CONNECTED_STATE) { 
        // 连接成功
        connected_ = true;
        LOG_INFO("ZooKeeper connected");
        conn_cv_.notify_all();  // 通知等待连接的线程
    } else if (state == ZOO_EXPIRED_SESSION_STATE) {
        // 会话过期
        connected_ = false;
        LOG_WARN("ZooKeeper session expired");
    } else if (state == ZOO_CONNECTING_STATE) {
        // 正在连接
        connected_ = false;
        LOG_INFO("ZooKeeper reconnecting...");
    } else if (state == ZOO_ASSOCIATING_STATE) {
        // 关联中
        LOG_DEBUG("ZooKeeper associating...");
    } else {
        LOG_WARN("ZooKeeper unknown state: {}", state);
    }
}

// 处理子节点列表变更
void ZooKeeperClient::HandleChildEvent(const std::string& path) {
    // 检查是否正在关闭
    if (closing_.load()) {
        return;
    }

    WatchCallback callback;
    
    {
        std::lock_guard<std::mutex> lock(watch_mutex_);

        // 双重检查
        if (closing_.load()) {
            return;
        }

        auto it = watches_.find(path);
        if (it == watches_.end()) {
            return;
        }
        callback = it->second;  // 复制回调
    }

    // 再次检查
    if (!callback || closing_.load()) {
        return;
    }

    // 执行回调
    try {
        callback(path);
    } catch (const std::exception& e) {
        LOG_ERROR("Watch callback exception: {}", e.what());
    } catch (...) {
        LOG_ERROR("Watch callback unknown exception");
    }

    // 重新注册前再次检查
    if (!closing_.load()) {
        ResetWatch(path);
    }
}

// 重新注册指定路径的 watch
void ZooKeeperClient::ResetWatch(const std::string& path){
    if (closing_.load()) {
        return;
    }

    {
        std::lock_guard<std::mutex> lock(watch_mutex_);
        // 检查是否需要再监听
        if(watches_.find(path) == watches_.end()){
            return;
        }
    }

    if (!IsConnected()) {
        return;
    }

    struct String_vector children;

    int rc=zoo_wget_children(zh_, path.c_str(), GlobalWatcher, this, &children);

    if(rc==ZOK){
        deallocate_String_vector(&children);
    }else{
        LOG_WARN("Failed to reset watch for {}: {}", path, zerror(rc));
    }
}

}   // namespace user_service


-----------------------------------------------------


// ====================== ./src/config/config.cpp ======================

#include "config/config.h"
#include <yaml-cpp/yaml.h>
#include <stdexcept>
#include <sstream>
#include <cstdlib>

namespace user_service {

// 配置加载完成后，添加合法性校验
void ValidateConfig(const Config& config) {
    // 校验端口合法性（1-65535）
    if (config.server.grpc_port <= 0 || config.server.grpc_port > 65535) {
        throw std::runtime_error("Invalid gRPC port: " + std::to_string(config.server.grpc_port));
    }
    if (config.server.metrics_port <= 0 || config.server.metrics_port > 65535) {
        throw std::runtime_error("Invalid metrics port: " + std::to_string(config.server.metrics_port));
    }
    if (config.mysql.port <= 0 || config.mysql.port > 65535) {
        throw std::runtime_error("Invalid MySQL port: " + std::to_string(config.mysql.port));
    }

    // 校验连接池大小（大于 0）
    if (config.mysql.pool_size <= 0) {
        throw std::runtime_error("Invalid MySQL pool size: " + std::to_string(config.mysql.pool_size));
    }
    if (config.redis.pool_size <= 0) {
        throw std::runtime_error("Invalid Redis pool size: " + std::to_string(config.redis.pool_size));
    }

    // 校验核心配置非空
    if (config.mysql.host.empty()) {
        throw std::runtime_error("MySQL host is empty");
    }
    if (config.mysql.database.empty()) {
        throw std::runtime_error("MySQL database is empty");
    }
    if (config.security.jwt_secret.empty()) {
        throw std::runtime_error("JWT secret is empty");
    }
    if (config.security.jwt_issuer.empty()) {
        throw std::runtime_error("JWT issuer is empty");
    }

    // 校验 Token TTL 合法性
    if (config.security.access_token_ttl_seconds <= 0) {
        throw std::runtime_error("Invalid access token TTL: " + 
            std::to_string(config.security.access_token_ttl_seconds));
    }
    if (config.security.refresh_token_ttl_seconds <= 0) {
        throw std::runtime_error("Invalid refresh token TTL: " + 
            std::to_string(config.security.refresh_token_ttl_seconds));
    }
    // Refresh Token TTL 应该大于 Access Token TTL
    if (config.security.refresh_token_ttl_seconds <= config.security.access_token_ttl_seconds) {
        throw std::runtime_error("Refresh token TTL should be greater than access token TTL");
    }

    // 校验验证码配置合法性
    if (config.sms.code_len <= 0 || config.sms.code_len > 10) {
        throw std::runtime_error("Invalid SMS code length: " + std::to_string(config.sms.code_len));
    }
    if (config.sms.code_ttl_seconds <= 0) {
        throw std::runtime_error("Invalid SMS code TTL: " + std::to_string(config.sms.code_ttl_seconds));
    }
    if (config.sms.send_interval_seconds <= 0) {
        throw std::runtime_error("Invalid SMS send interval: " + std::to_string(config.sms.send_interval_seconds));
    }
    if (config.sms.max_retry_count <= 0) {
        throw std::runtime_error("Invalid SMS max retry count: " + std::to_string(config.sms.max_retry_count));
    }
    if (config.sms.retry_ttl_seconds <= 0) {
        throw std::runtime_error("Invalid SMS retry TTL: " + std::to_string(config.sms.retry_ttl_seconds));
    }
    if (config.sms.lock_seconds <= 0) {
        throw std::runtime_error("Invalid SMS lock seconds: " + std::to_string(config.sms.lock_seconds));
    }
    // 锁定时间应大于验证码有效期
    if (config.sms.lock_seconds < config.sms.code_ttl_seconds) {
        throw std::runtime_error("SMS lock seconds should be greater than or equal to code TTL");
    }

    // ============ 校验登录配置 ============
    if (config.login.max_failed_attempts <= 0) {
        throw std::runtime_error("Invalid login max failed attempts: " + 
            std::to_string(config.login.max_failed_attempts));
    }
    if (config.login.failed_attempts_window <= 0) {
        throw std::runtime_error("Invalid login failed attempts window: " + 
            std::to_string(config.login.failed_attempts_window));
    }
    if (config.login.lock_duration_seconds <= 0) {
        throw std::runtime_error("Invalid login lock duration: " + 
            std::to_string(config.login.lock_duration_seconds));
    }
    if (config.login.max_sessions_per_user <= 0) {
        throw std::runtime_error("Invalid max sessions per user: " + 
            std::to_string(config.login.max_sessions_per_user));
    }
    // 图形验证码触发阈值应小于等于最大失败次数
    if (config.login.captcha_after_failed_attempts > config.login.max_failed_attempts) {
        throw std::runtime_error("Captcha trigger threshold should be <= max failed attempts");
    }

    // ============ 校验密码策略配置 ============
    if (config.password.min_length <= 0) {
        throw std::runtime_error("Invalid password min length: " + 
            std::to_string(config.password.min_length));
    }
    if (config.password.max_length <= 0) {
        throw std::runtime_error("Invalid password max length: " + 
            std::to_string(config.password.max_length));
    }
    if (config.password.min_length > config.password.max_length) {
        throw std::runtime_error("Password min length should be <= max length");
    }
    if (config.password.expire_days < 0) {
        throw std::runtime_error("Invalid password expire days: " + 
            std::to_string(config.password.expire_days));
    }
    if (config.password.history_count < 0) {
        throw std::runtime_error("Invalid password history count: " + 
            std::to_string(config.password.history_count));
    }

    // ============ 校验 ZooKeeper 配置 ============
    if (config.zookeeper.enabled) {
        if (config.zookeeper.hosts.empty()) {
            throw std::runtime_error("ZooKeeper hosts is empty");
        }
        if (config.zookeeper.session_timeout_ms <= 0) {
            throw std::runtime_error("Invalid ZooKeeper session timeout: " + 
                std::to_string(config.zookeeper.session_timeout_ms));
        }
        if (config.zookeeper.connect_timeout_ms <= 0) {
            throw std::runtime_error("Invalid ZooKeeper connect timeout: " + 
                std::to_string(config.zookeeper.connect_timeout_ms));
        }
        if (config.zookeeper.root_path.empty()) {
            throw std::runtime_error("ZooKeeper root path is empty");
        }
        if (config.zookeeper.root_path[0] != '/') {
            throw std::runtime_error("ZooKeeper root path must start with '/'");
        }
        if (config.zookeeper.register_self && config.zookeeper.service_name.empty()) {
            throw std::runtime_error("ZooKeeper service name is empty but register_self is true");
        }
        if (config.zookeeper.weight <= 0) {
            throw std::runtime_error("Invalid ZooKeeper service weight: " + 
                std::to_string(config.zookeeper.weight));
        }
    }
}

Config Config::LoadFromFile(const std::string& path) {
    Config config;
    try {
        YAML::Node yaml = YAML::LoadFile(path);

        // Server
        if (yaml["server"]) {
            const auto& s = yaml["server"];
            if (s["host"]) config.server.host = s["host"].as<std::string>();
            if (s["grpc_port"]) config.server.grpc_port = s["grpc_port"].as<int>();
            if (s["metrics_port"]) config.server.metrics_port = s["metrics_port"].as<int>();
        }

        // MySQL
        if (yaml["mysql"]) {
            const auto& m = yaml["mysql"];
            if (m["host"]) config.mysql.host = m["host"].as<std::string>();
            if (m["port"]) config.mysql.port = m["port"].as<int>();
            if (m["database"]) config.mysql.database = m["database"].as<std::string>();
            if (m["username"]) config.mysql.username = m["username"].as<std::string>();
            if (m["password"]) config.mysql.password = m["password"].as<std::string>();
            if (m["pool_size"]) config.mysql.pool_size = m["pool_size"].as<int>();
            if (m["connection_timeout_ms"]) config.mysql.connection_timeout_ms = m["connection_timeout_ms"].as<unsigned int>();
            if (m["read_timeout_ms"]) config.mysql.read_timeout_ms = m["read_timeout_ms"].as<unsigned int>();
            if (m["write_timeout_ms"]) config.mysql.write_timeout_ms = m["write_timeout_ms"].as<unsigned int>();
            if (m["max_retries"]) config.mysql.max_retries = m["max_retries"].as<unsigned int>();
            if (m["retry_interval_ms"]) config.mysql.retry_interval_ms = m["retry_interval_ms"].as<unsigned int>();
            if (m["auto_reconnect"]) config.mysql.auto_reconnect = m["auto_reconnect"].as<bool>();
            if (m["charset"]) config.mysql.charset = m["charset"].as<std::string>();
        }

        // Redis
        if (yaml["redis"]) {
            const auto& r = yaml["redis"];
            if (r["host"]) config.redis.host = r["host"].as<std::string>();
            if (r["port"]) config.redis.port = r["port"].as<int>();
            if (r["password"]) config.redis.password = r["password"].as<std::string>();
            if (r["db"]) config.redis.db = r["db"].as<int>();
            if (r["pool_size"]) config.redis.pool_size = r["pool_size"].as<int>();
            if (r["wait_timeout_ms"]) config.redis.wait_timeout_ms = r["wait_timeout_ms"].as<unsigned int>();
            if (r["connect_timeout_ms"]) config.redis.connect_timeout_ms = r["connect_timeout_ms"].as<unsigned int>();
            if (r["socket_timeout_ms"]) config.redis.socket_timeout_ms = r["socket_timeout_ms"].as<unsigned int>();
        }

        // ============ ZooKeeper 配置 ============
        if (yaml["zookeeper"]) {
            const auto& zk = yaml["zookeeper"];
            if (zk["hosts"]) 
                config.zookeeper.hosts = zk["hosts"].as<std::string>();
            if (zk["session_timeout_ms"]) 
                config.zookeeper.session_timeout_ms = zk["session_timeout_ms"].as<int>();
            if (zk["connect_timeout_ms"]) 
                config.zookeeper.connect_timeout_ms = zk["connect_timeout_ms"].as<int>();
            if (zk["root_path"]) 
                config.zookeeper.root_path = zk["root_path"].as<std::string>();
            if (zk["service_name"]) 
                config.zookeeper.service_name = zk["service_name"].as<std::string>();
            if (zk["enabled"]) 
                config.zookeeper.enabled = zk["enabled"].as<bool>();
            if (zk["register_self"]) 
                config.zookeeper.register_self = zk["register_self"].as<bool>();
            if (zk["weight"]) 
                config.zookeeper.weight = zk["weight"].as<int>();
            if (zk["region"]) 
                config.zookeeper.region = zk["region"].as<std::string>();
            if (zk["zone"]) 
                config.zookeeper.zone = zk["zone"].as<std::string>();
            if (zk["version"]) 
                config.zookeeper.version = zk["version"].as<std::string>();
        }

        // ============ Security（已更新） ============
        if (yaml["security"]) {
            const auto& s = yaml["security"];
            if (s["jwt_secret"]) 
                config.security.jwt_secret = s["jwt_secret"].as<std::string>();
            if (s["jwt_issuer"]) 
                config.security.jwt_issuer = s["jwt_issuer"].as<std::string>();
            if (s["access_token_ttl_seconds"]) 
                config.security.access_token_ttl_seconds = s["access_token_ttl_seconds"].as<int>();
            if (s["refresh_token_ttl_seconds"]) 
                config.security.refresh_token_ttl_seconds = s["refresh_token_ttl_seconds"].as<int>();
        }

        // ============ SMS 验证码配置 ============
        if (yaml["sms"]) {
            const auto& s = yaml["sms"];
            if (s["code_len"]) 
                config.sms.code_len = s["code_len"].as<int>();
            if (s["code_ttl_seconds"]) 
                config.sms.code_ttl_seconds = s["code_ttl_seconds"].as<int>();
            if (s["send_interval_seconds"]) 
                config.sms.send_interval_seconds = s["send_interval_seconds"].as<int>();
            if (s["max_retry_count"]) 
                config.sms.max_retry_count = s["max_retry_count"].as<int>();
            if (s["retry_ttl_seconds"]) 
                config.sms.retry_ttl_seconds = s["retry_ttl_seconds"].as<int>();
            if (s["lock_seconds"]) 
                config.sms.lock_seconds = s["lock_seconds"].as<int>();
        }

        // ============ Login 登录安全配置 ============
        if (yaml["login"]) {
            const auto& l = yaml["login"];
            if (l["max_failed_attempts"]) 
                config.login.max_failed_attempts = l["max_failed_attempts"].as<int>();
            if (l["failed_attempts_window"]) 
                config.login.failed_attempts_window = l["failed_attempts_window"].as<int>();
            if (l["lock_duration_seconds"]) 
                config.login.lock_duration_seconds = l["lock_duration_seconds"].as<int>();
            if (l["max_sessions_per_user"]) 
                config.login.max_sessions_per_user = l["max_sessions_per_user"].as<int>();
            if (l["kick_oldest_session"]) 
                config.login.kick_oldest_session = l["kick_oldest_session"].as<bool>();
            if (l["enable_password_login"]) 
                config.login.enable_password_login = l["enable_password_login"].as<bool>();
            if (l["enable_sms_login"]) 
                config.login.enable_sms_login = l["enable_sms_login"].as<bool>();
            if (l["require_captcha"]) 
                config.login.require_captcha = l["require_captcha"].as<bool>();
            if (l["captcha_after_failed_attempts"]) 
                config.login.captcha_after_failed_attempts = l["captcha_after_failed_attempts"].as<int>();
        }

        // ============ Password 密码策略配置 ============
        if (yaml["password"]) {
            const auto& p = yaml["password"];
            if (p["min_length"]) 
                config.password.min_length = p["min_length"].as<int>();
            if (p["max_length"]) 
                config.password.max_length = p["max_length"].as<int>();
            if (p["require_uppercase"]) 
                config.password.require_uppercase = p["require_uppercase"].as<bool>();
            if (p["require_lowercase"]) 
                config.password.require_lowercase = p["require_lowercase"].as<bool>();
            if (p["require_digit"]) 
                config.password.require_digit = p["require_digit"].as<bool>();
            if (p["require_special_char"]) 
                config.password.require_special_char = p["require_special_char"].as<bool>();
            if (p["expire_days"]) 
                config.password.expire_days = p["expire_days"].as<int>();
            if (p["history_count"]) 
                config.password.history_count = p["history_count"].as<int>();
        }

        // Log
        if (yaml["log"]) {
            const auto& l = yaml["log"];
            if (l["level"]) config.log.level = l["level"].as<std::string>();
            if (l["path"]) config.log.path = l["path"].as<std::string>();
            if (l["filename"]) config.log.filename = l["filename"].as<std::string>();
            if (l["max_size"]) config.log.max_size = l["max_size"].as<size_t>();
            if (l["max_files"]) config.log.max_files = l["max_files"].as<int>();
            if (l["console_output"]) config.log.console_output = l["console_output"].as<bool>();
        }
    } catch (const YAML::Exception& e) {
        throw std::runtime_error("Failed to load config: " + std::string(e.what()));
    }

    ValidateConfig(config);
    return config;
}

void Config::LoadFromEnv() {
    // MySQL
    if (const char* env = std::getenv("MYSQL_HOST")) mysql.host = env;
    if (const char* env = std::getenv("MYSQL_PASSWORD")) mysql.password = env;
    
    // Redis
    if (const char* env = std::getenv("REDIS_HOST")) redis.host = env;
    
    // ZooKeeper
    if (const char* env = std::getenv("ZK_HOSTS")) zookeeper.hosts = env;
    if (const char* env = std::getenv("ZK_SESSION_TIMEOUT")) {
        zookeeper.session_timeout_ms = std::atoi(env);
    }
    if (const char* env = std::getenv("ZK_CONNECT_TIMEOUT")) {
        zookeeper.connect_timeout_ms = std::atoi(env);
    }
    if (const char* env = std::getenv("ZK_ROOT_PATH")) zookeeper.root_path = env;
    if (const char* env = std::getenv("ZK_SERVICE_NAME")) zookeeper.service_name = env;
    if (const char* env = std::getenv("ZK_ENABLED")) {
        zookeeper.enabled = (std::string(env) == "true" || std::string(env) == "1");
    }
    if (const char* env = std::getenv("ZK_REGISTER_SELF")) {
        zookeeper.register_self = (std::string(env) == "true" || std::string(env) == "1");
    }
    if (const char* env = std::getenv("ZK_WEIGHT")) {
        zookeeper.weight = std::atoi(env);
    }
    if (const char* env = std::getenv("ZK_REGION")) zookeeper.region = env;
    if (const char* env = std::getenv("ZK_ZONE")) zookeeper.zone = env;
    if (const char* env = std::getenv("ZK_VERSION")) zookeeper.version = env;
    
    // Security
    if (const char* env = std::getenv("JWT_SECRET")) security.jwt_secret = env;
    if (const char* env = std::getenv("JWT_ISSUER")) security.jwt_issuer = env;
    if (const char* env = std::getenv("ACCESS_TOKEN_TTL")) {
        security.access_token_ttl_seconds = std::atoi(env);
    }
    if (const char* env = std::getenv("REFRESH_TOKEN_TTL")) {
        security.refresh_token_ttl_seconds = std::atoi(env);
    }

    // SMS 验证码配置
    if (const char* env = std::getenv("SMS_CODE_LEN")) {
        sms.code_len = std::atoi(env);
    }
    if (const char* env = std::getenv("SMS_CODE_TTL")) {
        sms.code_ttl_seconds = std::atoi(env);
    }
    if (const char* env = std::getenv("SMS_SEND_INTERVAL")) {
        sms.send_interval_seconds = std::atoi(env);
    }
    if (const char* env = std::getenv("SMS_MAX_RETRY")) {
        sms.max_retry_count = std::atoi(env);
    }
    if (const char* env = std::getenv("SMS_RETRY_TTL")) {
        sms.retry_ttl_seconds = std::atoi(env);
    }
    if (const char* env = std::getenv("SMS_LOCK_SECONDS")) {
        sms.lock_seconds = std::atoi(env);
    }

    // Login 登录安全配置（核心参数支持环境变量覆盖）
    if (const char* env = std::getenv("LOGIN_MAX_FAILED_ATTEMPTS")) {
        login.max_failed_attempts = std::atoi(env);
    }
    if (const char* env = std::getenv("LOGIN_LOCK_DURATION")) {
        login.lock_duration_seconds = std::atoi(env);
    }
    if (const char* env = std::getenv("LOGIN_MAX_SESSIONS")) {
        login.max_sessions_per_user = std::atoi(env);
    }

    // Password 密码策略配置（核心参数支持环境变量覆盖）
    if (const char* env = std::getenv("PASSWORD_MIN_LENGTH")) {
        password.min_length = std::atoi(env);
    }
    if (const char* env = std::getenv("PASSWORD_MAX_LENGTH")) {
        password.max_length = std::atoi(env);
    }
}

// ========================== ToString 实现 ==========================

std::string ServerConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Server Config ===" << std::endl;
    oss << "Host: " << host << std::endl;
    oss << "gRPC Port: " << grpc_port << std::endl;
    oss << "Metrics Port: " << metrics_port << std::endl;
    return oss.str();
}

std::string MySQLConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== MySQL Config ===" << std::endl;
    oss << "Host: " << host << std::endl;
    oss << "Port: " << port << std::endl;
    oss << "Database: " << database << std::endl;
    oss << "Username: " << username << std::endl;
    oss << "Password: " << (password.empty() ? "(empty)" : "******") << std::endl;
    oss << "Pool Size: " << pool_size << std::endl;
    oss << "Connection Timeout(ms): " 
        << (connection_timeout_ms ? std::to_string(*connection_timeout_ms) : "(not set)") << std::endl;
    oss << "Read Timeout(ms): " 
        << (read_timeout_ms ? std::to_string(*read_timeout_ms) : "(not set)") << std::endl;
    oss << "Write Timeout(ms): " 
        << (write_timeout_ms ? std::to_string(*write_timeout_ms) : "(not set)") << std::endl;
    oss << "Max Retries: " << max_retries << std::endl;
    oss << "Retry Interval(ms): " << retry_interval_ms << std::endl;
    oss << "Auto Reconnect: " 
        << (auto_reconnect ? (*auto_reconnect ? "true" : "false") : "(not set)") << std::endl;
    oss << "Charset: " << charset << std::endl;
    return oss.str();
}

std::string RedisConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Redis Config ===" << std::endl;
    oss << "Host: " << host << std::endl;
    oss << "Port: " << port << std::endl;
    oss << "Password: " << (password.empty() ? "(empty)" : "******") << std::endl;
    oss << "DB Index: " << db << std::endl;
    oss << "Pool Size: " << pool_size << std::endl;
    oss << "Wait Timeout(ms): " << wait_timeout_ms << std::endl;
    oss << "Connect Timeout(ms): " 
        << (connect_timeout_ms ? std::to_string(*connect_timeout_ms) : "(not set)") << std::endl;
    oss << "Socket Timeout(ms): " 
        << (socket_timeout_ms ? std::to_string(*socket_timeout_ms) : "(not set)") << std::endl;
    return oss.str();
}

// ============ ZooKeeperConfig::ToString ============
std::string ZooKeeperConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== ZooKeeper Config ===" << std::endl;
    oss << "Enabled: " << (enabled ? "Yes" : "No") << std::endl;
    oss << "Hosts: " << hosts << std::endl;
    oss << "Session Timeout: " << session_timeout_ms << " ms" << std::endl;
    oss << "Connect Timeout: " << connect_timeout_ms << " ms" << std::endl;
    oss << "Root Path: " << root_path << std::endl;
    oss << "Service Name: " << service_name << std::endl;
    oss << "Register Self: " << (register_self ? "Yes" : "No") << std::endl;
    oss << "Weight: " << weight << std::endl;
    oss << "Region: " << (region.empty() ? "(not set)" : region) << std::endl;
    oss << "Zone: " << (zone.empty() ? "(not set)" : zone) << std::endl;
    oss << "Version: " << version << std::endl;
    return oss.str();
}

// ============ SecurityConfig::ToString ============
std::string SecurityConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Security Config ===" << std::endl;
    oss << "JWT Secret: " << (jwt_secret.empty() ? "(empty)" : "******") << std::endl;
    oss << "JWT Issuer: " << jwt_issuer << std::endl;
    oss << "Access Token TTL: " << access_token_ttl_seconds << " seconds ("
        << access_token_ttl_seconds / 60 << " minutes)" << std::endl;
    oss << "Refresh Token TTL: " << refresh_token_ttl_seconds << " seconds ("
        << refresh_token_ttl_seconds / 86400 << " days)" << std::endl;
    return oss.str();
}

// ============ SmsConfig::ToString ============
std::string SmsConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== SMS Config ===" << std::endl;
    oss << "Code Length: " << code_len << std::endl;
    oss << "Code TTL: " << code_ttl_seconds << " seconds ("
        << code_ttl_seconds / 60 << " minutes)" << std::endl;
    oss << "Send Interval: " << send_interval_seconds << " seconds" << std::endl;
    oss << "Max Retry Count: " << max_retry_count << std::endl;
    oss << "Retry TTL: " << retry_ttl_seconds << " seconds ("
        << retry_ttl_seconds / 60 << " minutes)" << std::endl;
    oss << "Lock Duration: " << lock_seconds << " seconds ("
        << lock_seconds / 60 << " minutes)" << std::endl;
    return oss.str();
}

// ============ LoginConfig::ToString ============
std::string LoginConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Login Config ===" << std::endl;
    oss << "Max Failed Attempts: " << max_failed_attempts << std::endl;
    oss << "Failed Attempts Window: " << failed_attempts_window << " seconds ("
        << failed_attempts_window / 60 << " minutes)" << std::endl;
    oss << "Lock Duration: " << lock_duration_seconds << " seconds ("
        << lock_duration_seconds / 60 << " minutes)" << std::endl;
    oss << "Max Sessions Per User: " << max_sessions_per_user << std::endl;
    oss << "Kick Oldest Session: " << (kick_oldest_session ? "Yes" : "No") << std::endl;
    oss << "Enable Password Login: " << (enable_password_login ? "Yes" : "No") << std::endl;
    oss << "Enable SMS Login: " << (enable_sms_login ? "Yes" : "No") << std::endl;
    oss << "Require Captcha: " << (require_captcha ? "Yes" : "No") << std::endl;
    oss << "Captcha After Failed: " << captcha_after_failed_attempts << " attempts" << std::endl;
    return oss.str();
}

// ============ PasswordPolicyConfig::ToString ============
std::string PasswordPolicyConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Password Policy ===" << std::endl;
    oss << "Length: " << min_length << " - " << max_length << " chars" << std::endl;
    oss << "Require Uppercase: " << (require_uppercase ? "Yes" : "No") << std::endl;
    oss << "Require Lowercase: " << (require_lowercase ? "Yes" : "No") << std::endl;
    oss << "Require Digit: " << (require_digit ? "Yes" : "No") << std::endl;
    oss << "Require Special Char: " << (require_special_char ? "Yes" : "No") << std::endl;
    oss << "Expire Days: " << (expire_days > 0 ? std::to_string(expire_days) + " days" : "Never") << std::endl;
    oss << "History Count: " << (history_count > 0 ? std::to_string(history_count) : "Not checked") << std::endl;
    return oss.str();
}

std::string LogConfig::ToString() const {
    std::ostringstream oss;
    oss << "=== Log Config ===" << std::endl;
    oss << "Level: " << level << std::endl;
    oss << "Path: " << path << std::endl;
    oss << "Filename: " << filename << std::endl;
    oss << "Max Size: " << max_size / 1024 / 1024 << " MB (" << max_size << " bytes)" << std::endl;
    oss << "Max Files: " << max_files << std::endl;
    oss << "Console Output: " << (console_output ? "Enabled" : "Disabled") << std::endl;
    return oss.str();
}

std::string Config::ToString() const {
    std::ostringstream oss;
    oss << "==================== User Service Config ====================" << std::endl;
    oss << server.ToString() << std::endl;
    oss << mysql.ToString() << std::endl;
    oss << redis.ToString() << std::endl;
    oss << zookeeper.ToString() << std::endl;
    oss << security.ToString() << std::endl;
    oss << sms.ToString() << std::endl;
    oss << login.ToString() << std::endl;
    oss << password.ToString() << std::endl;
    oss << log.ToString();
    oss << "==============================================================" << std::endl;
    return oss.str();
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/config/CMakeLists.txt ======================

add_library(user_config STATIC config.cpp)

target_include_directories(user_config PUBLIC 
    ${CMAKE_SOURCE_DIR}/include
)

target_link_libraries(user_config PUBLIC
    yaml-cpp::yaml-cpp
    user_common
)

-----------------------------------------------------


// ====================== ./src/server/auth_main.cpp ======================

// src/server/auth_main.cpp
#include "server/server_builder.h"
#include "common/logger.h"
#include <csignal>

user_service::GrpcServer* g_server = nullptr;

void SignalHandler(int signal) {
    if (g_server) {
        g_server->Shutdown();
    }
}

int main(int argc, char* argv[]) {
    const char* config_path = std::getenv("CONFIG_PATH");
    if (!config_path) {
        config_path = "../../configs/config.yaml";
    }

    try {
        // 先加载配置
        auto config = user_service::Config::LoadFromFile(config_path);
        
        // 立即初始化 Logger
        user_service::Logger::Init(
            config.log.path,
            config.log.filename,
            config.log.level,
            config.log.max_size,
            config.log.max_files,
            config.log.console_output
        );


        auto server = user_service::ServerBuilder()
            .WithConfig(std::make_shared<user_service::Config>(config))
            .LoadFromEnvironment()
            .WithServiceName("auth-service")
            .WithPort(50052)  // 使用 50052 端口
            .Build();
        
        g_server = server.get();
        
        std::signal(SIGINT, SignalHandler);
        std::signal(SIGTERM, SignalHandler);
        
        if (!server->Initialize()) {
            std::cerr << "Failed to initialize server" << std::endl;
            return 1;
        }
        
        server->Run();
        
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}


-----------------------------------------------------


// ====================== ./src/server/CMakeLists.txt ======================

# src/server/CMakeLists.txt

add_library(user_server_lib
    grpc_server.cpp
    server_builder.cpp
)

target_include_directories(user_server_lib PUBLIC
    ${PROJECT_SOURCE_DIR}/include
    ${PROJECT_SOURCE_DIR}/thirdparty
    ${GRPC_INCLUDE_DIRS}
)

target_link_libraries(user_server_lib PUBLIC
    proto_lib
    user_handler
    user_service
    user_auth
    user_db
    user_cache
    user_common
    user_config
    user_discovery
    ${GRPC_LIBRARIES}
)

add_dependencies(user_server_lib proto_lib)

# User Service 可执行文件
add_executable(user_server user_main.cpp)
target_link_libraries(user_server PRIVATE user_server_lib)

# Auth Service 可执行文件
add_executable(auth_server auth_main.cpp)
target_link_libraries(auth_server PRIVATE user_server_lib)


-----------------------------------------------------


// ====================== ./src/server/grpc_server.cpp ======================

#include "server/grpc_server.h"
#include "common/logger.h"
#include "auth/jwt_authenticator.h"
#include "auth/token_cleanup_task.h"
#include "pool/connection_pool.h"

#include <csignal>
#include <iostream>

namespace user_service {

// ============================================================================
// 构造与析构
// ============================================================================

GrpcServer::GrpcServer(std::shared_ptr<Config> config)
    : config_(std::move(config)) {
    if (!config_) {
        throw std::invalid_argument("Config cannot be null");
    }
}

GrpcServer::~GrpcServer() {
    Shutdown();
}

// ============================================================================
// 初始化
// ============================================================================

bool GrpcServer::Initialize() {
    if (!Logger::IsInitialized()) {
        Logger::Init(
            config_->log.path,
            config_->log.filename,
            config_->log.level,
            config_->log.max_size,
            config_->log.max_files,
            config_->log.console_output
        );
        LOG_INFO("Logger initialized by GrpcServer (fallback)");
    }

    LOG_INFO("Initializing gRPC server...");

    try {
        if (!InitInfrastructure()) {
            LOG_ERROR("Failed to initialize infrastructure");
            return false;
        }

        if (!InitRepositories()) {
            LOG_ERROR("Failed to initialize repositories");
            return false;
        }

        if (!InitServices()) {
            LOG_ERROR("Failed to initialize services");
            return false;
        }

        if (!InitHandlers()) {
            LOG_ERROR("Failed to initialize handlers");
            return false;
        }

        if (config_->zookeeper.enabled) {
            if (!InitServiceDiscovery()) {
                LOG_WARN("Failed to initialize service discovery, continuing without it");
            }
        }

        LOG_INFO("gRPC server initialized successfully");
        return true;

    } catch (const std::exception& e) {
        LOG_ERROR("Initialization failed: {}", e.what());
        return false;
    }
}

bool GrpcServer::InitInfrastructure() {
    LOG_INFO("Initializing infrastructure...");

    // MySQL 连接池
    LOG_INFO("Creating MySQL connection pool: {}:{}", 
             config_->mysql.host, config_->mysql.port);
    
    mysql_pool_ = std::make_shared<MySQLPool>(
        config_,
        [](const MySQLConfig& cfg) {
            return std::make_unique<MySQLConnection>(cfg);
        }
    );

    // Redis 客户端
    LOG_INFO("Connecting to Redis: {}:{}", 
             config_->redis.host, config_->redis.port);
    
    redis_client_ = std::make_shared<RedisClient>(config_->redis);

    // 验证连接
    auto ping_result = redis_client_->Ping();
    if (!ping_result.IsOk()) {
        LOG_ERROR("Redis ping failed: {}", ping_result.message);
        return false;
    }

    LOG_INFO("Infrastructure initialized");
    return true;
}

bool GrpcServer::InitRepositories() {
    LOG_INFO("Initializing repositories...");

    user_db_ = std::make_shared<UserDB>(mysql_pool_);
    token_repo_ = std::make_shared<TokenRepository>(mysql_pool_);

    LOG_INFO("Repositories initialized");
    return true;
}

bool GrpcServer::InitServices() {
    LOG_INFO("Initializing services...");

    // 基础服务
    jwt_service_ = std::make_shared<JwtService>(config_->security);
    sms_service_ = std::make_shared<SmsService>(redis_client_, config_->sms);

    // 业务服务
    auth_service_ = std::make_shared<AuthService>(
        config_,
        user_db_,
        redis_client_,
        token_repo_,
        jwt_service_,
        sms_service_
    );

    user_service_ = std::make_shared<UserService>(
        config_,
        user_db_,
        token_repo_,
        sms_service_
    );

    // Token 清理任务
    token_cleanup_task_ = std::make_shared<TokenCleanupTask>(token_repo_, 60);
    token_cleanup_task_->Start();

    LOG_INFO("Services initialized");
    return true;
}

bool GrpcServer::InitHandlers() {
    LOG_INFO("Initializing handlers...");

    authenticator_ = std::make_shared<JwtAuthenticator>(jwt_service_);
    auth_handler_ = std::make_unique<AuthHandler>(auth_service_);
    user_handler_ = std::make_unique<UserHandler>(user_service_, authenticator_);

    LOG_INFO("Handlers initialized");
    return true;
}

bool GrpcServer::InitServiceDiscovery() {
    LOG_INFO("Initializing service discovery...");

    try {
        zk_client_ = std::make_shared<ZooKeeperClient>(
            config_->zookeeper.hosts,
            config_->zookeeper.session_timeout_ms
        );

        if (!zk_client_->Connect(config_->zookeeper.connect_timeout_ms)) {
            LOG_ERROR("Failed to connect to ZooKeeper");
            return false;
        }

        service_registry_ = std::make_shared<ServiceRegistry>(
            zk_client_,
            config_->zookeeper.root_path
        );

        LOG_INFO("Service discovery initialized");
        return true;

    } catch (const std::exception& e) {
        LOG_ERROR("Service discovery initialization failed: {}", e.what());
        return false;
    }
}

// ============================================================================
// 运行
// ============================================================================

void GrpcServer::Run() {
    if (!Start()) {
        LOG_ERROR("Failed to start server");
        return;
    }
    Wait();
}

bool GrpcServer::Start() {
    if (running_.load()) {
        LOG_WARN("Server is already running");
        return true;
    }

    std::string address = config_->server.host + ":" + 
                          std::to_string(config_->server.grpc_port);

    grpc::ServerBuilder builder;
    builder.AddListeningPort(address, grpc::InsecureServerCredentials());
    builder.RegisterService(auth_handler_.get());
    builder.RegisterService(user_handler_.get());

    // 启用健康检查
    grpc::EnableDefaultHealthCheckService(true);

    // 构建并启动服务器
    server_ = builder.BuildAndStart();

    if (!server_) {
        LOG_ERROR("Failed to start gRPC server on {}", address);
        return false;
    }

    running_.store(true);
    shutdown_requested_.store(false);

    // 注册到 ZooKeeper
    if (config_->zookeeper.enabled && config_->zookeeper.register_self) {
        RegisterToZooKeeper();
    }

    // 启动关闭监控线程
    shutdown_monitor_thread_ = std::thread([this]() {
        ShutdownMonitor();
    });

    LOG_INFO("========================================");
    LOG_INFO("gRPC Server started on {}", address);
    LOG_INFO("========================================");

    return true;
}

void GrpcServer::Wait() {
    if (server_) {
        server_->Wait();
    }

    if (shutdown_monitor_thread_.joinable()) {
        shutdown_monitor_thread_.join();
    }

    running_.store(false);
    LOG_INFO("Server stopped");
}

void GrpcServer::Shutdown(std::chrono::milliseconds deadline) {
    if (!running_.load()) {
        return;
    }

    LOG_INFO("Shutting down server...");
    shutdown_requested_.store(true);

    // 从 ZooKeeper 注销
    UnregisterFromZooKeeper();

    // 停止 Token 清理任务
    if (token_cleanup_task_) {
        token_cleanup_task_->Stop();
    }

    // 关闭 gRPC 服务器
    if (server_) {
        auto deadline_time = std::chrono::system_clock::now() + deadline;
        server_->Shutdown(deadline_time);
    }

    // 触发回调
    if (shutdown_callback_) {
        shutdown_callback_();
    }
}

std::string GrpcServer::GetAddress() const {
    return config_->server.host + ":" + std::to_string(config_->server.grpc_port);
}

// ============================================================================
// ZooKeeper
// ============================================================================

bool GrpcServer::RegisterToZooKeeper() {
    if (!service_registry_) {
        return false;
    }

    ServiceInstance instance;
    instance.service_name = config_->zookeeper.service_name;
    instance.host = config_->server.host;
    instance.port = config_->server.grpc_port;
    instance.weight = config_->zookeeper.weight;
    instance.metadata["version"] = config_->zookeeper.version;
    instance.metadata["region"] = config_->zookeeper.region;
    instance.metadata["zone"] = config_->zookeeper.zone;

    if (service_registry_->Register(instance)) {
        LOG_INFO("Registered to ZooKeeper: {}", instance.GetAddress());
        return true;
    }

    LOG_ERROR("Failed to register to ZooKeeper");
    return false;
}

void GrpcServer::UnregisterFromZooKeeper() {
    if (service_registry_ && service_registry_->IsRegistered()) {
        service_registry_->Unregister();
        LOG_INFO("Unregistered from ZooKeeper");
    }
}

void GrpcServer::ShutdownMonitor() {
    while (!shutdown_requested_.load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    if (server_ && running_.load()) {
        auto deadline = std::chrono::system_clock::now() + std::chrono::seconds(5);
        server_->Shutdown(deadline);
    }
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/server/user_main.cpp ======================

// src/server/user_main.cpp
#include "server/server_builder.h"
#include "common/logger.h"
#include <csignal>

user_service::GrpcServer* g_server = nullptr;

void SignalHandler(int signal) {
    if (g_server) {
        g_server->Shutdown();
    }
}

int main(int argc, char* argv[]) {
    // 获取配置文件路径
    const char* config_path = std::getenv("CONFIG_PATH");
    if (!config_path) {
        config_path = "../../configs/config.yaml";
    }

    try {

        // 先加载配置
        auto config = user_service::Config::LoadFromFile(config_path);

        // 立即初始化 Logger
        user_service::Logger::Init(
            config.log.path,
            config.log.filename,
            config.log.level,
            config.log.max_size,
            config.log.max_files,
            config.log.console_output
        );

        // 构建服务器
        auto server = user_service::ServerBuilder()
            .WithConfig(std::make_shared<user_service::Config>(config))
            .LoadFromEnvironment()
            .WithServiceName("user-service")
            .WithPort(50051)
            .Build();
        
        g_server = server.get();
        
        // 注册信号处理
        std::signal(SIGINT, SignalHandler);
        std::signal(SIGTERM, SignalHandler);
        
        // 初始化并运行
        if (!server->Initialize()) {
            std::cerr << "Failed to initialize server" << std::endl;
            return 1;
        }
        
        server->Run();
        
    } catch (const std::exception& e) {
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}


-----------------------------------------------------


// ====================== ./src/server/server_builder.cpp ======================

#include "server/server_builder.h"
#include "common/logger.h"
#include <stdexcept>

namespace user_service {

ServerBuilder& ServerBuilder::WithConfigFile(const std::string& path) {
    try {
        config_ = std::make_shared<Config>(Config::LoadFromFile(path));
    } catch (const std::exception& e) {
        throw std::runtime_error("Failed to load config from " + path + ": " + e.what());
    }
    return *this;
}

ServerBuilder& ServerBuilder::WithConfig(std::shared_ptr<Config> config) {
    config_ = std::move(config);
    return *this;
}

ServerBuilder& ServerBuilder::WithPort(int port) {
    port_override_ = port;
    return *this;
}

ServerBuilder& ServerBuilder::WithHost(const std::string& host) {
    host_override_ = host;
    return *this;
}

ServerBuilder& ServerBuilder::EnableServiceDiscovery(bool enable) {
    service_discovery_override_ = enable;
    return *this;
}

ServerBuilder& ServerBuilder::WithServiceName(const std::string& name) {
    service_name_override_ = name;
    return *this;
}

ServerBuilder& ServerBuilder::OnShutdown(GrpcServer::ShutdownCallback callback) {
    shutdown_callback_ = std::move(callback);
    return *this;
}

ServerBuilder& ServerBuilder::LoadFromEnvironment() {
    load_env_ = true;
    return *this;
}

std::unique_ptr<GrpcServer> ServerBuilder::Build() {
    if (!config_) {
        throw std::runtime_error("Config is required. Call WithConfigFile() or WithConfig()");
    }

    // 从环境变量加载
    if (load_env_) {
        config_->LoadFromEnv();
    }

    // 应用覆盖值
    if (port_override_.has_value()) {
        config_->server.grpc_port = port_override_.value();
    }

    if (host_override_.has_value()) {
        config_->server.host = host_override_.value();
    }

    if (service_discovery_override_.has_value()) {
        config_->zookeeper.enabled = service_discovery_override_.value();
    }

    if (service_name_override_.has_value()) {
        config_->zookeeper.service_name = service_name_override_.value();
    }

    // 创建服务器
    auto server = std::make_unique<GrpcServer>(config_);

    if (shutdown_callback_) {
        server->SetShutdownCallback(std::move(shutdown_callback_));
    }

    return server;
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/client/user_client.cpp ======================

#include "client/user_client.h"
#include "common/proto_converter.h"
#include "common/logger.h"

namespace user_service {

// ============================================================================
// 构造函数
// ============================================================================

UserClient::UserClient(const std::string& target)
    : channel_(grpc::CreateChannel(target, grpc::InsecureChannelCredentials()))
    , stub_(pb_user::UserService::NewStub(channel_)) {
}

UserClient::UserClient(const ClientOptions& options)
    : channel_(grpc::CreateCustomChannel(
          options.target,
          options.CreateCredentials(),
          options.CreateChannelArgs()))
    , stub_(pb_user::UserService::NewStub(channel_))
    , timeout_(options.timeout)
    , access_token_(options.access_token) {
}

UserClient::UserClient(std::shared_ptr<grpc::Channel> channel)
    : channel_(std::move(channel))
    , stub_(pb_user::UserService::NewStub(channel_)) {
}

// ============================================================================
// 辅助方法
// ============================================================================

std::unique_ptr<grpc::ClientContext> UserClient::CreateContext() const {
    auto context = std::make_unique<grpc::ClientContext>();
    context->set_deadline(std::chrono::system_clock::now() + timeout_);
    
    // 添加认证信息
    if (!access_token_.empty()) {
        context->AddMetadata("authorization", "Bearer " + access_token_);
    }
    
    return context;
}

// ============================================================================
// 当前用户操作
// ============================================================================

Result<UserEntity> UserClient::GetCurrentUser() {
    pb_user::GetCurrentUserRequest request;
    pb_user::GetCurrentUserResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->GetCurrentUser(context.get(), request, &response);

    if (!status.ok()) {
        return Result<UserEntity>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<UserEntity>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<UserEntity>::Ok(FromProtoUser(response.user()));
}

Result<UserEntity> UserClient::UpdateUser(std::optional<std::string> display_name) {
    pb_user::UpdateUserRequest request;
    
    if (display_name.has_value()) {
        request.mutable_display_name()->set_value(display_name.value());
    }

    pb_user::UpdateUserResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->UpdateUser(context.get(), request, &response);

    if (!status.ok()) {
        return Result<UserEntity>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<UserEntity>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<UserEntity>::Ok(FromProtoUser(response.user()));
}

Result<void> UserClient::ChangePassword(
    const std::string& old_password,
    const std::string& new_password) {
    
    pb_user::ChangePasswordRequest request;
    request.set_old_password(old_password);
    request.set_new_password(new_password);

    pb_user::ChangePasswordResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->ChangePassword(context.get(), request, &response);

    if (!status.ok()) {
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<void>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<void>::Ok();
}

Result<void> UserClient::DeleteUser(const std::string& verify_code) {
    pb_user::DeleteUserRequest request;
    request.set_verify_code(verify_code);

    pb_user::DeleteUserResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->DeleteUser(context.get(), request, &response);

    if (!status.ok()) {
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<void>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<void>::Ok();
}

// ============================================================================
// 管理员操作
// ============================================================================

Result<UserEntity> UserClient::GetUser(const std::string& user_id) {
    pb_user::GetUserRequest request;
    request.set_id(user_id);

    pb_user::GetUserResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->GetUser(context.get(), request, &response);

    if (!status.ok()) {
        return Result<UserEntity>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<UserEntity>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<UserEntity>::Ok(FromProtoUser(response.user()));
}

Result<std::pair<std::vector<UserEntity>, PageResult>> UserClient::ListUsers(
    std::optional<std::string> mobile_filter,
    std::optional<bool> disabled_filter,
    int32_t page,
    int32_t page_size) {
    
    pb_user::ListUsersRequest request;
    
    auto* page_req = request.mutable_page();
    page_req->set_page(page);
    page_req->set_page_size(page_size);
    
    if (mobile_filter.has_value()) {
        request.set_mobile_filter(mobile_filter.value());
    }
    
    if (disabled_filter.has_value()) {
        request.mutable_disabled_filter()->set_value(disabled_filter.value());
    }

    pb_user::ListUsersResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->ListUsers(context.get(), request, &response);

    if (!status.ok()) {
        return Result<std::pair<std::vector<UserEntity>, PageResult>>::Fail(
            ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<std::pair<std::vector<UserEntity>, PageResult>>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    // 转换用户列表
    std::vector<UserEntity> users;
    users.reserve(response.users_size());
    for (const auto& proto_user : response.users()) {
        users.push_back(FromProtoUser(proto_user));
    }

    // 转换分页信息
    PageResult page_result;
    page_result.total_records = response.page_info().total_records();
    page_result.total_pages = response.page_info().total_pages();
    page_result.page = response.page_info().page();
    page_result.page_size = response.page_info().page_size();

    return Result<std::pair<std::vector<UserEntity>, PageResult>>::Ok(
        std::make_pair(std::move(users), page_result)
    );
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./src/client/CMakeLists.txt ======================

add_library(user_client_lib STATIC
    auth_client.cpp
    user_client.cpp
)

target_include_directories(user_client_lib PUBLIC
    ${PROJECT_SOURCE_DIR}/include
)

target_link_libraries(user_client_lib PUBLIC
    proto_lib
    user_common
    ${GRPC_LIBRARIES}
)

# 使用选项控制是否构建示例程序
option(BUILD_CLIENT_EXAMPLE "Build client example program" OFF)

if(BUILD_CLIENT_EXAMPLE)
    add_executable(client_example main.cpp)
    
    target_include_directories(client_example PRIVATE
        ${PROJECT_SOURCE_DIR}/include
    )
    
    target_link_libraries(client_example PRIVATE
        user_client_lib
        user_config
    )
endif()


-----------------------------------------------------


// ====================== ./src/client/auth_client.cpp ======================

// src/client/auth_client.cpp

#include "client/auth_client.h"
#include "common/proto_converter.h"
#include "common/logger.h"

namespace user_service {

// ============================================================================
// 构造函数
// ============================================================================

AuthClient::AuthClient(const std::string& target)
    : channel_(grpc::CreateChannel(target, grpc::InsecureChannelCredentials()))
    , stub_(pb_auth::AuthService::NewStub(channel_)) {
}

AuthClient::AuthClient(const ClientOptions& options)
    : channel_(grpc::CreateCustomChannel(
          options.target,
          options.CreateCredentials(),
          options.CreateChannelArgs()))
    , stub_(pb_auth::AuthService::NewStub(channel_))
    , timeout_(options.timeout) {
}

AuthClient::AuthClient(std::shared_ptr<grpc::Channel> channel)
    : channel_(std::move(channel))
    , stub_(pb_auth::AuthService::NewStub(channel_)) {
}

// ============================================================================
// 辅助方法
// ============================================================================

std::unique_ptr<grpc::ClientContext> AuthClient::CreateContext() const {
    auto context = std::make_unique<grpc::ClientContext>();
    context->set_deadline(std::chrono::system_clock::now() + timeout_);
    return context;
}

// ============================================================================
// 发送验证码
// ============================================================================

Result<int32_t> AuthClient::SendVerifyCode(const std::string& mobile, SmsScene scene) {
    pb_auth::SendVerifyCodeRequest request;
    request.set_mobile(mobile);
    request.set_scene(ToProtoSmsScene(scene));

    pb_auth::SendVerifyCodeResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->SendVerifyCode(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("SendVerifyCode RPC failed: {}", status.error_message());
        return Result<int32_t>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<int32_t>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<int32_t>::Ok(response.retry_after());
}

// ============================================================================
// 注册
// ============================================================================

Result<AuthResult> AuthClient::Register(
    const std::string& mobile,
    const std::string& verify_code,
    const std::string& password,
    const std::string& display_name) {
    
    pb_auth::RegisterRequest request;
    request.set_mobile(mobile);
    request.set_verify_code(verify_code);
    request.set_password(password);
    if (!display_name.empty()) {
        request.set_display_name(display_name);
    }

    pb_auth::RegisterResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->Register(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("Register RPC failed: {}", status.error_message());
        return Result<AuthResult>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<AuthResult>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    // 转换响应
    AuthResult result;
    result.user = FromProtoUserInfo(response.user());
    result.tokens = FromProtoTokenPair(response.tokens());

    return Result<AuthResult>::Ok(result);
}

// ============================================================================
// 密码登录
// ============================================================================

Result<AuthResult> AuthClient::LoginByPassword(
    const std::string& mobile,
    const std::string& password) {
    
    pb_auth::LoginByPasswordRequest request;
    request.set_mobile(mobile);
    request.set_password(password);

    pb_auth::LoginByPasswordResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->LoginByPassword(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("LoginByPassword RPC failed: {}", status.error_message());
        return Result<AuthResult>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<AuthResult>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    AuthResult result;
    result.user = FromProtoUserInfo(response.user());
    result.tokens = FromProtoTokenPair(response.tokens());

    return Result<AuthResult>::Ok(result);
}

// ============================================================================
// 验证码登录
// ============================================================================

Result<AuthResult> AuthClient::LoginByCode(
    const std::string& mobile,
    const std::string& verify_code) {
    
    pb_auth::LoginByCodeRequest request;
    request.set_mobile(mobile);
    request.set_verify_code(verify_code);

    pb_auth::LoginByCodeResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->LoginByCode(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("LoginByCode RPC failed: {}", status.error_message());
        return Result<AuthResult>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<AuthResult>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    AuthResult result;
    result.user = FromProtoUserInfo(response.user());
    result.tokens = FromProtoTokenPair(response.tokens());

    return Result<AuthResult>::Ok(result);
}

// ============================================================================
// 刷新 Token
// ============================================================================

Result<TokenPair> AuthClient::RefreshToken(const std::string& refresh_token) {
    pb_auth::RefreshTokenRequest request;
    request.set_refresh_token(refresh_token);

    pb_auth::RefreshTokenResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->RefreshToken(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("RefreshToken RPC failed: {}", status.error_message());
        return Result<TokenPair>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<TokenPair>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<TokenPair>::Ok(FromProtoTokenPair(response.tokens()));
}

// ============================================================================
// 登出
// ============================================================================

Result<void> AuthClient::Logout(const std::string& refresh_token) {
    pb_auth::LogoutRequest request;
    request.set_refresh_token(refresh_token);

    pb_auth::LogoutResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->Logout(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("Logout RPC failed: {}", status.error_message());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<void>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<void>::Ok();
}

// ============================================================================
// 重置密码
// ============================================================================

Result<void> AuthClient::ResetPassword(
    const std::string& mobile,
    const std::string& verify_code,
    const std::string& new_password) {
    
    pb_auth::ResetPasswordRequest request;
    request.set_mobile(mobile);
    request.set_verify_code(verify_code);
    request.set_new_password(new_password);

    pb_auth::ResetPasswordResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->ResetPassword(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("ResetPassword RPC failed: {}", status.error_message());
        return Result<void>::Fail(ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<void>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    return Result<void>::Ok();
}

// ============================================================================
// 验证 Token（内部服务用）
// ============================================================================

Result<TokenValidationResult> AuthClient::ValidateToken(const std::string& access_token) {
    pb_auth::ValidateTokenRequest request;
    request.set_access_token(access_token);

    pb_auth::ValidateTokenResponse response;
    auto context = CreateContext();

    grpc::Status status = stub_->ValidateToken(context.get(), request, &response);

    if (!status.ok()) {
        LOG_ERROR("ValidateToken RPC failed: {}", status.error_message());
        return Result<TokenValidationResult>::Fail(
            ErrorCode::ServiceUnavailable, status.error_message());
    }

    if (response.result().code() != pb_common::ErrorCode::OK) {
        return Result<TokenValidationResult>::Fail(
            FromProtoErrorCode(response.result().code()),
            response.result().msg()
        );
    }

    TokenValidationResult result;
    result.user_id = std::stoll(response.user_id());
    result.user_uuid = response.user_uuid();
    result.mobile = response.mobile();
    result.role = FromProtoUserRole(response.role());
    
    // 转换过期时间
    if (response.has_expires_at()) {
        result.expires_at = std::chrono::system_clock::from_time_t(
            response.expires_at().seconds());
    }

    return Result<TokenValidationResult>::Ok(result);
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./configs/config.docker.yaml ======================

# ==================== 服务器配置 ====================
server:
  host: "0.0.0.0"
  grpc_port: 50051
  metrics_port: 9090

# ==================== MySQL 配置 ====================
mysql:
  host: "mysql"                      # 容器名
  port: 3306
  database: "user_service"
  username: "root"
  password: "root123"
  pool_size: 10
  connection_timeout_ms: 5000
  read_timeout_ms: 30000
  write_timeout_ms: 30000
  max_retries: 3
  retry_interval_ms: 1000
  auto_reconnect: true
  charset: "utf8mb4"

# ==================== Redis 配置 ====================
redis:
  host: "redis"                      # 容器名
  port: 6379
  password: ""
  db: 0
  pool_size: 5
  connect_timeout_ms: 3000
  socket_timeout_ms: 3000
  wait_timeout_ms: 100

# ==================== ZooKeeper 配置 ====================
zookeeper:
  hosts: "zookeeper:2181"
  session_timeout_ms: 30000
  connect_timeout_ms: 10000
  root_path: "/services"
  service_name: "user-service"       # 会被环境变量覆盖
  enabled: true
  register_self: true
  weight: 100
  region: "docker"
  zone: "local"
  version: "1.0.0"

# ==================== 日志配置 ====================
log:
  level: "info"
  path: "/app/logs"
  filename: "app.log"
  max_size: 10485760                 # 10MB
  max_files: 5
  console_output: true

# ==================== 安全配置 ====================
security:
  jwt_secret: "your-super-secret-key-change-in-production-at-least-32-bytes!"
  jwt_issuer: "user-service"
  access_token_ttl_seconds: 900      # 15分钟
  refresh_token_ttl_seconds: 604800  # 7天

# ==================== 短信验证码配置 ====================
sms:
  code_len: 6
  code_ttl_seconds: 300
  send_interval_seconds: 60
  max_retry_count: 5
  retry_ttl_seconds: 300
  lock_seconds: 1800

# ==================== 登录安全配置 ====================
login:
  max_failed_attempts: 5
  failed_attempts_window: 900
  lock_duration_seconds: 1800
  max_sessions_per_user: 5
  kick_oldest_session: true
  enable_password_login: true
  enable_sms_login: true
  require_captcha: false
  captcha_after_failed_attempts: 3

# ==================== 密码策略配置 ====================
password:
  min_length: 8
  max_length: 32
  require_uppercase: false
  require_lowercase: false
  require_digit: true
  require_special_char: false
  expire_days: 0
  history_count: 0


-----------------------------------------------------


// ====================== ./configs/config.yaml ======================

# ============================================================================
# User Service 配置文件
# ============================================================================
# 环境：development / staging / production
# 敏感信息建议使用环境变量覆盖，如：
#   USER_SERVICE_MYSQL_PASSWORD=xxx
#   USER_SERVICE_JWT_SECRET=xxx
# ============================================================================

# ==================== 服务器配置 ====================
server:
  host: "0.0.0.0"
  grpc_port: 50051
  metrics_port: 9090
  
  # 服务名称（用于服务发现）
  service_name: "user-service"
  
  # gRPC 配置
  grpc:
    max_receive_message_size: 4194304    # 4MB
    max_send_message_size: 4194304       # 4MB
    keepalive_time_ms: 30000             # 30秒发送一次 keepalive
    keepalive_timeout_ms: 10000          # 10秒等待 keepalive 响应
    max_connection_idle_ms: 300000       # 空闲连接 5 分钟后关闭

# ==================== MySQL 配置 ====================
mysql:
  host: "localhost"
  port: 3307
  database: "user_service"
  username: "root"
  password: "@txylj2864"                    # 生产环境请用环境变量 USER_SERVICE_MYSQL_PASSWORD
  pool_size: 10
  
  # 超时配置（毫秒）
  connection_timeout_ms: 5000            # 连接超时 5 秒
  read_timeout_ms: 30000                 # 读超时 30 秒
  write_timeout_ms: 30000                # 写超时 30 秒
  
  # 重试配置
  max_retries: 3                         # 最大重试次数
  retry_interval_ms: 1000                # 重试间隔 1 秒
  
  # 连接池配置
  min_idle_connections: 2                # 最小空闲连接数
  max_idle_time_ms: 600000               # 空闲连接最大存活时间 10 分钟
  connection_lifetime_ms: 3600000        # 连接最大生命周期 1 小时
  
  # 其他配置
  auto_reconnect: true
  charset: "utf8mb4"
  collation: "utf8mb4_unicode_ci"
  
  # SSL 配置（生产环境推荐启用）
  ssl:
    enabled: false
    ca_cert: ""                          # CA 证书路径
    client_cert: ""                      # 客户端证书
    client_key: ""                       # 客户端私钥

# ==================== Redis 配置 ====================
redis:
  host: "localhost"
  port: 6380
  password: ""                           # 生产环境请用环境变量 USER_SERVICE_REDIS_PASSWORD
  db: 0
  pool_size: 5
  
  # 超时配置（毫秒）
  connect_timeout_ms: 3000               # 连接超时 3 秒
  socket_timeout_ms: 3000                # 读写超时 3 秒
  
  # 连接池配置
  wait_timeout_ms: 100                   # 等待可用连接超时
  max_idle_time_ms: 300000               # 空闲连接最大存活时间 5 分钟
  
  # 重试配置
  max_retries: 3
  retry_interval_ms: 100
  
  # 哨兵模式（可选，与单机模式二选一）
  sentinel:
    enabled: false
    master_name: "mymaster"
    nodes:
      - "localhost:26379"
      - "localhost:26380"
      - "localhost:26381"
  
  # 集群模式（可选）
  cluster:
    enabled: false
    nodes:
      - "localhost:7000"
      - "localhost:7001"
      - "localhost:7002"

# ==================== ZooKeeper 配置 ====================
zookeeper:
  # 连接配置
  hosts: "localhost:2181"                # 多个节点用逗号分隔，如 "10.0.0.1:2181,10.0.0.2:2181"
  session_timeout_ms: 30000              # 会话超时（毫秒），推荐 10000-30000
  connect_timeout_ms: 10000              # 连接超时（毫秒）
  
  # 服务注册
  root_path: "/services"                 # 服务根路径
  service_name: "user-service"           # 当前服务名称
  
  # 开关
  enabled: true                          # 是否启用 ZK
  register_self: true                    # 是否注册自身（服务端 true，纯客户端 false）
  
  # 元数据（负载均衡/路由用）
  weight: 100                            # 服务权重
  region: ""                             # 区域标识，如 "cn-east"
  zone: ""                               # 可用区，如 "zone-a"
  version: "1.0.0"                       # 服务版本

  

# ==================== 日志配置 ====================
log:
  level: "debug"                          # trace / debug / info / warn / error / critical
  path: "./logs"
  filename: "user-service.log"
  
  # 日志轮转
  max_size: 10485760                     # 单文件最大 10MB
  max_files: 5                           # 保留最近 5 个文件
  max_age_days: 30                       # 日志保留 30 天
  
  # 输出配置
  console_output: true                   # 是否输出到控制台
  json_format: false                     # 是否使用 JSON 格式（便于 ELK 采集）
  
  # 日志内容
  include_caller: true                   # 是否包含调用位置
  include_stacktrace_on_error: true      # error 级别是否包含堆栈

# ============================================================================
# 业务配置
# ============================================================================

# ==================== JWT/安全配置 ====================
security:
  # JWT 配置
  jwt_secret: "your-super-secret-key-change-in-production-at-least-32-bytes!"
  jwt_issuer: "user-service"
  jwt_audience: "user-service-clients"
  
  # Token 有效期
  access_token_ttl_seconds: 900          # Access Token 15 分钟
  refresh_token_ttl_seconds: 604800      # Refresh Token 7 天
  
  # Token 签名算法
  jwt_algorithm: "HS256"                 # HS256 / HS384 / HS512 / RS256
  
  # RSA 密钥（如果使用 RS256）
  rsa_private_key_path: ""
  rsa_public_key_path: ""

# ==================== 短信验证码配置 ====================
sms:
  # 验证码配置
  code_len: 6                            # 验证码长度
  code_ttl_seconds: 300                  # 有效期 5 分钟
  
  # 发送限制
  send_interval_seconds: 60              # 发送间隔 60 秒
  daily_limit_per_mobile: 10             # 单手机号每日限制
  daily_limit_per_ip: 50                 # 单 IP 每日限制
  
  # 验证限制（防暴力破解）
  max_retry_count: 5                     # 最大验证错误次数
  retry_ttl_seconds: 300                 # 错误次数统计窗口 5 分钟
  lock_seconds: 1800                     # 锁定时长 30 分钟
  
  # 短信服务商配置（按需启用）
  provider: "mock"                       # mock / aliyun / tencent
  aliyun:
    access_key_id: ""
    access_key_secret: ""
    sign_name: ""
    template_code: ""
  tencent:
    secret_id: ""
    secret_key: ""
    app_id: ""
    sign_name: ""
    template_id: ""

# ==================== 登录安全配置 ====================
login:
  # 登录失败锁定策略
  max_failed_attempts: 5                 # 最大失败次数
  failed_attempts_window: 900            # 失败计数窗口 15 分钟
  lock_duration_seconds: 1800            # 锁定时长 30 分钟
  
  # 会话管理
  max_sessions_per_user: 5               # 单用户最大同时登录设备数
  kick_oldest_session: true              # 超出时踢掉最旧会话
  
  # 登录方式开关
  enable_password_login: true            # 允许密码登录
  enable_sms_login: true                 # 允许验证码登录
  enable_oauth_login: false              # 允许第三方登录
  
  # 图形验证码
  require_captcha: false                 # 是否强制图形验证码
  captcha_after_failed_attempts: 3       # 失败 N 次后需要验证码
  
  # 安全增强
  require_2fa: false                     # 是否强制双因素认证
  remember_device_days: 30               # 记住设备天数

# ==================== 密码策略配置 ====================
password:
  # 长度要求
  min_length: 8
  max_length: 32
  
  # 复杂度要求
  require_uppercase: false               # 需要大写字母
  require_lowercase: false               # 需要小写字母
  require_digit: true                    # 需要数字
  require_special_char: false            # 需要特殊字符
  
  # 密码过期
  expire_days: 0                         # 0 = 不过期
  warn_days_before_expire: 7             # 过期前 N 天提醒
  
  # 历史密码检查
  history_count: 0                       # 0 = 不检查历史密码
  
  # 加密配置
  bcrypt_cost: 12                        # bcrypt cost factor（10-14）

# ==================== 限流配置 ====================
rate_limit:
  enabled: true
  
  # 全局限流
  global:
    requests_per_second: 1000
    burst_size: 2000
  
  # API 级别限流
  api:
    send_verify_code:
      requests_per_minute: 5             # 每分钟最多 5 次
      requests_per_hour: 20              # 每小时最多 20 次
    login:
      requests_per_minute: 10
      requests_per_hour: 100
    register:
      requests_per_minute: 5
      requests_per_hour: 20

# ==================== 健康检查配置 ====================
health:
  enabled: true
  
  # 检查间隔
  check_interval_seconds: 30
  
  # 检查项
  checks:
    mysql: true
    redis: true
    kafka: false                         # 如果不使用 Kafka 可以关闭
    zookeeper: false

# ==================== 监控配置 ====================
metrics:
  enabled: true
  
  # Prometheus 配置
  prometheus:
    enabled: true
    path: "/metrics"
  
  # 业务指标
  business:
    track_login_count: true
    track_register_count: true
    track_api_latency: true

# ==================== 环境覆盖说明 ====================
# 以下配置可通过环境变量覆盖（推荐用于敏感信息）：
#
# USER_SERVICE_MYSQL_HOST
# USER_SERVICE_MYSQL_PORT
# USER_SERVICE_MYSQL_DATABASE
# USER_SERVICE_MYSQL_USERNAME
# USER_SERVICE_MYSQL_PASSWORD
#
# USER_SERVICE_REDIS_HOST
# USER_SERVICE_REDIS_PORT
# USER_SERVICE_REDIS_PASSWORD
#
# USER_SERVICE_JWT_SECRET
# USER_SERVICE_JWT_ISSUER
#
# USER_SERVICE_KAFKA_BROKERS
#
# USER_SERVICE_LOG_LEVEL
# ============================================================================


-----------------------------------------------------


// ====================== ./include/entity/user_entity.h ======================

#pragma once
#include <string>

namespace user_service{

enum class UserRole{
    User = 0,           // 普通用户
    Admin = 1,          // 管理员
    SuperAdmin = 2      // 超级管理员
};


struct UserEntity {
    int64_t id = 0;
    std::string uuid;
    std::string mobile;
    std::string display_name;
    std::string password_hash;
    UserRole role = UserRole::User;
    bool disabled = false;
    std::string created_at;
    std::string updated_at;
};



inline std::string UserRoleToString(UserRole role){
    switch(role){
        case UserRole::User:        return "0";
        case UserRole::Admin:       return "1";
        case UserRole::SuperAdmin:  return "2";
        default:                    return "0";    
    }
}

inline UserRole StringToUserRole(std::string role){
    if(role=="0") return UserRole::User;
    if(role=="1") return UserRole::Admin;
    if(role=="2") return UserRole::SuperAdmin;
    return UserRole::User;
}



inline UserRole IntToUserRole(int role){
    return static_cast<UserRole>(role);
}

inline int UserRoleToInt(UserRole role){
    return static_cast<int>(role);
}

// 判断是否有管理员权限
inline bool IsAdmin(UserRole role) {
    return role == UserRole::Admin || role == UserRole::SuperAdmin;
}

inline bool IsSuperAdmin(UserRole role) {
    return role == UserRole::SuperAdmin;
}


    
}


-----------------------------------------------------


// ====================== ./include/entity/token.h ======================

#pragma once
#include <string>


namespace user_service{
// ==================== Token 会话实体 ====================
// 一个会话（Session） ≈ 一次登录 ≈ 一个设备/客户端。
struct TokenSession {
    int64_t id = 0;
    int64_t user_id = 0;
    std::string token_hash;
    std::string expires_at;     // MySQL DATETIME 格式
    std::string created_at;
};

}

-----------------------------------------------------


// ====================== ./include/entity/page.h ======================

#pragma once

namespace user_service{

// 分页查询参数
struct PageParams {
    int page = 1;           // 当前页
    int page_size = 20;     // 每页记录数

    // 计算 offset
    int Offset() const{
        return (page-1)*page_size;
    }

    // 参数校验 
    void Validate(){
        if(page<1) page=1;
        if(page_size<1) page_size=20;
        if(page_size>100) page_size=100; // 防止一次查太多,导致性能太差
    }
};

// 分页查询结果
struct PageResult {
    int total_records=0;  // 总记录数        
    int total_pages=0;    // 总页数
    int page=1;           // 当前页
    int page_size=20;      // 每页记录数量

    static PageResult Create(int page,int page_size,int total_records){
        PageResult res;
        res.page=page;
        res.page_size=page_size;
        res.total_records=total_records;
        res.total_pages=(total_records+page_size-1)/page_size; //上取整
        return res;
    }
};

}


-----------------------------------------------------


// ====================== ./include/common/validator.h ======================

#pragma once

#include <string>
#include <regex>
#include "config/config.h"  // 引入配置

namespace user_service {

/**
 * @brief 校验手机号格式（中国大陆）
 */
inline bool IsValidMobile(const std::string& mobile, std::string& error) {
    static const std::regex pattern(R"(1[3-9]\d{9})");
    if (mobile.length() != 11 || !std::regex_match(mobile, pattern)) {
        error = "手机号格式错误";
        return false;
    }
    return true;
}

/**
 * @brief 校验邮箱格式
 */
inline bool IsValidEmail(const std::string& email, std::string& error) {
    static const std::regex pattern(R"([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})");
    if (email.empty() || email.length() > 128 || !std::regex_match(email, pattern)) {
        error = "邮箱格式错误";
        return false;
    }
    return true;
}

/**
 * @brief 校验密码强度（默认版本：8-32位，必须包含字母+数字）
 */
inline bool IsValidPassword(const std::string& password, std::string& error) {
    if (password.length() < 8) {
        error = "密码长度至少8位";
        return false;
    }
    if (password.length() > 32) {
        error = "密码长度不能超过32位";
        return false;
    }
    
    bool has_digit = false;
    bool has_alpha = false;
    for (char c : password) {
        if (std::isdigit(c)) has_digit = true;
        if (std::isalpha(c)) has_alpha = true;
    }
    
    if (!has_digit || !has_alpha) {
        error = "密码必须包含字母和数字";
        return false;
    }
    
    return true;
}

/**
 * @brief 校验密码强度（配置版本：根据 PasswordPolicyConfig 校验）
 */
inline bool IsValidPassword(const std::string& password, 
                            std::string& error,
                            const PasswordPolicyConfig& policy) {
    // 长度检查
    if (static_cast<int>(password.length()) < policy.min_length) {
        error = "密码长度至少" + std::to_string(policy.min_length) + "位";
        return false;
    }
    if (static_cast<int>(password.length()) > policy.max_length) {
        error = "密码长度不能超过" + std::to_string(policy.max_length) + "位";
        return false;
    }
    
    // 复杂度检查
    bool has_uppercase = false;
    bool has_lowercase = false;
    bool has_digit = false;
    bool has_special = false;
    
    for (char c : password) {
        if (std::isupper(c)) has_uppercase = true;
        if (std::islower(c)) has_lowercase = true;
        if (std::isdigit(c)) has_digit = true;
        if (!std::isalnum(c)) has_special = true;
    }
    
    if (policy.require_uppercase && !has_uppercase) {
        error = "密码必须包含大写字母";
        return false;
    }
    if (policy.require_lowercase && !has_lowercase) {
        error = "密码必须包含小写字母";
        return false;
    }
    if (policy.require_digit && !has_digit) {
        error = "密码必须包含数字";
        return false;
    }
    if (policy.require_special_char && !has_special) {
        error = "密码必须包含特殊字符";
        return false;
    }
    
    return true;
}

/**
 * @brief 校验验证码格式（默认版本：6位数字）
 */
inline bool IsValidVerifyCode(const std::string& code, std::string& error) {
    if (code.length() != 6) {
        error = "验证码格式错误";
        return false;
    }
    for (char c : code) {
        if (!std::isdigit(c)) {
            error = "验证码格式错误";
            return false;
        }
    }
    return true;
}

/**
 * @brief 校验验证码格式（配置版本：根据 SmsConfig 校验）
 */
inline bool IsValidVerifyCode(const std::string& code, 
                              std::string& error,
                              const SmsConfig& config) {
    if (static_cast<int>(code.length()) != config.code_len) {
        error = "验证码应为" + std::to_string(config.code_len) + "位数字";
        return false;
    }
    for (char c : code) {
        if (!std::isdigit(c)) {
            error = "验证码应为" + std::to_string(config.code_len) + "位数字";
            return false;
        }
    }
    return true;
}

/**
 * @brief 校验昵称
 */
inline bool IsValidDisplayName(const std::string& name, std::string& error) {
    if (name.empty()) {
        error = "昵称不能为空";
        return false;
    }
    if (name.length() > 32) {
        error = "昵称长度不能超过32位";
        return false;
    }
    return true;
}

/**
 * @brief 校验用户ID（字符串形式）
 */
inline bool IsValidUserId(const std::string& user_id, std::string& error) {
    if (user_id.empty()) {
        error = "用户ID不能为空";
        return false;
    }
    for (char c : user_id) {
        if (!std::isdigit(c)) {
            error = "用户ID格式错误";
            return false;
        }
    }
    return true;
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/proto_utils.h ======================

#pragma once

#include <string>
#include <google/protobuf/timestamp.pb.h>

// Proto 生成的头文件
#include "common/result.pb.h"
#include "auth/auth.pb.h"
#include "user/user.pb.h"

// 业务代码
#include "common/error_codes.h"
#include "common/time_utils.h"
#include "entity/user_entity.h"

namespace user_service {

// ==================== ErrorCode 转换 ====================

/**
 * @brief C++ ErrorCode 转 Protobuf ErrorCode
 */
inline common::ErrorCode ToPbErrorCode(ErrorCode code) {
    return static_cast<common::ErrorCode>(static_cast<int>(code));
}

// ==================== Result 填充 ====================

/**
 * @brief 填充成功 Result
 */
inline void SetResultOk(common::Result* result, const std::string& msg = "操作成功") {
    result->set_code(common::ErrorCode::OK);
    result->set_msg(msg);
}

/**
 * @brief 填充失败 Result
 */
inline void SetResultFail(common::Result* result, ErrorCode code, const std::string& msg = "") {
    result->set_code(ToPbErrorCode(code));
    result->set_msg(msg.empty() ? GetErrorMessage(code) : msg);
}

/**
 * @brief 添加字段级错误
 */
inline void AddFieldError(common::Result* result, const std::string& field, const std::string& msg) {
    auto* err = result->add_field_errors();
    err->set_field(field);
    err->set_msg(msg);
}

// ==================== UserEntity ↔ auth::UserInfo ====================

/**
 * @brief UserEntity 转 auth::UserInfo（登录/注册响应用）
 * @note auth::UserInfo 不包含敏感信息
 */
inline void EntityToAuthUserInfo(const UserEntity& entity, auth::UserInfo* user_info) {
    user_info->set_id(entity.uuid);
    user_info->set_mobile(entity.mobile);  // 可选：脱敏处理
    user_info->set_display_name(entity.display_name);
    user_info->set_disabled(entity.disabled);
    StringToTimestamp(entity.created_at, user_info->mutable_created_at());
}

// ==================== UserEntity ↔ user::User ====================

/**
 * @brief UserEntity 转 user::User（完整用户信息）
 */
inline void EntityToUserProto(const UserEntity& entity, user::User* user) {
    user->set_id(entity.uuid);
    user->set_mobile(entity.mobile);
    user->set_display_name(entity.display_name);
    user->set_disabled(entity.disabled);
    StringToTimestamp(entity.created_at, user->mutable_created_at());
    StringToTimestamp(entity.updated_at, user->mutable_updated_at());
    // 注意：password_hash 永远不返回给客户端
}

/**
 * @brief user::User 转 UserEntity（用于更新操作）
 * @note 只转换允许客户端修改的字段
 */
inline void UserProtoToEntity(const user::User& user, UserEntity& entity) {
    entity.uuid = user.id();
    entity.display_name = user.display_name();
    // mobile 不允许直接修改，需要走换绑流程
    // password_hash 不从 proto 获取
}

// ==================== 手机号脱敏 ====================

/**
 * @brief 手机号脱敏 138****1234
 */
inline std::string MaskMobile(const std::string& mobile) {
    if (mobile.length() != 11) return mobile;
    return mobile.substr(0, 3) + "****" + mobile.substr(7);
}

// ==================== 分页转换 ====================

/**
 * @brief 填充分页响应
 */
inline void FillPageResponse(user::PageResponse* resp, 
                             int64_t total_records, 
                             int32_t total_pages,
                             int32_t page, 
                             int32_t page_size) {
    resp->set_total_records(total_records);
    resp->set_total_pages(total_pages);
    resp->set_page(page);
    resp->set_page_size(page_size);
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/uuid.h ======================

#pragma once

#include <uuid/uuid.h>
#include <string>
#include <cstring>

namespace user_service{

/**
 * UUID 工具类 - 针对用户管理系统
 * 
 * 对应 proto 中的使用场景：
 * - User.id         → UserId()
 * - Token           → Token()
 * - 通用场景        → Generate()
 */
class UUIDHelper {
public:
    // ==================== 基础生成 ====================
    
    /// 生成标准格式 UUID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    static std::string Generate() {
        uuid_t uuid;
        char str[37];
        uuid_generate_random(uuid);
        uuid_unparse_lower(uuid, str);
        return std::string(str);
    }
    
    /// 生成紧凑格式（无连字符）: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    static std::string GenerateCompact() {
        uuid_t uuid;
        char str[37];
        uuid_generate_random(uuid);
        uuid_unparse_lower(uuid, str);
        
        // 移除连字符
        std::string result;
        result.reserve(32);
        for (int i = 0; i < 36; ++i) {
            if (str[i] != '-') {
                result += str[i];
            }
        }
        return result;
    }
    
    // ==================== 业务专用（对应 proto 字段）====================
    
    /// 用户 ID（对应 User.id）
    /// 格式: usr_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    static std::string UserId() {
        return "usr_" + Generate();
    }
    
    /// 认证 Token（对应 AuthenticateResponse.token）
    /// 格式: 紧凑型，便于传输
    static std::string Token() {
        return GenerateCompact();
    }
    
    /// Session ID（如需会话管理）
    /// 格式: sess_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    static std::string SessionId() {
        return "sess_" + GenerateCompact();
    }
    
    // ==================== 工具方法 ====================
    
    /// 验证 UUID 格式是否正确
    static bool IsValid(const std::string& str) {
        std::string uuid_part = ExtractUUID(str);
        
        // 标准格式 36 字符
        if (uuid_part.length() == 36) {
            uuid_t tmp;
            return uuid_parse(uuid_part.c_str(), tmp) == 0;
        }
        
        // 紧凑格式 32 字符
        if (uuid_part.length() == 32) {
            for (char c : uuid_part) {
                if (!std::isxdigit(static_cast<unsigned char>(c))) {
                    return false;
                }
            }
            return true;
        }
        
        return false;
    }
    
    /// 从带前缀的 ID 中提取纯 UUID 部分
    /// "usr_xxxx-xxxx" → "xxxx-xxxx"
    static std::string ExtractUUID(const std::string& prefixed_id) {
        size_t pos = prefixed_id.find('_');
        if (pos != std::string::npos && pos + 1 < prefixed_id.length()) {
            return prefixed_id.substr(pos + 1);
        }
        return prefixed_id;
    }
    
    /// 判断 ID 类型
    enum class IDType { USER, SESSION, TOKEN, UNKNOWN };
    
    static IDType GetIDType(const std::string& id) {
        if (id.compare(0, 4, "usr_") == 0)  return IDType::USER;
        if (id.compare(0, 5, "sess_") == 0) return IDType::SESSION;
        if (id.length() == 32 && IsValid(id)) return IDType::TOKEN;
        return IDType::UNKNOWN;
    }
};

} // namespace user_servic

-----------------------------------------------------


// ====================== ./include/common/logger.h ======================

#pragma once
#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_DEBUG
#include <string>
#include <spdlog/spdlog.h>
namespace spdlog{
    class Logger;
}

namespace user_service{

class Logger{
public:
    static void Init(const std::string& log_path,
                     const std::string& filename,
                     const std::string& level="info",
                     size_t max_size = 5*1024*1024,
                     int max_files=3,
                     bool console_output=true);

    static void Shutdown();

    static bool IsInitialized(){return initialized;}
private:
    static spdlog::level::level_enum ParseLevel(const std::string& level);
    static bool initialized;
};


#define LOG_TRACE(...) do { if (user_service::Logger::IsInitialized()) { SPDLOG_TRACE(__VA_ARGS__); } } while(0)
#define LOG_DEBUG(...) do { if (user_service::Logger::IsInitialized()) { SPDLOG_DEBUG(__VA_ARGS__); } } while(0)
#define LOG_INFO(...) do { if (user_service::Logger::IsInitialized()) { SPDLOG_INFO(__VA_ARGS__); } } while(0)
#define LOG_WARN(...) do { if (user_service::Logger::IsInitialized()) { SPDLOG_WARN(__VA_ARGS__); } } while(0)
#define LOG_ERROR(...) do { if (user_service::Logger::IsInitialized()) { SPDLOG_ERROR(__VA_ARGS__); } } while(0)


}

-----------------------------------------------------


// ====================== ./include/common/password_helper.h ======================

#pragma once

#include <string>
#include <random>
#include <sstream>
#include <iomanip>
#include <openssl/sha.h>
#include <openssl/evp.h>
#include <openssl/rand.h>

namespace user_service {

class PasswordHelper {
public:
    /**
     * @brief 生成密码哈希（SHA256 + 盐）
     * @return 格式: $sha256$<salt>$<hash>
     * @note 生产环境建议使用 bcrypt/argon2
     */
    static std::string Hash(const std::string& password) {
        // 1. 生成 16 字节随机盐
        unsigned char salt_bytes[16];
        RAND_bytes(salt_bytes, sizeof(salt_bytes));
        std::string salt = BytesToHex(salt_bytes, sizeof(salt_bytes));
        
        // 2. 计算 hash = SHA256(salt + password)
        std::string salted = salt + password;
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256(reinterpret_cast<const unsigned char*>(salted.c_str()), 
               salted.size(), hash);
        
        std::string hash_hex = BytesToHex(hash, SHA256_DIGEST_LENGTH);
        
        // 3. 返回格式: $sha256$salt$hash
        return "$sha256$" + salt + "$" + hash_hex;
    }
    
    /**
     * @brief 验证密码
     */
    static bool Verify(const std::string& password, const std::string& stored_hash) {
        // 解析存储的哈希: $sha256$<salt>$<hash>
        if (stored_hash.substr(0, 8) != "$sha256$") {
            return false;
        }
        
        size_t salt_start = 8;
        size_t salt_end = stored_hash.find('$', salt_start);
        if (salt_end == std::string::npos) {
            return false;
        }
        
        std::string salt = stored_hash.substr(salt_start, salt_end - salt_start);
        std::string expected_hash = stored_hash.substr(salt_end + 1);
        
        // 计算 hash = SHA256(salt + password)
        std::string salted = salt + password;
        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256(reinterpret_cast<const unsigned char*>(salted.c_str()), 
               salted.size(), hash);
        
        std::string actual_hash = BytesToHex(hash, SHA256_DIGEST_LENGTH);
        
        // 常量时间比较（防止时序攻击）
        return ConstantTimeCompare(expected_hash, actual_hash);
    }

private:
    static std::string BytesToHex(const unsigned char* data, size_t len) {
        std::ostringstream oss;
        for (size_t i = 0; i < len; ++i) {
            oss << std::hex << std::setw(2) << std::setfill('0') 
                << static_cast<int>(data[i]);
        }
        return oss.str();
    }
    
    static bool ConstantTimeCompare(const std::string& a, const std::string& b) {
        if (a.length() != b.length()) return false;
        volatile int result = 0;
        for (size_t i = 0; i < a.length(); ++i) {
            result |= a[i] ^ b[i];
        }
        return result == 0;
    }
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/error_codes.h ======================

#pragma once


#include <string>
#include <grpcpp/grpcpp.h>

namespace user_service{
enum class ErrorCode{
    // ========== 成功 ==========
    Ok = 0,

    // ==================== 通用错误（100~999） ====================
    // 系统错误（1xx）
    Unknown             = 100,  // 未知错误
    Internal            = 101,  // 内部服务器异常
    NotImplemented      = 102,  // 功能未实现
    ServiceUnavailable  = 103,  // 服务不可用
    Timeout             = 104,  // 请求超时

    // 参数错误（2xx）
    InvalidArgument     = 200,  // 参数无效
    InvalidPage         = 210,  // 无效的分页参数
    InvalidPageSize     = 211,  // 无效的分页大小

    // 限流（3xx）
    RateLimited         = 300,  // 请求过于频繁
    QuotaExceeded       = 301,  // 配额超限

    // ==================== 认证错误（1000~1999） ====================
    // Token 相关（100x）
    Unauthenticated     = 1000, // 未认证（通用）
    TokenMissing        = 1001, // Token 缺失
    TokenInvalid        = 1002, // Token 无效
    TokenExpired        = 1003, // Token 已过期
    TokenRevoked        = 1004, // Token 已注销

    // 登录相关（101x~102x）
    LoginFailed         = 1010, // 登录失败（通用）
    WrongPassword       = 1011, // 密码错误
    AccountLocked       = 1012, // 账号已锁定（多次密码错误）

    // 验证码相关
    CaptchaWrong        = 1021, // 验证码错误
    CaptchaExpired      = 1022, // 验证码已过期


    // ==================== 用户错误（2000~2999） ====================
    // 用户查询（200x）
    UserNotFound        = 2000, // 用户不存在
    UserDeleted         = 2001, // 用户已删除

    // 用户创建（201x）
    UserAlreadyExists   = 2010, // 用户已存在（通用）
    MobileTaken         = 2013, // 手机号已被占用

    // 用户状态（202x）
    UserDisabled        = 2020, // 用户已禁用
    UserNotVerified     = 2021, // 用户未验证

    // ==================== 权限错误（3000~3999） ====================
    PermissionDenied    = 3000, // 无权限（通用）
    AdminRequired       = 3001, // 需要管理员权限
    OwnerRequired       = 3002, // 需要是资源所有者
};

// ============================================================================
// 错误码工具函数
// ============================================================================

// 获取错误码对应的消息（用户友好）
inline std::string GetErrorMessage(ErrorCode code) {
    switch (code) {
        case ErrorCode::Ok:                  return "成功";
        
        // 通用错误
        case ErrorCode::Unknown:             return "未知错误";
        case ErrorCode::Internal:            return "服务器内部错误";
        case ErrorCode::NotImplemented:      return "功能暂未实现";
        case ErrorCode::ServiceUnavailable:  return "服务暂不可用";
        case ErrorCode::Timeout:             return "请求超时";
        case ErrorCode::InvalidArgument:     return "参数无效";
        case ErrorCode::InvalidPage:         return "无效的页码";
        case ErrorCode::InvalidPageSize:     return "无效的每页大小";
        case ErrorCode::RateLimited:         return "请求过于频繁，请稍后再试";
        case ErrorCode::QuotaExceeded:       return "配额已超限";

        // 认证错误
        case ErrorCode::Unauthenticated:     return "请先登录";
        case ErrorCode::TokenMissing:        return "缺少认证信息";
        case ErrorCode::TokenInvalid:        return "认证信息无效";
        case ErrorCode::TokenExpired:        return "登录已过期，请重新登录";
        case ErrorCode::TokenRevoked:        return "登录已失效";
        case ErrorCode::LoginFailed:         return "登录失败";
        case ErrorCode::WrongPassword:       return "用户名或密码错误";  // 故意模糊
        case ErrorCode::AccountLocked:       return "账号已锁定，请稍后再试";
        case ErrorCode::CaptchaWrong:        return "验证码错误";
        case ErrorCode::CaptchaExpired:      return "验证码已过期，请重新获取";

        // 用户错误
        case ErrorCode::UserNotFound:        return "用户不存在";
        case ErrorCode::UserDeleted:         return "用户已注销";
        case ErrorCode::UserAlreadyExists:   return "用户已存在";
        case ErrorCode::MobileTaken:         return "手机号已被使用";
        case ErrorCode::UserDisabled:        return "账号已被禁用";
        case ErrorCode::UserNotVerified:     return "账号未验证";

        // 权限错误
        case ErrorCode::PermissionDenied:    return "无权限执行此操作";
        case ErrorCode::AdminRequired:       return "需要管理员权限";
        case ErrorCode::OwnerRequired:       return "只有所有者可执行此操作";

        default:                             return "未知错误";
    }
}

// 错误码 → gRPC 状态码映射
inline constexpr grpc::StatusCode ToGrpcStatus(ErrorCode code) {
    switch (code) {
        case ErrorCode::Ok:
            return grpc::StatusCode::OK;

        // 参数错误 → INVALID_ARGUMENT
        case ErrorCode::InvalidArgument:
        case ErrorCode::InvalidPage:
        case ErrorCode::InvalidPageSize:
            return grpc::StatusCode::INVALID_ARGUMENT;

        // 认证错误 → UNAUTHENTICATED
        case ErrorCode::Unauthenticated:
        case ErrorCode::TokenMissing:
        case ErrorCode::TokenInvalid:
        case ErrorCode::TokenExpired:
        case ErrorCode::TokenRevoked:
        case ErrorCode::LoginFailed:
        case ErrorCode::WrongPassword:
        case ErrorCode::CaptchaWrong:
        case ErrorCode::CaptchaExpired:
            return grpc::StatusCode::UNAUTHENTICATED;

        // 未找到 → NOT_FOUND
        case ErrorCode::UserNotFound:
        case ErrorCode::UserDeleted:
            return grpc::StatusCode::NOT_FOUND;

        // 已存在 → ALREADY_EXISTS
        case ErrorCode::UserAlreadyExists:
        case ErrorCode::MobileTaken:
            return grpc::StatusCode::ALREADY_EXISTS;

        // 权限/状态错误 → PERMISSION_DENIED
        case ErrorCode::PermissionDenied:
        case ErrorCode::AdminRequired:
        case ErrorCode::OwnerRequired:
        case ErrorCode::UserDisabled:
        case ErrorCode::AccountLocked:
            return grpc::StatusCode::PERMISSION_DENIED;

        // 限流 → RESOURCE_EXHAUSTED
        case ErrorCode::RateLimited:
        case ErrorCode::QuotaExceeded:
            return grpc::StatusCode::RESOURCE_EXHAUSTED;

        // 未实现 → UNIMPLEMENTED
        case ErrorCode::NotImplemented:
            return grpc::StatusCode::UNIMPLEMENTED;

        // 服务不可用 → UNAVAILABLE
        case ErrorCode::ServiceUnavailable:
        case ErrorCode::Timeout:
            return grpc::StatusCode::UNAVAILABLE;

        // 其他 → INTERNAL
        default:
            return grpc::StatusCode::INTERNAL;
    }
}

// 错误码 → HTTP 状态码映射（如果需要 REST 网关）
inline constexpr int ToHttpStatus(ErrorCode code) {
    switch (code) {
        case ErrorCode::Ok:                  return 200;
        
        case ErrorCode::InvalidArgument:
        case ErrorCode::InvalidPage:
        case ErrorCode::InvalidPageSize:     return 400;  // Bad Request

        case ErrorCode::Unauthenticated:
        case ErrorCode::TokenMissing:
        case ErrorCode::TokenInvalid:
        case ErrorCode::TokenExpired:
        case ErrorCode::TokenRevoked:
        case ErrorCode::LoginFailed:
        case ErrorCode::WrongPassword:
        case ErrorCode::CaptchaWrong:
        case ErrorCode::CaptchaExpired:      return 401;  // Unauthorized

        case ErrorCode::PermissionDenied:
        case ErrorCode::AdminRequired:
        case ErrorCode::OwnerRequired:
        case ErrorCode::UserDisabled:
        case ErrorCode::AccountLocked:       return 403;  // Forbidden

        case ErrorCode::UserNotFound:
        case ErrorCode::UserDeleted:         return 404;  // Not Found

        case ErrorCode::UserAlreadyExists:
        case ErrorCode::MobileTaken:         return 409;  // Conflict

        case ErrorCode::RateLimited:
        case ErrorCode::QuotaExceeded:       return 429;  // Too Many Requests

        case ErrorCode::NotImplemented:      return 501;  // Not Implemented
        case ErrorCode::ServiceUnavailable:  return 503;  // Service Unavailable

        default:                             return 500;  // Internal Server Error
    }
}

}


-----------------------------------------------------


// ====================== ./include/common/result.h ======================

#pragma once

#include "error_codes.h"
#include <optional>

namespace user_service {

// 通用版本：有返回值
template<typename T>
struct Result {
    ErrorCode code;
    std::string message;
    std::optional<T> data;

    // ==================== 构造方法 ====================
    
    // 成功：有返回值
    static Result Ok(const T& value) {
        return {ErrorCode::Ok, GetErrorMessage(ErrorCode::Ok), value};
    }
    
    // 成功：移动语义
    static Result Ok(T&& value) {
        return {ErrorCode::Ok, GetErrorMessage(ErrorCode::Ok), std::move(value)};
    }

    // 失败
    static Result Fail(ErrorCode c, const std::string& msg = "") {
        return {c, msg.empty() ? GetErrorMessage(c) : msg, std::nullopt};
    }

    // ==================== 状态检查 ====================
    
    bool Success() const { return code == ErrorCode::Ok; }
    bool Failure() const { return !Success(); }
    
    // 别名方法（兼容不同命名习惯）
    bool IsOk() const { return Success(); }
    bool IsErr() const { return Failure(); }

    explicit operator bool() const {
        return code == ErrorCode::Ok;
    }
    
    // ==================== 数据访问 ====================
    
    // 获取值（如果成功）
    const T& Value() const& { return *data; }
    T& Value() & { return *data; }
    T&& Value() && { return std::move(*data); }
    
    // 获取值或默认值
    T ValueOr(const T& default_value) const {
        return data.value_or(default_value);
    }
    
    // ==================== 错误访问 ====================
    
    // 别名（兼容不同命名习惯）
    std::optional<T> GetData() const { return data;}
    ErrorCode GetErrCode() const { return code; }
    const std::string& GetErrMessage() const { return message; }
};

// ==================== 特化版本：无返回值 ====================

template<>
struct Result<void> {
    ErrorCode code;
    std::string message;

    // 成功
    static Result Ok() {
        return {ErrorCode::Ok, GetErrorMessage(ErrorCode::Ok)};
    }

    // 失败
    static Result Fail(ErrorCode c, const std::string& msg = "") {
        return {c, msg.empty() ? GetErrorMessage(c) : msg};
    }

    // 状态检查
    bool Success() const { return code == ErrorCode::Ok; }
    bool Failure() const { return !Success(); }
    
    // 别名方法
    bool IsOk() const { return Success(); }
    bool IsErr() const { return Failure(); }

    explicit operator bool() const {
        return code == ErrorCode::Ok;
    }
    
    // 错误访问别名
    user_service::ErrorCode GetErrCode() const { return code; }
    const std::string& GetErrMessage() const { return message; }
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/auth_type.h ======================

#pragma once

#include <string>
#include <chrono>
#include "entity/user_entity.h"

namespace user_service {

// ============================================================================
// Token 相关结构体
// ============================================================================

/// @brief Token 令牌对（统一定义，JwtService 和 AuthService 共用）
struct TokenPair {
    std::string access_token;   ///< 访问令牌
    std::string refresh_token;  ///< 刷新令牌
    int64_t expires_in;         ///< access_token 有效期（秒）
};

/// @brief Access Token 解析后的载荷
struct AccessTokenPayload {
    int64_t user_id;            ///< 数据库用户ID
    std::string user_uuid;      ///< 用户 UUID（对外标识）
    std::string mobile;         ///< 手机号
    UserRole role;              ///< 用户身份
    std::chrono::system_clock::time_point expires_at;  ///< 过期时间
};

/// @brief Token 验证结果（ValidateToken 返回）
struct TokenValidationResult {
    int64_t user_id = 0;        ///< 数据库用户ID
    std::string user_uuid;      ///< 用户 UUID
    std::string mobile;         ///< 手机号
    UserRole role;              ///< 用户身份
    std::chrono::system_clock::time_point expires_at;  ///< 过期时间
};


// ============================================================================
// 认证业务相关结构体
// ============================================================================

/// @brief 认证结果（注册/登录成功后返回）
struct AuthResult {
    UserEntity user;    ///< 用户信息
    TokenPair tokens;   ///< Token 对
};

/// @brief 验证码场景
enum class SmsScene {
    UnKnow = 0,         // 未指定场景（默认值，用于参数校验，非法场景）
    Register = 1,       // 注册场景 - 新用户账号注册验证
    Login = 2,          // 登录场景 - 账号短信登录/验证登录
    ResetPassword = 3,  // 重置密码场景 - 忘记密码/账号密码重置
    DeleteUser =4       // 删除用户
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/time_utils.h ======================

#pragma once

#include <string>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <chrono>
#include <google/protobuf/timestamp.pb.h>

namespace user_service {

// ==================== chrono <-> string ====================

/**
 * @brief chrono::time_point 转字符串
 * @param tp 时间点
 * @return 格式 "YYYY-MM-DD HH:MM:SS"（UTC）
 */
inline std::string TimePointToString(const std::chrono::system_clock::time_point& tp) {
    std::time_t time = std::chrono::system_clock::to_time_t(tp);
    std::tm tm;
    gmtime_r(&time, &tm);  // 线程安全（POSIX）
    char buf[32];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &tm);
    return std::string(buf);
}

/**
 * @brief 字符串转 chrono::time_point
 * @param time_str 格式 "YYYY-MM-DD HH:MM:SS"（UTC）
 * @return 时间点，解析失败返回 epoch
 */
inline std::chrono::system_clock::time_point StringToTimePoint(const std::string& time_str) {
    if (time_str.empty()) {
        return std::chrono::system_clock::time_point{};
    }
    
    std::tm tm = {};
    std::istringstream ss(time_str);
    ss >> std::get_time(&tm, "%Y-%m-%d %H:%M:%S");
    
    if (ss.fail()) {
        return std::chrono::system_clock::time_point{};
    }
    
    std::time_t time = timegm(&tm);  // UTC
    return std::chrono::system_clock::from_time_t(time);
}

// ==================== Unix 时间戳 <-> string ====================

/**
 * @brief Unix 时间戳（秒）转字符串
 */
inline std::string UnixToString(int64_t unix_seconds) {
    if (unix_seconds <= 0) {
        return "1970-01-01 00:00:00";
    }
    std::time_t time = static_cast<std::time_t>(unix_seconds);
    std::tm tm;
    gmtime_r(&time, &tm);
    char buf[32];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &tm);
    return std::string(buf);
}

/**
 * @brief 字符串转 Unix 时间戳（秒）
 */
inline int64_t StringToUnix(const std::string& time_str) {
    if (time_str.empty()) return 0;
    
    std::tm tm = {};
    std::istringstream ss(time_str);
    ss >> std::get_time(&tm, "%Y-%m-%d %H:%M:%S");
    
    if (ss.fail()) return 0;
    return static_cast<int64_t>(timegm(&tm));
}

// ==================== Protobuf Timestamp ====================

/**
 * @brief Protobuf Timestamp 转字符串
 */
inline std::string TimestampToString(const google::protobuf::Timestamp& ts) {
    return UnixToString(ts.seconds());
}

/**
 * @brief 字符串转 Protobuf Timestamp
 */
inline void StringToTimestamp(const std::string& time_str, google::protobuf::Timestamp* ts) {
    if (time_str.empty() || !ts) return;
    ts->set_seconds(StringToUnix(time_str));
    ts->set_nanos(0);
}

/**
 * @brief chrono::time_point 转 Protobuf Timestamp
 */
inline void TimePointToTimestamp(const std::chrono::system_clock::time_point& tp,
                                  google::protobuf::Timestamp* ts) {
    if (!ts) return;
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(
        tp.time_since_epoch()
    ).count();
    ts->set_seconds(seconds);
    ts->set_nanos(0);
}

// ==================== 便捷函数 ====================

/**
 * @brief 获取当前 Unix 时间戳（秒）
 */
inline int64_t NowSeconds() {
    return std::time(nullptr);
}

/**
 * @brief 获取当前时间字符串
 */
inline std::string NowString() {
    return UnixToString(NowSeconds());
}

/**
 * @brief 获取 N 秒后的时间字符串
 */
inline std::string FutureString(int64_t seconds_from_now) {
    return UnixToString(NowSeconds() + seconds_from_now);
}

/**
 * @brief 获取 N 天后的时间字符串
 */
inline std::string FutureDaysString(int days) {
    return FutureString(days * 24 * 3600);
}

/**
 * @brief 判断时间字符串是否已过期
 */
inline bool IsExpired(const std::string& expires_at) {
    return StringToUnix(expires_at) < NowSeconds();
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/common/proto_converter.h ======================

#pragma once

#include <string>
#include <grpcpp/grpcpp.h>
#include "pb_common/result.pb.h"
#include "common/error_codes.h"
#include "common/auth_type.h"
#include "entity/user_entity.h"
#include "entity/page.h"
#include "pb_common/result.grpc.pb.h"
#include "pb_auth/auth.grpc.pb.h"
#include "pb_user/user.grpc.pb.h"

namespace user_service {

// ============================================================================
// ErrorCode 转换函数
// ============================================================================

// 业务层 ErrorCode → Proto ErrorCode
inline pb_common::ErrorCode ToProtoErrorCode(ErrorCode code) {
    // 数值相同，直接转换
    return static_cast<pb_common::ErrorCode>(static_cast<int>(code));
}

// Proto ErrorCode → 业务层 ErrorCode
inline ErrorCode FromProtoErrorCode(pb_common::ErrorCode code) {
    return static_cast<ErrorCode>(static_cast<int>(code));
}

// ============================================================================
// 便捷函数：直接设置 Result
// ============================================================================

// 设置成功结果
inline void SetResultOk(pb_common::Result* result, const std::string& msg = "成功") {
    result->set_code(pb_common::ErrorCode::OK);
    result->set_msg(msg);
}

// 设置错误结果
inline void SetResultError(pb_common::Result* result, ErrorCode code) {
    result->set_code(ToProtoErrorCode(code));
    result->set_msg(GetErrorMessage(code));
}

// 设置错误结果（自定义消息）
inline void SetResultError(pb_common::Result* result, ErrorCode code, const std::string& msg) {
    result->set_code(ToProtoErrorCode(code));
    result->set_msg(msg);
}


// ============================================================================
// 时间转换
// ============================================================================

/// @brief MySQL DATETIME 字符串 → Protobuf Timestamp
/// @param datetime_str 格式: "2024-01-15 10:30:00"
inline google::protobuf::Timestamp ToProtoTimestamp(const std::string& datetime_str) {
    google::protobuf::Timestamp ts;
    
    if (datetime_str.empty()) {
        ts.set_seconds(0);
        ts.set_nanos(0);
        return ts;
    }
    
    // 简单解析 "YYYY-MM-DD HH:MM:SS"
    std::tm tm = {};
    if (strptime(datetime_str.c_str(), "%Y-%m-%d %H:%M:%S", &tm) != nullptr) {
        std::time_t time = std::mktime(&tm);
        ts.set_seconds(time);
        ts.set_nanos(0);
    }
    
    return ts;
}

/// @brief Protobuf Timestamp → MySQL DATETIME 字符串
inline std::string FromProtoTimestamp(const google::protobuf::Timestamp& ts) {
    std::time_t time = ts.seconds();
    std::tm* tm = std::localtime(&time);
    
    char buf[32];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", tm);
    return std::string(buf);
}

/// @brief system_clock::time_point → Protobuf Timestamp
inline google::protobuf::Timestamp ToProtoTimestamp(
    const std::chrono::system_clock::time_point& tp) {
    google::protobuf::Timestamp ts;
    auto duration = tp.time_since_epoch();
    auto seconds = std::chrono::duration_cast<std::chrono::seconds>(duration);
    auto nanos = std::chrono::duration_cast<std::chrono::nanoseconds>(duration - seconds);
    ts.set_seconds(seconds.count());
    ts.set_nanos(static_cast<int32_t>(nanos.count()));
    return ts;
}

// ============================================================================
// SmsScene 枚举转换
// ============================================================================

/// @brief 业务层 SmsScene → Proto SmsScene
inline pb_auth::SmsScene ToProtoSmsScene(SmsScene scene) {
    switch (scene) {
        case SmsScene::Register:      return pb_auth::SmsScene::SMS_SCENE_REGISTER;
        case SmsScene::Login:         return pb_auth::SmsScene::SMS_SCENE_LOGIN;
        case SmsScene::ResetPassword: return pb_auth::SmsScene::SMS_SCENE_RESET_PASSWORD;
        case SmsScene::DeleteUser:    return pb_auth::SmsScene::SMS_SCENE_DELETE_USER;
        default:                      return pb_auth::SmsScene::SMS_SCENE_UNKNOWN;
    }
}

/// @brief Proto SmsScene → 业务层 SmsScene
inline SmsScene FromProtoSmsScene(pb_auth::SmsScene scene) {
    switch (scene) {
        case pb_auth::SmsScene::SMS_SCENE_REGISTER:       return SmsScene::Register;
        case pb_auth::SmsScene::SMS_SCENE_LOGIN:          return SmsScene::Login;
        case pb_auth::SmsScene::SMS_SCENE_RESET_PASSWORD: return SmsScene::ResetPassword;
        case pb_auth::SmsScene::SMS_SCENE_DELETE_USER:    return SmsScene::DeleteUser;
        default:                                          return SmsScene::UnKnow;
    }
}

// ============================================================================
// UserRole 枚举转换
// ============================================================================

/// @brief 业务层 UserRole → Proto UserRole
inline pb_auth::UserRole ToProtoUserRole(UserRole role) {
    switch (role) {
        case UserRole::User:       return pb_auth::UserRole::USER_ROLE_USER;
        case UserRole::Admin:      return pb_auth::UserRole::USER_ROLE_ADMIN;
        case UserRole::SuperAdmin: return pb_auth::UserRole::USER_ROLE_SUPER_ADMIN;
        default:                   return pb_auth::UserRole::USER_ROLE_USER;
    }
}

/// @brief Proto UserRole → 业务层 UserRole
inline UserRole FromProtoUserRole(pb_auth::UserRole role) {
    switch (role) {
        case pb_auth::UserRole::USER_ROLE_ADMIN:       return UserRole::Admin;
        case pb_auth::UserRole::USER_ROLE_SUPER_ADMIN: return UserRole::SuperAdmin;
        default:                                       return UserRole::User;
    }
}

// ============================================================================
// TokenPair 转换
// ============================================================================

/// @brief 业务层 TokenPair → Proto TokenPair
inline void ToProtoTokenPair(const TokenPair& src, pb_auth::TokenPair* dst) {
    dst->set_access_token(src.access_token);
    dst->set_refresh_token(src.refresh_token);
    dst->set_expires_in(src.expires_in);
}

/// @brief Proto TokenPair → 业务层 TokenPair
inline TokenPair FromProtoTokenPair(const pb_auth::TokenPair& src) {
    return TokenPair{
        .access_token = src.access_token(),
        .refresh_token = src.refresh_token(),
        .expires_in = src.expires_in()
    };
}

// ============================================================================
// TokenValidation 转换
// ============================================================================

/// @brief 业务层 TokenValidation → Proto ValidateTokenResponse 字段
inline void SetValidateTokenResponse(
    const TokenValidationResult& src,
    pb_auth::ValidateTokenResponse* response) 
{
    response->set_user_id(std::to_string(src.user_id));
    response->set_user_uuid(src.user_uuid);
    response->set_mobile(src.mobile);
    response->set_role(ToProtoUserRole(src.role));
    *response->mutable_expires_at() = ToProtoTimestamp(src.expires_at);
}


// ============================================================================
// UserEntity 转换
// ============================================================================

/// @brief UserEntity → pb_auth::UserInfo（登录/注册返回用）
inline void ToProtoUserInfo(const UserEntity& src, pb_auth::UserInfo* dst) {
    dst->set_id(src.uuid);
    dst->set_mobile(src.mobile);
    dst->set_display_name(src.display_name);
    dst->set_role(ToProtoUserRole(src.role));
    dst->set_disabled(src.disabled);
    *dst->mutable_created_at() = ToProtoTimestamp(src.created_at);
}

/// @brief UserEntity → pb_user::User（完整用户信息）
inline void ToProtoUser(const UserEntity& src, pb_user::User* dst) {
    dst->set_id(src.uuid);
    dst->set_mobile(src.mobile);
    dst->set_display_name(src.display_name);
    dst->set_role(ToProtoUserRole(src.role));
    dst->set_disabled(src.disabled);
    *dst->mutable_created_at() = ToProtoTimestamp(src.created_at);
    *dst->mutable_updated_at() = ToProtoTimestamp(src.updated_at);
}

/// @brief pb_auth::UserInfo → UserEntity
inline UserEntity FromProtoUserInfo(const pb_auth::UserInfo& src) {
    UserEntity entity;
    entity.uuid = src.id();
    entity.mobile = src.mobile();
    entity.display_name = src.display_name();
    entity.role = FromProtoUserRole(src.role());
    entity.disabled = src.disabled();
    entity.created_at = FromProtoTimestamp(src.created_at());
    return entity;
}

/// @brief pb_user::User → UserEntity（部分字段，用于更新）
inline UserEntity FromProtoUser(const pb_user::User& src) {
    UserEntity entity;
    entity.uuid = src.id();
    entity.mobile = src.mobile();
    entity.display_name = src.display_name();
    entity.role = FromProtoUserRole(src.role());
    entity.disabled = src.disabled();
    entity.created_at = FromProtoTimestamp(src.created_at());
    entity.updated_at = FromProtoTimestamp(src.updated_at());
    return entity;
}

// ============================================================================
// AuthResult 转换（组合转换）
// ============================================================================

/// @brief 设置 RegisterResponse / LoginResponse
inline void SetAuthResponse(
    const AuthResult& result,
    pb_auth::UserInfo* user_info,
    pb_auth::TokenPair* tokens) 
{
    ToProtoUserInfo(result.user, user_info);
    ToProtoTokenPair(result.tokens, tokens);
}

// ============================================================================
// 分页转换
// ============================================================================

/// @brief Proto PageRequest → 业务层 PageParams
inline PageParams FromProtoPageRequest(const pb_user::PageRequest& src) {
    PageParams params;
    params.page = src.page();
    params.page_size = src.page_size();
    params.Validate();  // 自动校验
    return params;
}

/// @brief 业务层 PageResult → Proto PageResponse
inline void ToProtoPageResponse(const PageResult& src, pb_user::PageResponse* dst) {
    dst->set_total_records(src.total_records);
    dst->set_total_pages(src.total_pages);
    dst->set_page(src.page);
    dst->set_page_size(src.page_size);
}

// ============================================================================
// Wrapper 类型辅助函数
// ============================================================================

/// @brief 检查 StringValue 是否有值
inline bool HasValue(const google::protobuf::StringValue& wrapper) {
    return !wrapper.value().empty();
}

/// @brief 检查 BoolValue 是否有值（通过是否被设置判断）
inline bool HasValue(const google::protobuf::BoolValue& wrapper, bool* out_value) {
    // BoolValue 总是有值，需要通过 message 是否存在来判断
    *out_value = wrapper.value();
    return true;
}

/// @brief 获取 StringValue 的值，无值返回默认值
inline std::string GetValueOr(
    const google::protobuf::StringValue& wrapper, 
    const std::string& default_value = "") 
{
    return wrapper.value().empty() ? default_value : wrapper.value();
}

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/auth/jwt_service.h ======================

#pragma once

#include <string>
#include <optional>
#include <chrono>
#include <map>
#include "common/auth_type.h"
#include "common/result.h"
#include "config/config.h"

// 认证模块命名空间
namespace user_service {
// JWT核心服务类：提供双令牌生成、验证、解析、哈希等核心功能
class JwtService {
public:
    virtual ~JwtService()=default; 

    // 构造函数：传入JWT配置初始化服务
    explicit JwtService(const SecurityConfig& config);
    
    // 生成双令牌对：根据用户ID，生成access_token+refresh_token
    virtual TokenPair GenerateTokenPair(const UserEntity& user);
    
    // 验证访问令牌：校验token有效性，有效则返回解析后的载荷，无效返回错误
    virtual Result<AccessTokenPayload> VerifyAccessToken(const std::string& token);
    
    // 解析刷新令牌：校验refresh_token有效性，有效则返回关联的用户ID，无效返回错误
    virtual Result<std::string> ParseRefreshToken(const std::string& token);
    
    // 令牌哈希：对原始令牌做哈希处理（用于服务端存储，避免明文保存令牌）
    static std::string HashToken(const std::string& token);

private:
    SecurityConfig config_; // 私有配置：存储JWT全局配置
    
    // 生成访问令牌（私有）：内部调用，单独生成access_token
    std::string GenerateAccessToken(const UserEntity& user);
    // 生成刷新令牌（私有）：内部调用，单独生成refresh_token
    std::string GenerateRefreshToken(const UserEntity& user);
    
    // JWT核心工具函数（静态私有）：供内部调用，封装JWT基础操作
    static std::string Base64UrlEncode(const std::string& input); // Base64Url编码（JWT专用，兼容URL）
    static std::string Base64UrlDecode(const std::string& input); // Base64Url解码
    static std::string HmacSha256(const std::string& key, const std::string& data); // HmacSha256签名（JWT验签核心）
    static std::string CreateJwt(const std::map<std::string, std::string>& claims, 
                                  const std::string& secret); // 生成JWT令牌：传入载荷和秘钥
    
    // 验证JWT令牌结果
    struct JwtVerifyResult {
        bool success = false;
        ErrorCode error_code = ErrorCode::Ok;
        std::map<std::string, std::string> claims;
    };
    
    static JwtVerifyResult VerifyJwt(
        const std::string& token, const std::string& secret); // 验证JWT令牌：校验签名+过期，返回解析后的载荷
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/auth/token_cleanup_task.h ======================

// include/auth/token_cleanup_task.h

#pragma once

#include <thread>
#include <atomic>
#include <mutex>
#include <memory>
#include "common/logger.h"
#include "auth/token_repository.h"

namespace user_service {

class TokenCleanupTask {
public:
    TokenCleanupTask(std::shared_ptr<TokenRepository> token_repo, int interval_minutes = 60);
    ~TokenCleanupTask();  // 添加析构函数
    
    // 禁止拷贝和移动
    TokenCleanupTask(const TokenCleanupTask&) = delete;
    TokenCleanupTask& operator=(const TokenCleanupTask&) = delete;
    TokenCleanupTask(TokenCleanupTask&&) = delete;
    TokenCleanupTask& operator=(TokenCleanupTask&&) = delete;
    
    void Start();
    void Stop();

private:
    std::shared_ptr<TokenRepository> token_repo_;
    int interval_;
    std::atomic<bool> running_;
    std::thread thread_;
    std::mutex mutex_;  // 保护 Start/Stop 的并发调用
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/auth/sms_service.h ======================

#pragma once

#include<string>
#include<memory>
#include "common/auth_type.h"
#include "common/result.h"
#include "cache/redis_client.h"

namespace user_service{

/// @brief 短消息服务（SMS 全称 Short Message Service，Captcha 验证码缩写）
class SmsService{
public:
    SmsService(std::shared_ptr<RedisClient> redis, const SmsConfig& config);

    // 发送验证码
    virtual Result<int32_t> SendCaptcha(SmsScene scene,
                                        const std::string& mobile);

    // 验证验证码
    virtual Result<void> VerifyCaptcha(SmsScene scene,
                            const std::string& mobile,
                            const std::string& code);

    // 消费验证码（验证成功后删除，防止重复使用）
    virtual Result<void> ConsumeCaptcha(SmsScene scene, const std::string& mobile);
private:
    // 场景名称
    static std::string SceneName(SmsScene scene);

    // 生成随机验证码
    std::string GenerateCaptcha();

    // 实际发送短信（对接服务商）
    Result<void> DoSend(const std::string& mobile, const std::string& code, SmsScene scene);

    /*
    作用：生成短信验证码本身的缓存 Key
    存储值：实际的短信验证码（如682915）+ 过期时间（通常 5-10 分钟，验证码有效期）
    绑定 scene 原因：同一个手机号在不同场景的验证码独立（比如登录发了682915，注册可同时发954278，不会覆盖）
    典型 Key 示例：sms:code:login:13812345678、sms:code:find_pwd:13812345678
    */
    std::string CaptchaKey(SmsScene scene, const std::string& mobile);

    /*
    作用：生成短信发送间隔的缓存 Key（防频繁发送）
    存储值：最后一次发送短信的时间戳（如1735689600）
    设计原因：基础限流规则 —— 无论哪个场景，同一个手机号短时间内不能反复发验证码（比如默认 60 秒内只能发 1 次），无需绑定 scene（全局间隔限制）
    典型 Key 示例：sms:interval:13812345678
    */
    std::string IntervalKey(const std::string& mobile);
    
    /*
    作用：生成单场景验证码验证失败次数的缓存 Key（防暴力破解）
    存储值：该场景下，手机号累计验证验证码失败的次数（如2）
    绑定 scene 原因：不同场景的验证失败次数独立（比如登录验证失败 2 次，不影响注册场景）
    设计原因：防暴力破解验证码 —— 限制单场景下的失败次数（比如最多失败 3 次），超过则临时锁定该场景的短信发送 / 验证，避免攻击者枚举验证码
    典型 Key 示例：sms:verify_count:login:13812345678
    */
    std::string VerifyCountKey(SmsScene scene, const std::string& mobile);

    /*
    作用：生成单场景短信临时锁定的缓存 Key（风控兜底）
    存储值：锁定状态（如1）+ 锁定过期时间（比如 10 分钟，自动解锁）
    绑定 scene 原因：锁定仅针对当前场景（比如登录场景被锁，注册场景仍可正常使用）
    设计原因：兜底风控 —— 当满足「验证失败次数超限」「发送间隔频繁突破」等风险条件时，临时锁定该场景的短信服务，避免进一步的恶意操作，且非全局锁定，不影响用户其他业务操作，兼顾风控和用户体验
    典型 Key 示例：sms:lock:login:13812345678
    */
    std::string LockKey(SmsScene scene, const std::string& mobile);

private:
    std::shared_ptr<RedisClient> redis_;
    SmsConfig config_;
};

}


-----------------------------------------------------


// ====================== ./include/auth/jwt_authenticator.h ======================

#pragma once

#include "auth/authenticator.h"
#include "auth/jwt_service.h"
#include <memory>

namespace user_service {

class JwtAuthenticator : public Authenticator {
public:
    explicit JwtAuthenticator(std::shared_ptr<JwtService> jwt_service)
        : jwt_service_(std::move(jwt_service)) {}

    // ============================================================================
    // gRPC 请求认证函数
    // ============================================================================

    /// @brief 从 gRPC 上下文中验证 Token 并提取用户信息
    /// @details
    ///   ┌────────────────────────────────────────────────────────────────┐
    ///   │  认证流程                                                      │
    ///   ├────────────────────────────────────────────────────────────────┤
    ///   │  Client Request                                                │
    ///   │       │                                                        │
    ///   │       ▼                                                        │
    ///   │  ┌─────────────────────────────────────────┐                   │
    ///   │  │ HTTP Header                             │                   │
    ///   │  │ Authorization: Bearer eyJhbGciOi...     │                   │
    ///   │  └─────────────────────────────────────────┘                   │
    ///   │       │                                                        │
    ///   │       ▼                                                        │
    ///   │  1. 提取 metadata 中的 "authorization"                         │
    ///   │       │                                                        │
    ///   │       ▼                                                        │
    ///   │  2. 验证格式："Bearer " + token                                │
    ///   │       │                                                        │
    ///   │       ▼                                                        │
    ///   │  3. 调用 JwtService::VerifyAccessToken 验证签名和有效期        │
    ///   │       │                                                        │
    ///   │       ▼                                                        │
    ///   │  4. 返回 AuthContext（user_id, user_uuid, mobile）            │
    ///   └────────────────────────────────────────────────────────────────┘
    ///
    ///   gRPC Metadata 说明：
    ///   - gRPC 的 metadata 等同于 HTTP/2 的 headers
    ///   - 客户端设置：metadata.insert({"authorization", "Bearer xxx"})
    ///   - 服务端读取：context->client_metadata()
    ///   - key 全部小写（gRPC 规范）
    ///
    Result<AuthContext> Authenticate(::grpc::ServerContext* context) override {
        auto metadata = context->client_metadata();
        auto it = metadata.find("authorization");
        
        if (it == metadata.end()) {
            return Result<AuthContext>::Fail(ErrorCode::Unauthenticated, "缺少认证信息");
        }

        std::string auth_header(it->second.data(), it->second.size());
        
        const std::string prefix = "Bearer ";
        if (auth_header.rfind(prefix, 0) != 0) {
            return Result<AuthContext>::Fail(ErrorCode::Unauthenticated, "认证格式错误");
        }

        std::string token = auth_header.substr(prefix.length());
        if (token.empty()) {
            return Result<AuthContext>::Fail(ErrorCode::Unauthenticated, "Token 不能为空");
        }

        auto verify_result = jwt_service_->VerifyAccessToken(token);
        if (!verify_result.IsOk()) {
            return Result<AuthContext>::Fail(verify_result.code, verify_result.message);
        }

        const auto& payload = verify_result.Value();
        AuthContext auth_ctx;
        auth_ctx.user_id = payload.user_id;
        auth_ctx.user_uuid = payload.user_uuid;
        auth_ctx.mobile = payload.mobile;
        auth_ctx.role = payload.role;
        
        return Result<AuthContext>::Ok(auth_ctx);
    }

private:
    std::shared_ptr<JwtService> jwt_service_;
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/auth/authenticator.h ======================

#pragma once

#include <grpcpp/grpcpp.h>
#include "common/result.h"
#include "common/auth_type.h"

namespace user_service {

// 认证上下文
// 认证上下文（从 Token 解析出的用户信息）
struct AuthContext {
    int64_t user_id;        // 数据库 ID
    std::string user_uuid;  // UUID
    std::string mobile;     // 手机号（可选）
    UserRole role;          // 用户角色
};

// 认证器接口（可 mock）
class Authenticator {
public:
    virtual ~Authenticator() = default;

    // ============================================================================
    // gRPC 请求认证函数
    // ============================================================================

    /// @brief 从 gRPC 上下文中验证 Token 并提取用户信息
    /// @details
    ///   gRPC Metadata 说明：
    ///   - gRPC 的 metadata 等同于 HTTP/2 的 headers
    ///   - 客户端设置：metadata.insert({"authorization", "Bearer xxx"})
    ///   - 服务端读取：context->client_metadata()
    ///   - key 全部小写（gRPC 规范）
    ///
    virtual Result<AuthContext> Authenticate(::grpc::ServerContext* context) = 0;
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/auth/token_repository.h ======================

#pragma once
#include "pool/connection_pool.h"
#include "db/mysql_result.h"
#include "db/mysql_connection.h"
#include "common/result.h"
#include "common/error_codes.h"
#include "common/logger.h"
#include "entity/token.h"

#include <memory>
#include <string>
#include <chrono>
#include <vector>
#include <ctime>
#include <iomanip>
#include <sstream>

namespace user_service {

// ==================== Token 仓库类 ====================
class TokenRepository {
public:
    using MySQLPool=TemplateConnectionPool<MySQLConnection>;
    explicit TokenRepository(std::shared_ptr<MySQLPool> pool);

    virtual ~TokenRepository()=default;
    // ==================== 创建 ====================
    // 保存 Refresh Token（创建会话）
    virtual Result<void> SaveRefreshToken(int64_t user_id,
                                   const std::string& token_hash,
                                   int expires_in_seconds);

    // ==================== 查询 ====================
    // 根据 Token 哈希查找会话
    virtual Result<TokenSession> FindByTokenHash(const std::string& token_hash);

    // 检查 Token 是否有效（存在且未过期）
    virtual Result<bool> IsTokenValid(const std::string& token_hash);

    // 获取用户的活跃会话数量
    virtual Result<int64_t> CountActiveSessionsByUserId(int64_t user_id);

    // ==================== 删除 ====================
    // 删除指定 Token（单设备登出）
    virtual Result<void> DeleteByTokenHash(const std::string& token_hash);

    // 删除用户的所有 Token（强制登出所有设备）
    virtual Result<void> DeleteByUserId(int64_t user_id);

    // 清理过期 Token（返回清理数量）
    virtual Result<int64_t> CleanExpiredTokens();

private:
    std::shared_ptr<MySQLPool> pool_;

    // 解析数据库行
    TokenSession ParseRow(MySQLResult& res);

    // 格式化时间戳为 MySQL DATETIME 格式
    static std::string FormatDatetime(std::chrono::system_clock::time_point tp);

    // 获取当前时间的 MySQL DATETIME 格式
    static std::string NowDatetime();
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/cache/redis_client.h ======================

#pragma once

#include <sw/redis++/redis++.h>
#include <memory>
#include <string>
#include <optional>
#include <chrono>
#include <vector>
#include <unordered_map>
#include "config/config.h"
#include "common/result.h"

namespace user_service {

// ============================================================================
// Redis 客户端
// 
// 设计原则：
//   - 使用 Result<T> 区分"执行失败"与"数据不存在"
//   - 所有操作都是 noexcept，通过 Result 返回错误信息
//   - Result 成功 + optional 无值 = key 不存在（正常业务情况）
//   - Result 失败 = Redis 执行出错（网络/超时等）
//
// 使用示例：
//   auto result = redis->Get("user:123");
//   if (!result.IsOk()) {
//       // Redis 执行失败
//       LOG_ERROR("Redis error: {}", result.message);
//   } else if (result.Value().has_value()) {
//       // Key 存在，获取到值
//       auto& value = result.Value().value();
//   } else {
//       // Key 不存在（正常情况）
//   }
// ============================================================================
class RedisClient {
public:
    /// @brief 构造函数（详细参数版本）
    RedisClient(const std::string& host, int port,
                const std::string& password, int db);
    
    /// @brief 构造函数（配置结构体版本）
    explicit RedisClient(const RedisConfig& config);

    virtual ~RedisClient()=default;

    // ==================== 字符串操作 ====================
    
    /// @brief 设置键值对（无过期时间）
    /// @return 成功返回 Ok，失败返回错误信息
    virtual Result<void> Set(const std::string& key, const std::string& value) noexcept;
    
    /// @brief 设置键值对 + 过期时间（毫秒）
    /// @param ttl 过期时间（毫秒），必须 > 0
    /// @return 成功返回 Ok，失败返回错误信息
    virtual Result<void> SetPx(const std::string& key, const std::string& value,
                       std::chrono::milliseconds ttl) noexcept;
    
    /// @brief 获取值
    /// @return 成功+有值=存在，成功+无值=不存在，失败=Redis错误
    virtual Result<std::optional<std::string>> Get(const std::string& key) noexcept;

    /// @brief 仅当 key 不存在时设置（分布式锁常用）
    /// @return 成功时 bool 表示是否设置成功（true=设置了，false=key已存在）
    virtual Result<bool> SetNx(const std::string& key, const std::string& value) noexcept;

    /// @brief SETNX + PEXPIRE 原子操作（分布式锁推荐）
    virtual Result<bool> SetNxPx(const std::string& key, const std::string& value,
                         std::chrono::milliseconds ttl) noexcept;

    // ==================== 通用操作 ====================
    
    /// @brief 判断键是否存在
    /// @return 成功时 bool 表示是否存在
    virtual Result<bool> Exists(const std::string& key) noexcept;
    
    /// @brief 删除键
    /// @return 成功时 bool 表示是否真的删除了（false=key本不存在）
    virtual Result<bool> Del(const std::string& key) noexcept;
    
    /// @brief 设置键的过期时间（毫秒）
    /// @return 成功时 bool 表示是否设置成功（false=key不存在）
    virtual Result<bool> PExpire(const std::string& key, std::chrono::milliseconds ttl) noexcept;

    /// @brief 获取键的剩余过期时间（毫秒）
    /// @return 成功时返回 int64_t：>0=剩余毫秒，-1=无过期时间，-2=key不存在
    virtual Result<int64_t> PTTL(const std::string& key) noexcept;

    /// @brief 获取匹配的所有 Key（KEYS 命令）——>（开发调试）
    /// @param pattern 匹配模式，如 "user:*"、"sms:code:*" 等
    /// @warning 生产环境慎用！大数据量时会阻塞 Redis
    /// @return 成功时返回匹配的 key 列表
    virtual Result<std::vector<std::string>> Keys(const std::string& pattern) noexcept;

    /// @brief 增量迭代获取 Key（SCAN 命令，推荐）
    /// @param pattern 匹配模式
    /// @param count 每次迭代建议返回的数量（仅为提示，实际可能不同）
    /// @return 成功时返回匹配的 key 列表
    virtual Result<std::vector<std::string>> Scan(const std::string& pattern, 
                                          int64_t count = 100) noexcept;


    // ==================== Hash 操作 ====================
    
    /// @brief 设置 Hash 字段
    virtual Result<void> HSet(const std::string& key, 
                      const std::string& field,
                      const std::string& value) noexcept;
    
    /// @brief 批量设置 Hash 字段
    virtual Result<void> HMSet(const std::string& key,
                       const std::vector<std::pair<std::string, std::string>>& fields) noexcept;
    
    /// @brief 获取 Hash 字段值
    /// @return 成功+有值=存在，成功+无值=字段不存在
    virtual Result<std::optional<std::string>> HGet(const std::string& key,
                                            const std::string& field) noexcept;
    
    /// @brief 获取 Hash 所有字段
    /// @return 成功时返回 map（key不存在时为空map，这是正常情况）
    virtual Result<std::unordered_map<std::string, std::string>> HGetAll(const std::string& key) noexcept;
    
    /// @brief 删除 Hash 字段
    /// @return 成功时 bool 表示是否真的删除了
    virtual Result<bool> HDel(const std::string& key, const std::string& field) noexcept;

    /// @brief 判断 Hash 字段是否存在
    virtual Result<bool> HExists(const std::string& key, const std::string& field) noexcept;

    // ==================== 原子操作 ====================
    
    /// @brief 自增 1（key不存在时从0开始）
    /// @return 成功时返回自增后的值
    virtual Result<int64_t> Incr(const std::string& key) noexcept;
    
    /// @brief 自增指定值（可为负数）
    /// @return 成功时返回自增后的值
    virtual Result<int64_t> IncrBy(const std::string& key, int64_t increment) noexcept;

    /// @brief 自减 1
    virtual Result<int64_t> Decr(const std::string& key) noexcept;

    // ==================== 健康检查 ====================
    
    /// @brief Ping 测试连接
    virtual Result<void> Ping() noexcept;

protected:
    // 供 Mock 使用的受保护构造函数
    RedisClient() = default;

private:
    std::unique_ptr<sw::redis::Redis> redis_;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/db/mysql_connection.h ======================

#pragma once

#include "config/config.h"
#include "mysql_result.h"
#include <mysql/mysql.h>
#include <string>
#include <variant>
#include <vector>

namespace user_service {

/**
 * @brief MySQL 数据库连接封装类
 * 
 * 提供安全的数据库操作接口，支持参数化查询以防止 SQL 注入。
 * 内部管理 MYSQL* 连接资源，自动处理连接失败重试。
 * 
 * @note 禁止拷贝和移动，生命周期由连接池统一管理
 * @note 所有 SQL 语句使用 '?' 作为参数占位符
 * 
 * @example
 * @code
 *   MySQLConnection conn(config);
 *   
 *   // 查询
 *   auto res = conn.Query("SELECT * FROM users WHERE id = ?", {123});
 *   
 *   // 插入
 *   conn.Execute("INSERT INTO users (name, age) VALUES (?, ?)", {"Tom", 25});
 *   auto id = conn.LastInsertId();
 * @endcode
 * 
 * @warning SQL 语句中不能包含非占位符的 '?' 字符
 */
class MySQLConnection {
public:
    /**
     * @brief 参数类型定义
     * 
     * 支持的参数类型：
     * - nullptr_t: 对应 SQL NULL
     * - int64_t/uint64_t: 整数类型
     * - double: 浮点类型
     * - std::string: 字符串（会自动转义）
     * - bool: 布尔类型（转为 0/1）
     * 
     * @note 其他类型请先转为 string 再传入
     */
    using Param = std::variant<nullptr_t, int64_t, uint64_t, double, std::string, bool>;

    /**
     * @brief 构造函数，建立数据库连接
     * @param config MySQL 配置（host, port, user, password, database 等）
     * @throws MySQLException 连接失败且重试耗尽时抛出
     */
    explicit MySQLConnection(const MySQLConfig& config);
    
    /**
     * @brief 析构函数，关闭数据库连接
     */
    ~MySQLConnection();

    /// @name 禁用拷贝和移动
    /// @{
    MySQLConnection(const MySQLConnection&) = delete;
    MySQLConnection& operator=(const MySQLConnection&) = delete;
    MySQLConnection(MySQLConnection&& other) = delete;
    MySQLConnection& operator=(MySQLConnection&& other) = delete;
    /// @}

    /**
     * @brief 检查连接是否有效
     * 
     * 内部使用 mysql_ping 检测连接状态，会自动尝试重连。
     * 
     * @return true 连接有效
     * @return false 连接无效或已断开
     */
    bool Valid() const { return mysql_ && mysql_ping(mysql_) == 0; }

    /**
     * @brief 获取原生 MySQL 连接指针
     * @return MYSQL* 原生连接指针
     * @warning 谨慎使用，避免破坏内部状态
     */
    MYSQL* Get() { return mysql_; }

    /**
     * @brief 执行 SELECT 查询
     * 
     * @param sql SQL 语句，使用 '?' 作为参数占位符
     * @param params 参数列表，按顺序替换 '?'
     * @return MySQLResult 查询结果集
     * 
     * @throws MySQLException 查询执行失败
     * @throws std::invalid_argument 参数数量与占位符不匹配
     * 
     * @example
     * @code
     *   // 无参数查询
     *   auto res = conn.Query("SELECT * FROM users");
     *   
     *   // 带参数查询（防 SQL 注入）
     *   auto res = conn.Query("SELECT * FROM users WHERE name = ? AND age > ?", 
     *                         {"Tom", 18});
     * @endcode
     * 
     * @warning SQL 中不能包含非占位符的 '?' 字符
     */
    MySQLResult Query(const std::string& sql, std::initializer_list<Param> params = {});

    MySQLResult Query(const std::string& sql, const std::vector<Param>& params);

    /**
     * @brief 执行 INSERT/UPDATE/DELETE 操作
     * 
     * @param sql SQL 语句，使用 '?' 作为参数占位符
     * @param params 参数列表，按顺序替换 '?'
     * @return uint64_t 受影响的行数
     * 
     * @throws MySQLException 执行失败
     * @throws MySQLDuplicateKeyException 唯一键冲突（INSERT 时）
     * @throws std::invalid_argument 参数数量与占位符不匹配
     * 
     * @example
     * @code
     *   // INSERT
     *   conn.Execute("INSERT INTO users (name) VALUES (?)", {"Tom"});
     *   
     *   // UPDATE
     *   uint64_t affected = conn.Execute("UPDATE users SET age = ? WHERE id = ?", {30, 1});
     *   
     *   // DELETE  
     *   uint64_t deleted = conn.Execute("DELETE FROM users WHERE id = ?", {1});
     * @endcode
     */
    uint64_t Execute(const std::string& sql, std::initializer_list<Param> params = {});

    uint64_t Execute(const std::string& sql, const std::vector<Param>& params);
    // /**
    //  * @brief 流式查询（逐行获取，适合大结果集）
    //  * @param sql SQL 语句
    //  * @return MySQLResult 流式结果集
    //  * @warning 遍历期间不能执行其他查询！
    //  */
    // MySQLResult QueryUnbuffered(const std::string& sql);

    /**
     * @brief 获取最后一次 INSERT 操作生成的自增 ID
     * @return uint64_t 自增 ID，无自增列时返回 0
     * @note 必须在 INSERT 之后立即调用
     */
    uint64_t LastInsertId();

private:
    /**
     * @brief 初始化连接并设置选项
     * @param config MySQL 配置
     * @note 设置字符集、超时、自动重连等选项
     */
    void InitAndSetOptions(const MySQLConfig& config);

    /**
     * @brief 判断错误是否值得重试
     * @param err_code MySQL 错误码
     * @return true 可重试（如网络超时、连接丢失）
     * @return false 不可重试（如语法错误、权限不足）
     */
    bool IsRetryableError(unsigned int err_code);

    /**
     * @brief 带重试机制的连接方法
     * @param config MySQL 配置
     * @throws MySQLException 重试次数耗尽仍失败
     */
    void ConnectWithRetry(const MySQLConfig& config);

    /**
     * @brief 转义字符串（防 SQL 注入）
     * @param str 原始字符串
     * @return std::string 转义后的字符串
     * @note 仅用于转义参数值，不要用于表名/列名
     */
    std::string Escape(const std::string& str);

    // /**
    //  * @brief 构建完整的 SQL 语句
    //  * 
    //  * 将参数化 SQL 中的 '?' 占位符替换为实际值。
    //  * 
    //  * @param sql 带占位符的 SQL 模板
    //  * @param params 参数列表
    //  * @return std::string 完整的可执行 SQL
    //  * 
    //  * @throws std::invalid_argument 参数数量与 '?' 数量不匹配
    //  * 
    //  * @note 字符串参数会自动转义并加引号
    //  * @note nullptr 会转换为 SQL 的 NULL
    //  * @note bool 会转换为 0 或 1
    //  */
    // std::string BuildSQL(const std::string& sql, std::initializer_list<Param> params);

    // 模板方法：接受任意迭代器
    template<typename Iter>
    std::string BuildSQL(const std::string& sql, Iter begin, Iter end);

    /**
     * @brief 根据错误码抛出对应异常
     * @param code MySQL 错误码
     * @param msg 错误描述信息
     * @throws MySQLDuplicateKeyException 唯一键冲突 (ER_DUP_ENTRY)
     * @throws MySQLException 其他错误
     */
    void ThrowByErrorCode(unsigned int code, const std::string& msg);

private:
    
    MYSQL* mysql_ = nullptr;  ///< MySQL 原生连接句柄
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/db/mysql_result.h ======================

#pragma once
#include <mysql/mysql.h>
#include <string>
#include <cstdint>
#include <stdexcept>
#include <optional>
#include <unordered_map>

namespace user_service {

/**
 * @brief MySQL 查询结果集封装类
 * 
 * 封装 MYSQL_RES，提供安全的结果集遍历和字段值获取功能。
 * 支持按索引或列名获取字段，自动管理底层资源生命周期。
 * 
 * @note 禁止拷贝，仅支持移动语义
 * @note 使用前必须先调用 Next() 获取第一行数据
 * 
 * @example
 * @code
 *   auto res = conn->Query("SELECT id, username FROM users");
 *   while (res.Next()) {
 *       auto id = res.GetInt("id");
 *       auto name = res.GetString("username");
 *   }
 * @endcode
 */
class MySQLResult {
public:
    /**
     * @brief 构造函数
     * @param res MySQL 原生结果集指针，可为 nullptr（表示空结果）
     * @note 构造时会自动构建列名索引映射
     */
    explicit MySQLResult(MYSQL_RES* res);
    
    /**
     * @brief 析构函数，自动释放 MYSQL_RES 资源
     */
    ~MySQLResult();

    /// @name 禁用拷贝，允许移动
    /// @{
    MySQLResult(const MySQLResult&) = delete;
    MySQLResult& operator=(const MySQLResult&) = delete;
    
    /**
     * @brief 移动构造函数
     * @param other 被移动的对象
     * @note noexcept 保证 STL 容器可以安全优化
     */
    MySQLResult(MySQLResult&& other) noexcept;
    
    /**
     * @brief 移动赋值运算符
     * @param other 被移动的对象
     * @return 当前对象的引用
     */
    MySQLResult& operator=(MySQLResult&& other) noexcept;
    /// @}

    // ==================== 遍历接口 ====================
    
    /**
     * @brief 获取下一行数据
     * 
     * 将游标移动到下一行，并将数据存储在内部缓冲区中。
     * 必须在调用 Get* 系列方法前调用此方法。
     * 
     * @return true 成功获取下一行
     * @return false 没有更多数据
     */
    bool Next();

    // ==================== 元信息接口 ====================
    
    /**
     * @brief 获取结果集总行数
     * @return 总行数，空结果返回 0
     * @warning 对于 unbuffered 查询，此值可能不准确
     */
    size_t RowCount() const;
    
    /**
     * @brief 获取结果集列数
     * @return 列数
     */
    size_t FieldCount() const;
    
    /**
     * @brief 判断结果集是否为空
     * @return true 结果集为空或无数据
     */
    bool Empty() const { return result_ == nullptr || RowCount() == 0; }

    // ==================== 按索引获取字段值 ====================
    
    /**
     * @brief 判断指定列是否为 NULL
     * @param col 列索引（从 0 开始）
     * @return true 该列值为 NULL
     * @throws MySQLResultException 未调用 Next() 或索引越界
     */
    bool IsNull(size_t col) const;
    
    /**
     * @brief 获取字符串类型字段值
     * @param col 列索引（从 0 开始）
     * @return 字段值，NULL 时返回 std::nullopt
     * @throws MySQLResultException 未调用 Next() 或索引越界
     */
    std::optional<std::string> GetString(size_t col) const;
    
    /**
     * @brief 获取整数类型字段值
     * @param col 列索引（从 0 开始）
     * @return 字段值（int64_t），NULL 时返回 std::nullopt
     * @throws MySQLResultException 未调用 Next() 或索引越界
     */
    std::optional<int64_t> GetInt(size_t col) const;
    
    /**
     * @brief 获取浮点类型字段值
     * @param col 列索引（从 0 开始）
     * @return 字段值（double），NULL 时返回 std::nullopt
     * @throws MySQLResultException 未调用 Next() 或索引越界
     */
    std::optional<double> GetDouble(size_t col) const;

    // ==================== 按列名获取字段值 ====================
    
    /**
     * @brief 判断指定列是否为 NULL
     * @param col_name 列名
     * @return true 该列值为 NULL
     * @throws std::out_of_range 列名不存在
     * @throws MySQLResultException 未调用 Next()
     */
    bool IsNull(const std::string& col_name) const;
    
    /**
     * @brief 获取字符串类型字段值
     * @param col_name 列名
     * @return 字段值，NULL 时返回 std::nullopt
     * @throws std::out_of_range 列名不存在
     */
    std::optional<std::string> GetString(const std::string& col_name) const;
    
    /**
     * @brief 获取整数类型字段值
     * @param col_name 列名
     * @return 字段值（int64_t），NULL 时返回 std::nullopt
     * @throws std::out_of_range 列名不存在
     */
    std::optional<int64_t> GetInt(const std::string& col_name) const;
    
    /**
     * @brief 获取浮点类型字段值
     * @param col_name 列名
     * @return 字段值（double），NULL 时返回 std::nullopt
     * @throws std::out_of_range 列名不存在
     */
    std::optional<double> GetDouble(const std::string& col_name) const;

private:
    /**
     * @brief 检查列索引是否合法
     * @param col 列索引
     * @throws MySQLResultException 未调用 Next() 或索引越界
     */
    void CheckColumn(size_t col) const;
    
    /**
     * @brief 构建列名到索引的映射表
     * @note 在构造函数中自动调用
     */
    void BuildColumnMap();
    
    /**
     * @brief 根据列名获取列索引
     * @param col_name 列名
     * @return 对应的列索引
     * @throws std::out_of_range 列名不存在
     */
    size_t GetColumnIndex(const std::string& col_name) const;

    MYSQL_RES* result_ = nullptr;           ///< MySQL 原生结果集
    MYSQL_ROW current_row_ = nullptr;       ///< 当前行数据指针
    unsigned long* lengths_ = nullptr;      ///< 当前行各字段的实际长度
    unsigned int field_count_ = 0;          ///< 结果集列数

    /// 列名到索引的映射，用于按列名快速查找
    std::unordered_map<std::string, size_t> col_name_map_;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/db/user_db.h ======================

#pragma once

#include <optional>
#include <string>
#include <vector>
#include "pool/connection_pool.h"
#include "mysql_connection.h"
#include "config/config.h"
#include "common/result.h"
#include "entity/user_entity.h"
#include "entity/page.h"

namespace user_service {

struct UserQueryParams {
    PageParams page_params;
    std::optional<std::string> mobile_like;
    std::optional<bool> disabled;
};


class MySQLResult;

// DAO封装
class UserDB {
public:
    using MySQLPool = TemplateConnectionPool<MySQLConnection>;
    using UserListResult = Result<std::pair<std::vector<UserEntity>, PageResult>>;

    explicit UserDB(std::shared_ptr<MySQLPool> pool);

    // ==================== CRUD 操作 ====================
    
    // 创建用户
    virtual Result<UserEntity> Create(const UserEntity& user);
    
    // 查询用户
    virtual Result<UserEntity> FindById(int64_t id);
    virtual Result<UserEntity> FindByUUID(const std::string& uuid);
    virtual Result<UserEntity> FindByMobile(const std::string& mobile);  // 手机号查询（登录用）
    
    // 更新用户
    virtual Result<void> Update(const UserEntity& user);
    
    // 删除用户
    virtual Result<void> Delete(int64_t id);
    virtual Result<void> DeleteByUUID(const std::string& uuid);
    
    // ==================== 分页查询 ====================
    
    // 查询用户列表（分页查询：手机号模糊查询）
    virtual UserListResult FindAll(const PageParams& page, const std::string& mobile_filter = "");
    
    // 查询用户列表（分页查询：多参数查询）
    virtual Result<std::vector<UserEntity>> FindAll(const UserQueryParams& params);
    // ==================== 辅助查询 ====================
    // 判断是否存在
    virtual Result<bool> ExistsByMobile(const std::string& mobile);

    // 统计用户数量
    virtual Result<int64_t> Count(const UserQueryParams& params);

private:
    // 根据字段寻找
    Result<UserEntity> FindByField(const std::string& field_name, const std::string& field_val);

    // 判断字段值是否存在
    Result<bool> ExistsByField(const std::string& field_name, const std::string& field_val);

    // 解析查询的一行
    UserEntity ParseRow(MySQLResult& res);

    std::shared_ptr<MySQLPool> pool_;
};

}


-----------------------------------------------------


// ====================== ./include/service/auth_service.h ======================

#pragma once

#include <memory>
#include <string>
#include "common/result.h"
#include "entity/user_entity.h"
#include "db/user_db.h"
#include "auth/token_repository.h"
#include "auth/jwt_service.h"
#include "auth/sms_service.h"
#include "common/auth_type.h"
#include "cache/redis_client.h"
#include "config/config.h"

namespace user_service {

/// @brief 认证服务类
class AuthService{
public:
    AuthService(std::shared_ptr<Config> config,
                std::shared_ptr<UserDB> user_db,
                std::shared_ptr<RedisClient> redis_cli,
                std::shared_ptr<TokenRepository> token_repo,
                std::shared_ptr<JwtService> jwt_srv,
                std::shared_ptr<SmsService> sms_srv);

    virtual ~AuthService()=default;
    
    // 发送验证码
    virtual Result<int32_t> SendVerifyCode(const std::string& mobile,
                                    SmsScene scene);

    // 注册
    virtual Result<AuthResult> Register(const std::string& mobile,
                                const std::string& verify_code,
                                const std::string& password,
                                const std::string& display_name);

    // 登录
    virtual Result<AuthResult> LoginByPassword(const std::string& mobile,
                                        const std::string& password);

    virtual Result<AuthResult> LoginByCode(const std::string& mobile,
                                    const std::string& verify_code);

    // 重置密码
    virtual Result<void> ResetPassword(const std::string& mobile,
                                const std::string& verify_code,
                                const std::string& new_password);
    
    // Token 管理
    virtual Result<TokenPair> RefreshToken(const std::string& refresh_token);
    virtual Result<void> Logout(const std::string& refresh_token);
    virtual Result<void> LogoutAll(const std::string& user_uuid);

    /// @brief 验证 Access Token 有效性（供其他微服务调用）
    /// @param access_token 待验证的访问令牌
    /// @return TokenValidation 包含有效性、用户ID、过期时间
    virtual Result<TokenValidationResult> ValidateAccessToken(const std::string& access_token);

private:
    // 检查登录失败次数（超过最大次数将被锁定）
    Result<void> CheckLoginFailedAttempts(const std::string& mobile);

    // 记录登录失败
    void RecordLoginFailure(const std::string& mobile);

    // 清除登录失败记录
    void ClearLoginFailure(const std::string& mobile);

    // 存储Refress Token
    Result<void> StoreRefreshToken(int64_t user_id, const std::string& refresh_token);
    
    std::shared_ptr<Config> config_;

    std::shared_ptr<UserDB> user_db_;               // user数据库操作句柄
    std::shared_ptr<RedisClient> redis_cli_;        // redis缓存句柄 
    std::shared_ptr<TokenRepository> token_repo_;   // token数据库操作句柄
    std::shared_ptr<JwtService> jwt_srv_;           // token服务句柄
    std::shared_ptr<SmsService> sms_srv_;           // Captcha服务句柄


};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/service/user_service.h ======================

#pragma once

#include <memory>
#include <string>

#include "config/config.h"
#include "common/result.h"
#include "db/user_db.h"
#include "auth/token_repository.h"
#include  "auth/sms_service.h"

namespace user_service{


struct ListUsersResult {
    std::vector<UserEntity> users;
    PageResult page_res;
};

/// @brief 用户操作类
class UserService {
public:
    UserService(std::shared_ptr<Config> config,
                std::shared_ptr<UserDB> user_db,
                std::shared_ptr<TokenRepository> token_repo,
                std::shared_ptr<SmsService> sms_srv);

    virtual ~UserService()=default; 

    // ==================== 当前用户操作 ====================
    
    /// @brief 获取用户信息，
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    virtual Result<UserEntity> GetCurrentUser(const std::string& user_uuid);
    
    /// @brief 更新用户信息（可选更新：后续扩展：avatar_url, email 等）
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    virtual Result<UserEntity> UpdateUser(const std::string& user_uuid,
                                    std::optional<std::string> display_name);
    


    /// @brief 修改密码（已登录，需要旧密码）
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    virtual Result<void> ChangePassword(const std::string& user_uuid,
                                const std::string& old_password,
                                const std::string& new_password);
    

    /// @brief 删除用户（注销账号）
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    virtual Result<void> DeleteUser(const std::string& user_uuid,
                            const std::string verify_code);

    // ==================== 管理员操作 ====================
    


    /// @brief 获取指定用户
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    virtual Result<UserEntity> GetUser(const std::string& user_uuid);

    /// @brief 获取用户列表（可按条件筛选）
    /// @param mobile_filter “电话号码”筛选条件
    /// @param disabled_filter “是否禁用”筛选条件
    /// @param page 返回的页数
    /// @param page_size 每页的大小
    /// @return 返回用户列表
    virtual Result<ListUsersResult> ListUsers(std::optional<std::string> mobile_filter,
                                        std::optional<bool> disabled_filter,
                                        int32_t page=1,
                                        int32_t page_size=20);

    /// @brief 禁用/启用用户
    /// @param user_uuid 由上层调用者从Access Token获取，并传入
    /// @param disabled 禁用/启用
    virtual Result<void> SetUserDisabled(const std::string& user_uuid, bool disabled);

private:
    std::shared_ptr<Config> config_;                // 配置句柄
    std::shared_ptr<UserDB> user_db_;               // 用户数据库句柄
    std::shared_ptr<TokenRepository> token_repo_;   // token数据库句柄
    std::shared_ptr<SmsService> sms_srv_;           // 验证码服务句柄
};


}

-----------------------------------------------------


// ====================== ./include/handlers/auth_handler.h ======================

#pragma once

#include <memory>
#include "pb_auth/auth.grpc.pb.h"
#include "service/auth_service.h"

namespace user_service {

// 前向声明
class AuthService;

class AuthHandler final : public ::pb_auth::AuthService::Service {
public:
    explicit AuthHandler(std::shared_ptr<AuthService> auth_service);

    // 验证码
    ::grpc::Status SendVerifyCode(::grpc::ServerContext* context, 
                                   const ::pb_auth::SendVerifyCodeRequest* request, 
                                   ::pb_auth::SendVerifyCodeResponse* response) override;
    
    // 注册
    ::grpc::Status Register(::grpc::ServerContext* context, 
                            const ::pb_auth::RegisterRequest* request, 
                            ::pb_auth::RegisterResponse* response) override;
    
    // 登录
    ::grpc::Status LoginByPassword(::grpc::ServerContext* context, 
                                    const ::pb_auth::LoginByPasswordRequest* request, 
                                    ::pb_auth::LoginByPasswordResponse* response) override;
    
    ::grpc::Status LoginByCode(::grpc::ServerContext* context, 
                                const ::pb_auth::LoginByCodeRequest* request, 
                                ::pb_auth::LoginByCodeResponse* response) override;
    
    // Token 管理
    ::grpc::Status RefreshToken(::grpc::ServerContext* context, 
                                 const ::pb_auth::RefreshTokenRequest* request, 
                                 ::pb_auth::RefreshTokenResponse* response) override;
    
    ::grpc::Status Logout(::grpc::ServerContext* context, 
                          const ::pb_auth::LogoutRequest* request, 
                          ::pb_auth::LogoutResponse* response) override;
    
    // 密码
    ::grpc::Status ResetPassword(::grpc::ServerContext* context, 
                                  const ::pb_auth::ResetPasswordRequest* request, 
                                  ::pb_auth::ResetPasswordResponse* response) override;
    
    // 内部验证
    ::grpc::Status ValidateToken(::grpc::ServerContext* context, 
                                  const ::pb_auth::ValidateTokenRequest* request, 
                                  ::pb_auth::ValidateTokenResponse* response) override;

private:
    std::shared_ptr<AuthService> auth_service_;
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/handlers/user_handler.h ======================

#pragma once

#include <memory>
#include "pb_user/user.grpc.pb.h"
#include "service/user_service.h"
#include "auth/jwt_service.h"  // 新增
#include "auth/jwt_authenticator.h"

namespace user_service {

class UserHandler final : public ::pb_user::UserService::Service {
public:
    UserHandler(std::shared_ptr<UserService> user_service,
        std::shared_ptr<Authenticator> authenticator);

    ::grpc::Status GetCurrentUser(::grpc::ServerContext* context, 
                                   const ::pb_user::GetCurrentUserRequest* request, 
                                   ::pb_user::GetCurrentUserResponse* response) override;
    ::grpc::Status UpdateUser(::grpc::ServerContext* context, 
                               const ::pb_user::UpdateUserRequest* request, 
                               ::pb_user::UpdateUserResponse* response) override;
    ::grpc::Status ChangePassword(::grpc::ServerContext* context, 
                                   const ::pb_user::ChangePasswordRequest* request, 
                                   ::pb_user::ChangePasswordResponse* response) override;
    ::grpc::Status DeleteUser(::grpc::ServerContext* context, 
                               const ::pb_user::DeleteUserRequest* request, 
                               ::pb_user::DeleteUserResponse* response) override;
    ::grpc::Status GetUser(::grpc::ServerContext* context, 
                            const ::pb_user::GetUserRequest* request, 
                            ::pb_user::GetUserResponse* response) override;
    ::grpc::Status ListUsers(::grpc::ServerContext* context, 
                              const ::pb_user::ListUsersRequest* request, 
                              ::pb_user::ListUsersResponse* response) override;

private:
    std::shared_ptr<UserService> user_service_;
    std::shared_ptr<Authenticator> authenticator_;
};

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/exception/client_exception.h ======================

// common/client_exception.h
#pragma once

#include <stdexcept>
#include <string>
#include "error_codes.h"

namespace user_service {

class ClientException : public std::runtime_error {
public:
    // 只有错误码
    explicit ClientException(ErrorCode code)
        : std::runtime_error(std::string(GetErrorMessage(code)))
        , code_(code) {}

    // 错误码 + 自定义消息
    ClientException(ErrorCode code, const std::string& detail)
        : std::runtime_error(std::string(GetErrorMessage(code)) + ": " + detail)
        , code_(code)
        , detail_(detail) {}

    ErrorCode code() const { return code_; }
    const std::string& detail() const { return detail_; }

private:
    ErrorCode code_;
    std::string detail_;
};

// 便捷抛出宏（可选）
#define THROW_CLIENT_ERROR(code) \
    throw ClientException(code)

#define THROW_CLIENT_ERROR_MSG(code, msg) \
    throw ClientException(code, msg)

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/exception/mysql_exception.h ======================

#pragma once

#include <stdexcept>
#include <string>

namespace user_service {

// MySQL 异常基类（带错误码）
class MySQLException : public std::runtime_error {
public:
    MySQLException(int mysql_errno, const std::string& msg)
        : std::runtime_error(msg), errno_(mysql_errno)
    {}

    int mysql_errno() const { return errno_; }

    // 是否可重试
    bool IsRetryable() const {
        return errno_ == 1213 ||    // 死锁
               errno_ == 2002 ||    // socket 错误
               errno_ == 2003 ||    // 无法连接主机
               errno_ == 2006 ||    // 服务断开
               errno_ == 2013;      // 连接丢失
    }

private:
    int errno_;
};

// 唯一键冲突异常（继承自 MySQLException）
class MySQLDuplicateKeyException : public MySQLException {
public:
    MySQLDuplicateKeyException(int mysql_errno, const std::string& msg)
        : MySQLException(mysql_errno, msg), key_name_(ParseKeyName(msg))
    {}

    // 获取冲突的索引名（如 "username"）
    const std::string& key_name() const { return key_name_; }

private:
    std::string key_name_;

    // 解析错误信息中的索引名（index_name）
    // MySQL 5.7+ 格式固定: "... for key 'table.index_name'"
    // 如："Duplicate entry 'alice' for key 'test.name'"
    static std::string ParseKeyName(const std::string& msg) {
        auto dot = msg.rfind('.');
        auto end = msg.rfind('\'');
        
        if (dot == std::string::npos || end == std::string::npos || dot >= end) {
            return "";  // 格式异常
        }
        
        return msg.substr(dot + 1, end - dot - 1);
    }
};


// SQL 构建异常（参数不匹配等，非 MySQL 错误）
class MySQLBuildException : public std::logic_error {
public:
    explicit MySQLBuildException(const std::string& msg)
        : std::logic_error(msg)
    {}
};

// SQL 结果集使用错误(MySQLResult中，非MySQL错误)
class MySQLResultException : public std::runtime_error {
public:
    explicit MySQLResultException(const std::string& msg)
        : std::runtime_error(msg) {}
};


// 辅助函数：根据错误码抛出对应异常
inline void ThrowMySQLException(unsigned int err_code, const std::string& err_msg) {
    if (err_code == 1062) {  // ER_DUP_ENTRY - 唯一键冲突
        throw MySQLDuplicateKeyException(static_cast<int>(err_code), err_msg);
    }
    throw MySQLException(static_cast<int>(err_code), err_msg);
}

}  // namespace user_service


-----------------------------------------------------


// ====================== ./include/exception/exception.h ======================

#pragma once

# include "mysql_exception.h"

-----------------------------------------------------


// ====================== ./include/discovery/service_instance.h ======================

// src/discovery/service_instance.h
#pragma once

#include <string>
#include <map>
#include "json/json.hpp"

namespace user_service {

/**
 * @brief 服务实例信息
 * 
 * @note services/user-service/192.168.1.10:50051
 *       - serivces：root_path
 *       - services/user-service：服务路径（永久节点） 
 *           - user-service：服务名
 *       - services/user-service/192.168.1.10:50051：实例节点（临时节点）
 *           - 192.168.1.10:50051：实例节点数据（存储用json格式）
 */
struct ServiceInstance {
    std::string service_name;   // 服务名，如 "user-service"
    std::string instance_id;    // 实例ID，如 "192.168.1.10:50051"
    std::string host;           // 主机地址
    int port;                   // 端口号
    int weight = 100;           // 权重（负载均衡用）
    std::map<std::string, std::string> metadata;  // 元数据
    
    /**
     * @brief 获取完整地址
     */
    std::string GetAddress() const {
        return host + ":" + std::to_string(port);
    }
    
    /**
     * @brief 序列化为 JSON
     */
    std::string ToJson() const {
        nlohmann::json j;
        j["service_name"] = service_name;
        j["instance_id"] = instance_id;
        j["host"] = host;
        j["port"] = port;
        j["weight"] = weight;
        j["metadata"] = metadata;
        return j.dump();
    }
    
    /**
     * @brief 从 JSON 反序列化
     */
    static ServiceInstance FromJson(const std::string& json_str) {
        ServiceInstance instance;
        try {
            auto j = nlohmann::json::parse(json_str);
            instance.service_name = j.value("service_name", "");
            instance.instance_id = j.value("instance_id", "");
            instance.host = j.value("host", "");
            instance.port = j.value("port", 0);
            instance.weight = j.value("weight", 100);
            if (j.contains("metadata")) {
                instance.metadata = j["metadata"].get<std::map<std::string, std::string>>();
            }
        } catch (...) {
            // 解析失败，返回空实例
        }
        return instance;
    }
    
    bool IsValid() const {
        return !host.empty() && port > 0;
    }
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/discovery/zk_client.h ======================

// src/discovery/zk_client.h
#pragma once

#include <zookeeper/zookeeper.h>
#include <string>
#include <vector>
#include <map>
#include <functional>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>

namespace user_service {

/**
 * @brief ZooKeeper 客户端封装
 * 
 * 提供 ZooKeeper 基本操作的 C++ 封装，包括：
 * - 节点的 CRUD 操作
 * - 子节点监听（Watch）
 * - 自动重连处理
 * 
 * 使用示例：
 * @code
 * ZooKeeperClient zk("127.0.0.1:2181", 15000);
 * if (zk.Connect()) {
 *     zk.CreateNode("/test", "data", false);
 * }
 * @endcode
 */
class ZooKeeperClient {
public:
    // 子节点变化回调类型
    using WatchCallback = std::function<void(const std::string& path)>;
    
    /**
     * @brief 构造函数
     * @param hosts ZK 服务器地址，格式: "ip1:port1,ip2:port2"
     * @param session_timeout_ms 会话超时时间（毫秒），推荐 10000-30000
     */
    ZooKeeperClient(const std::string& hosts, int session_timeout_ms = 30000);
    
    /**
     * @brief 析构函数，自动关闭连接
     */
    ~ZooKeeperClient();
    
    // 禁止拷贝
    ZooKeeperClient(const ZooKeeperClient&) = delete;
    ZooKeeperClient& operator=(const ZooKeeperClient&) = delete;
    
    // ============================================================================
    // 通用接口（gRPC 服务端 + gRPC 客户端 都使用）
    // ============================================================================
    
    /**
     * @brief 连接到 ZooKeeper
     * @param timeout_ms 连接超时时间（毫秒）
     * @return 连接成功返回 true
     */
    virtual bool Connect(int timeout_ms = 10000);
    
    /**
     * @brief 关闭连接
     */
    virtual void Close();
    
    /**
     * @brief 是否已连接
     */
    virtual bool IsConnected() const;
    
    // ============================================================================
    // gRPC 服务端使用的接口（服务注册）
    // ============================================================================
    
    /**
     * @brief 创建单个节点（f服务路径<父节点>必须存在）
     * @param path 节点路径
     * @param data 节点数据
     * @param ephemeral 是否为临时节点（会话断开自动删除）
     * @return 创建成功或节点已存在返回 true
     * 
     * @note 服务端用于：注册服务实例（创建临时节点）
     */
    virtual bool CreateNode(const std::string& path, const std::string& data, 
                    bool ephemeral = false);
    
    /**
     * @brief 递归创建整个路径（自动创建所有父节点）
     * @param path 服务根路径
     * @return 创建成功返回 true
     * 
     * @note 服务端用于：创建服务根路径 /services/user-service ——> 永久性节点
     * @note 服务注册的典型用法：
        void RegisterService(const std::string& service_name, 
                            const std::string& host, int port) {
            
            // 1. 先用 CreatePath 确保服务路径存在（持久节点）
            std::string service_path = "/services/" + service_name;
            zk_client->CreatePath(service_path);  // 递归创建 /services/user-service
            
            // 2. 再用 CreateNode 创建实例节点（临时节点）
            std::string instance_path = service_path + "/" + host + ":" + std::to_string(port);
            std::string data = R"({"host":")" + host + R"(","port":)" + std::to_string(port) + "}";
            zk_client->CreateNode(instance_path, data, true);  // ephemeral=true
        }

        ┌─────────────────────────────────────────────────────────────────────────────┐
        │  /services/user-service/192.168.1.100:50051                                 │
        │  ├────────┬────────────┬─────────────────────┤                              │
        │  │  持久  │    持久    │        临时          │                              │
        │  └────────┴────────────┴─────────────────────┘                              │
        │                                                                              │
        │  • /services          → 持久：服务根目录，永远存在                            │
        │  • /user-service      → 持久：服务名，永远存在                                │
        │  • /192.168.1.100:50051 → 临时：实例节点，服务下线自动删除                     │
        │                                                                              │
        │  好处：服务全部下线后，/services/user-service 还在，                           │
        │       客户端可以继续 Watch，等待新实例上线                                     │
        └─────────────────────────────────────────────────────────────────────────────┘
     */
    virtual bool CreateServicePath(const std::string& path);
    
    /**
     * @brief 删除节点
     * @param path 节点路径
     * @return 删除成功或节点不存在返回 true
     * 
     * @note 服务端用于：主动注销服务实例
     */
    virtual bool DeleteNode(const std::string& path);
    
    /**
     * @brief 检查节点是否存在
     * 
     * @note 服务端用于：检查路径是否已创建
     */
    virtual bool Exists(const std::string& path);
    
    /**
     * @brief 设置节点数据，用于更新已有节点数据
     * @param path 节点路径
     * @param data 新数据
     * @return 设置成功返回 true
     * 
     * @note 服务端用于：更新服务实例的元信息（如权重、状态）
     */
    virtual bool SetData(const std::string& path, const std::string& data);
    
    // ============================================================================
    // gRPC 客户端使用的接口（服务发现）
    // ============================================================================
    
    /**
     * @brief 获取节点数据
     * @param path 节点路径
     * @return 节点数据，失败返回空字符串
     * 
     * @note 客户端用于：读取服务实例信息（host、port、metadata）
     */
    virtual std::string GetData(const std::string& path);
    
    /**
     * @brief 获取子节点列表
     * @param path 父节点路径
     * @return 子节点名称列表（不含路径前缀）
     * 
     * @note 客户端用于：获取所有服务实例节点名
     */
    virtual std::vector<std::string> GetChildren(const std::string& path);
    
    /**
     * @brief 监听子节点变化
     * @param path 监听路径
     * @param callback 变化回调
     * 
     * @note ZK 的 watch 是一次性的，本方法会自动重新注册
     * @note 回调在 ZK 事件线程中执行，避免长时间阻塞
     * @note 客户端用于：监听服务实例上下线
     */
    virtual void WatchChildren(const std::string& path, WatchCallback callback);
    
    /**
     * @brief 取消监听
     * @param path 监听路径
     * 
     * @note 客户端用于：停止监听某个服务
     */
    virtual void UnwatchChildren(const std::string& path);
    
private:
    /**
     * @brief 全局 Watcher 回调（静态，供 C API 调用）
     * @param type 事件类型：ZOO_SESSION_EVENT（会话状态变更）、ZOO_CHILD_EVENT（子节点列表变更）等
     * @param state 会话状态：连接、断开、过期等（用于：ZOO_SESSION_EVENT）
     * @param path 子节点路径（用于：ZOO_CHILD_EVENT）
     * @param context 用户上下文，传入ZooKeeperClient*，方便在内部调用HandleXXX函数
     * @note 必须是static函数，因为是供 C API 调用，故不可以用普通成员函数
     */
    static void GlobalWatcher(zhandle_t* zh, int type, int state,
                              const char* path, void* context);
    
    /**
     * @brief 处理会话状态变化
     */
    void HandleSessionEvent(int state);
    
    /**
     * @brief 处理子节点变化事件
     */
    void HandleChildEvent(const std::string& path);
    
    /**
     * @brief 重新注册指定路径的 watch
     */
    void ResetWatch(const std::string& path);

    // ZooKeeper 句柄
    zhandle_t* zh_ = nullptr;
    
    // 配置
    std::string hosts_;
    int session_timeout_ms_;
    
    // 连接状态（原子变量，线程安全）
    std::atomic<bool> connected_{false};
    std::atomic<bool> closing_{false};  // 标记正在关闭
    
    // 连接等待
    std::mutex conn_mutex_;
    std::condition_variable conn_cv_;
    
    // Watch 回调管理（因为watch只能使用一次，所以会多次注册watch，故需要存储“子节点路径——>回调处理函数”）
    std::mutex watch_mutex_;
    std::map<std::string, WatchCallback> watches_;  // 回调map：子节点路径——>回调处理函数（客户端设置）
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/discovery/service_discovery.h ======================

#pragma once

#include "zk_client.h"
#include "service_instance.h"
#include <memory>
#include <vector>
#include <map>
#include <shared_mutex>
#include <functional>
#include <random>

namespace user_service {

/**
 * @brief 服务发现器（gRPC 客户端使用）
 * 
 * 功能：
 * - 从 ZooKeeper 获取服务实例列表
 * - 订阅服务变化（实例上线/下线）
 * - 本地缓存 + 自动更新
 * - 负载均衡选择实例
 * 
 * 使用示例：
 * @code
 * auto discovery = std::make_shared<ServiceDiscovery>(zk_client);
 * 
 * // 订阅服务变化
 * discovery->Subscribe("user-service", [](const std::string& service) {
 *     LOG_INFO("Service {} instances changed", service);
 * });
 * 
 * // 获取一个实例（负载均衡）
 * auto instance = discovery->SelectInstance("user-service");
 * if (instance) {
 *     auto channel = grpc::CreateChannel(instance->GetAddress(), ...);
 * }
 * @endcode
 */
class ServiceDiscovery {
public:
    // 服务变化回调
    using ServiceChangeCallback = std::function<void(const std::string& service_name)>;
    
    /**
     * @brief 构造函数
     * @param zk_client ZooKeeper 客户端（需要已连接）
     * @param root_path 服务根路径，默认 "/services"
     */
    explicit ServiceDiscovery(std::shared_ptr<ZooKeeperClient> zk_client,
                             const std::string& root_path = "/services");
    
    ~ServiceDiscovery();
    
    // 禁止拷贝
    ServiceDiscovery(const ServiceDiscovery&) = delete;
    ServiceDiscovery& operator=(const ServiceDiscovery&) = delete;
    
    /**
     * @brief 订阅服务变化（设置watch）
     * @param service_name 服务名称
     * @param callback 变化回调（可选）
     * 
     * @note 会立即拉取一次实例列表
     * @note 之后实例变化时自动更新本地缓存并触发回调
     */
    void Subscribe(const std::string& service_name, 
                   ServiceChangeCallback callback = nullptr);
    
    /**
     * @brief 取消订阅（取消watch）
     * @param service_name 服务名称
     */
    void Unsubscribe(const std::string& service_name);
    
    /**
     * @brief 获取服务的所有实例（业务一个服务在多个ip，或多个port上运行）
     * @param service_name 服务名称
     * @return 实例列表（可能为空）
     */
    std::vector<ServiceInstance> GetInstances(const std::string& service_name);
    
    /**
     * @brief 选择一个实例（随机负载均衡，自己实现）
     * @param service_name 服务名称
     * @return 实例指针，无可用实例返回 nullptr
     */
    std::shared_ptr<ServiceInstance> SelectInstance(const std::string& service_name);
    
    /**
     * @brief 选择一个实例（加权随机，自己实现）
     * @param service_name 服务名称
     * @return 实例指针，无可用实例返回 nullptr
     */
    std::shared_ptr<ServiceInstance> SelectInstanceWeighted(const std::string& service_name);
    
private:
    /**
     * @brief 刷新指定服务的实例列表
     */
    void RefreshInstances(const std::string& service_name);
    
    /**
     * @brief 处理子节点变化（Watch 回调）
     */
    void OnChildrenChanged(const std::string& path);
    
    /**
     * @brief 从路径提取服务名
     * /services/user-service -> user-service
     */
    std::string ExtractServiceName(const std::string& path) const;
    
    /**
     * @brief 构建服务路径
     */
    std::string BuildServicePath(const std::string& service_name) const;
    

    std::shared_ptr<ZooKeeperClient> zk_client_;    // zookeeper客户端句柄
    std::string root_path_;                         // 服务根路径，默认 "/services"
    
    // 服务实例缓存：service_name -> instances
    mutable std::shared_mutex cache_mutex_;
    std::map<std::string, std::vector<ServiceInstance>> instance_cache_;
    
    // 服务变化回调：service_name -> callback
    mutable std::mutex callback_mutex_;
    std::map<std::string, ServiceChangeCallback> callbacks_;
    
    // 随机数生成器（负载均衡用）
    mutable std::mt19937 rng_{std::random_device{}()};
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/discovery/service_registry.h ======================

#pragma once

#include <memory>
#include <thread>
#include <atomic>
#include "zk_client.h"
#include "service_instance.h"

namespace user_service {

/**
 * @brief 服务注册器（gRPC 服务端使用）——> 一个进程 = 一个服务 = 一个服务注册器
 * 
 * 功能：
 * - 将服务实例注册到 ZooKeeper
 * - 自动心跳保活（通过临时节点实现）
 * - 优雅下线
 * 
 * 使用示例：
 * @code
 * auto registry = std::make_shared<ServiceRegistry>(zk_client);
 * ServiceInstance instance;
 * instance.service_name = "user-service";
 * instance.host = "192.168.1.10";
 * instance.port = 50051;
 * registry->Register(instance);
 * // ... 服务运行 ...
 * registry->Unregister();
 * @endcode
 */
class ServiceRegistry {
public:
    /**
     * @brief 构造函数
     * @param zk_client ZooKeeper 客户端（需要已连接）
     * @param root_path 服务根路径，默认 "/services"
     */
    explicit ServiceRegistry(std::shared_ptr<ZooKeeperClient> zk_client,
                            const std::string& root_path = "/services");
    
    ~ServiceRegistry();
    
    // 禁止拷贝
    ServiceRegistry(const ServiceRegistry&) = delete;
    ServiceRegistry& operator=(const ServiceRegistry&) = delete;
    
    /**
     * @brief 注册服务实例
     * @param instance 服务实例信息
     * @return 注册成功返回 true
     * 
     * @note 会自动创建父路径
     * @note 创建临时节点，服务下线时自动删除
     */
    bool Register(const ServiceInstance& instance);
    
    /**
     * @brief 注销服务实例
     * @return 注销成功返回 true
     */
    bool Unregister();
    
    /**
     * @brief 更新服务实例信息
     * @param instance 新的实例信息
     * @return 更新成功返回 true
     */
    bool Update(const ServiceInstance& instance);
    
    /**
     * @brief 是否已注册
     */
    bool IsRegistered() const { return registered_.load(); }
    
private:
    /**
     * @brief 构建实例节点路径
     * 格式：/services/{service_name}/{instance_id}
     */
    std::string BuildInstancePath(const ServiceInstance& instance) const;
    
    /**
     * @brief 构建服务路径
     * 格式：/services/{service_name}
     */
    std::string BuildServicePath(const std::string& service_name) const;
    
private:
    

    std::shared_ptr<ZooKeeperClient> zk_client_;    // ZooKeeper 客户端（需要已连接）
    std::string root_path_;                         // 服务根路径，默认 "/services"
    
    // 当前注册的实例信息（微服务架构中：一个进程 = 一个服务实例）
    ServiceInstance current_instance_;
    std::string current_path_;
    std::atomic<bool> registered_{false};
    
    mutable std::mutex mutex_;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/pool/connection_pool.h ======================

#pragma once

#include <memory>
#include <deque>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <functional>
#include <stdexcept>
#include <type_traits>
#include "../common/logger.h"
#include "config/config.h"

namespace user_service {

// ==================== 前置声明 ====================

class MySQLConnection;
class RedisConnection;

// ==================== 编译期类型推导 ====================

/**
 * @brief 连接类型到配置类型的映射（主模板）
 * 
 * 通过模板特化实现「连接类型 T → 配置类型 Config」的编译期推导，
 * 避免手动传递 Config 模板参数，消除「T 与 Config 不匹配」的风险。
 * 
 * @tparam T 连接类型
 */
template<typename>
struct ConnectionConfig;

/// @brief MySQLConnection 对应 MySQLConfig
template<>
struct ConnectionConfig<MySQLConnection> { 
    using type = user_service::MySQLConfig; 
};

/// @brief RedisConnection 对应 RedisConfig
template<>
struct ConnectionConfig<RedisConnection> { 
    using type = user_service::RedisConfig; 
};

/**
 * @brief 配置类型别名（简化使用）
 * @tparam T 连接类型
 * 
 * @example
 * @code
 *   Config_t<MySQLConnection>  // 等价于 MySQLConfig
 *   Config_t<RedisConnection>  // 等价于 RedisConfig
 * @endcode
 */
template<typename T>
using Config_t = typename ConnectionConfig<T>::type;

/**
 * @brief 用于 static_assert 的编译期 false 值
 * 
 * 直接写 static_assert(false, ...) 会在模板定义时就触发错误，
 * 而 always_false_v<T> 依赖模板参数 T，只有实例化时才会触发。
 */
template<typename>
inline constexpr bool always_false_v = false;


// ==================== 连接池模板类 ====================

/**
 * @brief 泛型数据库连接池
 * 
 * 提供线程安全的连接获取与归还机制，支持连接有效性检测和自动重建。
 * 使用 RAII 守卫类 ConnectionGuard 自动管理连接生命周期。
 * 
 * @tparam T 连接类型，需满足以下要求：
 *           - 提供 Valid() 方法判断连接有效性
 *           - 在 ConnectionConfig 中有对应的配置类型特化
 * 
 * @note 线程安全：所有公共方法均可在多线程环境下安全调用
 * 
 * @example
 * @code
 *   // 创建 MySQL 连接池
 *   auto pool = std::make_shared<TemplateConnectionPool<MySQLConnection>>(
 *       global_config,
 *       [](const MySQLConfig& cfg) {
 *           return std::make_unique<MySQLConnection>(cfg);
 *       }
 *   );
 *   
 *   // 使用连接（RAII 自动归还）
 *   {
 *       auto guard = pool->CreateConnection();
 *       auto result = guard->Query("SELECT * FROM users");
 *   } // guard 析构时自动归还连接
 * @endcode
 */
template<typename T>
class TemplateConnectionPool {
public:
    /// 连接智能指针类型
    using ConnectionPtr = std::unique_ptr<T>;
    
    /// 配置类型（编译期自动推导）
    using Config = Config_t<T>;
    
    /// 配置智能指针类型（const 保证配置不可变）
    using ConfigPtr = std::shared_ptr<const Config>;
    
    /// 连接创建回调函数类型
    using CreateFunc = std::function<ConnectionPtr(const Config&)>;

    /**
     * @brief 构造函数，初始化连接池
     * 
     * @param global_config 全局配置对象，包含各数据库的子配置
     * @param func 连接创建回调函数
     * 
     * @throws std::invalid_argument global_config 为空或 func 无效
     * @throws std::runtime_error 初始化连接失败
     * 
     * @note 构造时会立即创建 pool_size 个连接
     */
    TemplateConnectionPool(std::shared_ptr<user_service::Config> global_config, CreateFunc func)
        : createConnFunc_(std::move(func))
    {
        // 参数校验（快速失败原则）
        if (!global_config) {
            throw std::invalid_argument("TemplateConnectionPool: global_config is nullptr");
        }
        if (!createConnFunc_) {
            throw std::invalid_argument("TemplateConnectionPool: createConnFunc is empty");
        }

        // 从全局配置中提取对应类型的子配置
        ExtractSubConfig(global_config);
        
        // 预创建连接填充池
        InitPool();
    }

    /**
     * @brief 连接守卫类（RAII 模式）
     * 
     * 自动管理连接的获取与归还，确保连接不会泄漏。
     * 析构时自动将连接归还到池中。
     * 
     * @note 禁止拷贝，仅支持移动
     * @note 支持智能指针风格的 -> 和 * 操作符
     * 
     * @example
     * @code
     *   auto guard = pool.CreateConnection();
     *   guard->Query("SELECT 1");  // 通过 -> 访问连接
     *   (*guard).Execute("...");   // 通过 * 访问连接
     * @endcode
     */
    class ConnectionGuard {
    public:
        /**
         * @brief 构造函数，从池中获取连接
         * @param pool 连接池引用
         * @throws std::runtime_error 获取连接失败
         */
        ConnectionGuard(TemplateConnectionPool& pool)
            : pool_(pool)
        {
            conn_ = std::move(pool_.Acquire());
            if (!conn_) {
                throw std::runtime_error("Failed to acquire connection in ConnectionGuard");
            }
        }

        /// @name 禁用拷贝和拷贝赋值
        /// @{
        ConnectionGuard(const ConnectionGuard&) = delete;
        ConnectionGuard& operator=(const ConnectionGuard&) = delete;
        ConnectionGuard& operator=(ConnectionGuard&&) = delete;
        /// @}

        /**
         * @brief 移动构造函数
         * @param other 被移动的对象
         * @note 移动后 other.conn_ 置为 nullptr，防止析构时重复归还
         */
        ConnectionGuard(ConnectionGuard&& other) noexcept
            : pool_(other.pool_)
        {
            if (this == &other) return;
            conn_ = std::move(other.conn_);
            other.conn_ = nullptr;  // 防止双重释放
        }

        /**
         * @brief 获取原始连接指针
         * @return T* 连接指针，可能为 nullptr
         */
        T* get() const noexcept {
            return conn_.get();
        }

        /**
         * @brief 箭头运算符重载，支持 guard->method() 语法
         * @return T* 连接指针
         * @throws std::runtime_error 连接为空
         */
        T* operator->() {
            if (!conn_) throw std::runtime_error("Connection is null in ConnectionGuard");
            return conn_.get();
        }

        /**
         * @brief 解引用运算符重载，支持 (*guard).method() 语法
         * @return T& 连接引用
         * @throws std::runtime_error 连接为空
         */
        T& operator*() {
            if (!conn_) throw std::runtime_error("Connection is null in ConnectionGuard");
            return *conn_;
        }

        /**
         * @brief 析构函数，自动归还连接到池中
         */
        ~ConnectionGuard() {
            if (conn_) {
                pool_.Release(std::move(conn_));
                conn_ = nullptr;
            }
        }

    private:
        TemplateConnectionPool& pool_;  ///< 所属连接池的引用
        ConnectionPtr conn_;            ///< 持有的连接
    };

    /**
     * @brief 创建连接守卫（推荐使用方式）
     * 
     * @return ConnectionGuard RAII 守卫对象
     * @throws std::runtime_error 获取连接失败
     * 
     * @example
     * @code
     *   auto guard = pool.CreateConnection();
     *   // 使用 guard->... 访问连接
     * @endcode
     */
    ConnectionGuard CreateConnection() {
        return ConnectionGuard(*this);
    }

private:
    /**
     * @brief 从全局配置中提取对应类型的子配置
     * 
     * 使用 if constexpr 在编译期选择正确的配置字段，
     * 避免运行时类型判断的开销。
     * 
     * @param global_config 全局配置对象
     */
    void ExtractSubConfig(const std::shared_ptr<user_service::Config> global_config) {
        /*
         * if constexpr：编译期条件分支
         * - 只有匹配的分支会被编译
         * - 不匹配的分支即使语法错误也不会报错（因为不会实例化）
         */
        if constexpr (std::is_same_v<T, MySQLConnection>) {
            config_ = std::make_shared<const Config>(global_config->mysql);
        } else if constexpr (std::is_same_v<T, RedisConnection>) {
            config_ = std::make_shared<const Config>(global_config->redis);
        } else {
            // 编译期断言：不支持的连接类型
            // 注意：不能直接 static_assert(false, ...)，否则模板定义时就报错
            static_assert(always_false_v<T>, "Unsupported connection type, no matching sub-config");
        }
    }

    /**
     * @brief 初始化连接池
     * 
     * 根据配置的 pool_size 预创建指定数量的连接。
     * 
     * @throws std::runtime_error 配置为空或创建连接失败
     */
    void InitPool() {
        // 防御性检查（理论上不会为空，但多一层保护）
        if (!config_) {
            throw std::runtime_error("TemplateConnectionPool: config_ is nullptr");
        }
        
        int poolSize = config_->GetPoolSize();
        for (int i = 0; i < poolSize; ++i) {
            auto conn = std::move(createConnFunc_(*config_));
            if (!conn) {
                throw std::runtime_error("Failed to create connection during pool initialization");
            }
            pool_.push_back(std::move(conn));
        }
    }

    /**
     * @brief 从池中获取一个连接
     * 
     * 如果池为空，最多等待 5 秒。获取后会检测连接有效性，
     * 无效连接会尝试重建。
     * 
     * @return ConnectionPtr 连接指针，失败返回 nullptr
     * 
     * @note 线程安全
     * @note 超时时间硬编码为 5 秒，可根据需要改为配置项
     */
    ConnectionPtr Acquire() {
        std::unique_lock<std::mutex> lk(mutex_);
        
        // 带超时的等待：避免无限阻塞
        bool ret = cond_.wait_for(lk, std::chrono::seconds(5), [this]() {
            return !pool_.empty();
        });
        
        if (!ret) {
            LOG_ERROR("Acquire connection timeout after 5 seconds");
            return nullptr;
        }

        // 双重校验：防止虚假唤醒导致的空队列访问
        if (pool_.empty()) {
            LOG_ERROR("Connection pool is empty after wake up (spurious wakeup?)");
            return nullptr;
        }

        auto conn = std::move(pool_.front());
        pool_.pop_front();

        // 连接有效性检测：长时间空闲的连接可能已断开
        if (!conn->Valid()) {
            LOG_WARN("Acquired invalid connection, attempting rebuild");
            conn = createConnFunc_(*config_);
            if (!conn) {
                LOG_ERROR("Failed to rebuild invalid connection");
                return nullptr;
            }
        }

        return conn;
    }

    /**
     * @brief 将连接归还到池中
     * 
     * 归还前会检测连接有效性，无效连接会尝试重建。
     * 
     * @param conn 要归还的连接
     * 
     * @note 线程安全
     * @note 重建失败时不会抛异常，仅记录日志（析构函数中调用，不能抛异常）
     */
    void Release(ConnectionPtr conn) {
        std::unique_lock<std::mutex> lk(mutex_);
        
        // 检测并重建无效连接
        if (!conn || !conn->Valid()) {
            conn = std::move(createConnFunc_(*config_));
            // 重建失败：静默处理（析构函数中调用，不能抛异常）
            if (!conn) {
                LOG_ERROR("Failed to rebuild connection during release, connection lost");
                return;
            }
        }
        
        pool_.push_back(std::move(conn));
        cond_.notify_one();  // 唤醒一个等待的线程
    }

private:
    std::deque<ConnectionPtr> pool_;  ///< 连接队列（双端队列，支持高效头部弹出）
    ConfigPtr config_;                ///< 数据库配置（const 保证不可变）
    std::mutex mutex_;                ///< 互斥锁（保护 pool_ 的并发访问）
    std::condition_variable cond_;    ///< 条件变量（用于等待可用连接）
    CreateFunc createConnFunc_;       ///< 连接创建回调函数
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/config/config.h ======================

// src/config/config.h
#pragma once

#include <string>
#include <chrono>
#include <optional>
namespace user_service {

// ==================================== gRPC服务 配置 ===============================

struct ServerConfig {
    std::string host = "0.0.0.0";
    int grpc_port = 50051;
    int metrics_port = 9090; //独立端口暴露监控指标

    std::string ToString() const;
};

// ==================================== Mysql 配置 ===============================

struct MySQLConfig {
    //基本连接信息
    std::string host = "localhost";
    int port = 3306;
    std::string database = "user_service";
    std::string username = "root";
    std::string password = "";
    int pool_size = 10;

    //超时配置(ms)
    std::optional<unsigned int> connection_timeout_ms;
    std::optional<unsigned int> read_timeout_ms;
    std::optional<unsigned int> write_timeout_ms;
    
    //重试配置
    unsigned int max_retries=3; 
    unsigned int retry_interval_ms=1000; //重试间隔（ms）

    //其它配置
    std::optional<bool> auto_reconnect;
    std::string charset= "utf8mb4";

    int GetPoolSize() const{ return pool_size;}

    std::string ToString() const;
};

// ==================================== Redis 配置 ===============================

struct RedisConfig {
    std::string host = "localhost";
    int port = 6379;
    std::string password = "";
    int db = 0;
    int pool_size = 5;

    std::optional<unsigned int> connect_timeout_ms; //连接超时
    std::optional<unsigned int> socket_timeout_ms;  //读写超时
    
    unsigned int wait_timeout_ms=100;
    int GetPoolSize()const {return pool_size;}

    std::string ToString() const;
};

// ==================================== Logger 配置 ===============================

struct LogConfig {
    std::string level = "info";
    std::string path = "./logs";
    std::string filename = "user-service.log";
    size_t max_size = 10 * 1024 * 1024;  // 10MB
    int max_files = 5;
    bool console_output = true;

    std::string ToString() const;
};


// ==================================== ZooKeeper 配置 ===============================

struct ZooKeeperConfig {
    // ==================== 连接配置 ====================
    std::string hosts = "127.0.0.1:2181";       // ZK 服务器地址，多个用逗号分隔
                                                 // 例如: "192.168.1.10:2181,192.168.1.11:2181"
    int session_timeout_ms = 15000;              // 会话超时（毫秒），推荐 10000-30000
    int connect_timeout_ms = 10000;              // 连接超时（毫秒）
    
    // ==================== 服务注册配置（服务端使用） ====================
    std::string root_path = "/services";         // 服务根路径
    std::string service_name = "user-service";   // 当前服务名称
    
    // ==================== 开关 ====================
    bool enabled = true;                         // 是否启用服务注册/发现
    bool register_self = true;                   // 是否注册自身（服务端设为true，纯客户端设为false）
    
    // ==================== 元数据 ====================
    int weight = 100;                            // 服务权重（负载均衡用）
    std::string region = "";                     // 区域标识，如 "cn-east"
    std::string zone = "";                       // 可用区，如 "zone-a"
    std::string version = "1.0.0";               // 服务版本
    
    /**
     * @brief 获取完整的服务路径
     * @return 例如 "/services/user-service"
     */
    std::string GetServicePath() const {
        return root_path + "/" + service_name;
    }
    
    std::string ToString() const;
};



// ==================================== 业务相关 ===============================

// token配置
struct SecurityConfig {
    std::string jwt_secret = "your-secret-key";
    std::string jwt_issuer = "user-service";        
    int access_token_ttl_seconds{900};              // access_token有效期：15分钟
    int refresh_token_ttl_seconds{604800};          // refresh_token有效期：7天

    std::string ToString() const;
};

// 验证码配置
struct SmsConfig{
    // 验证码长度
    int code_len=6;

    // 验证码有效期（秒）
    int code_ttl_seconds=300;       // 5分钟有效期

    // 发送间隔（秒）- 防止频繁发送（可以覆盖之前的验证码，方便用户没有收到验证码时快速重新获取）
    int send_interval_seconds=60;    // 60秒才能重发
    
    // 最大验证错误次数
    int max_retry_count=5;          

    // 错误次数记录有效期（秒）
    int retry_ttl_seconds=300;      // 3分钟 

    // 失败次数超过max_retry_count，进行锁定（避免被暴力破解）
    int lock_seconds = 1800;            // 锁定30分钟

    std::string ToString() const;
};

// ============ 登录安全配置 ============
struct LoginConfig {
    // ==================== 登录失败锁定策略 ====================
    int max_failed_attempts = 5;        // 最大登录失败次数
    int failed_attempts_window = 900;   // 失败计数窗口期（秒），15分钟
    int lock_duration_seconds = 1800;   // 锁定时长（秒），30分钟
    
    // ==================== 会话管理 ====================
    int max_sessions_per_user = 5;      // 单用户最大同时登录设备数
    bool kick_oldest_session = true;    // 超出时是否踢掉最旧的会话（false则拒绝新登录）
    
    // ==================== 登录方式开关 ====================
    bool enable_password_login = true;  // 允许密码登录
    bool enable_sms_login = true;       // 允许验证码登录
    
    // ==================== 图形验证码 ====================
    bool require_captcha = false;                   // 是否强制图形验证码
    int captcha_after_failed_attempts = 3;          // 失败N次后需要图形验证码

    std::string ToString() const;
};

// ============ 密码策略配置 ============
struct PasswordPolicyConfig {
    int min_length = 8;                 // 最小长度
    int max_length = 32;                // 最大长度
    bool require_uppercase = false;     // 需要大写字母
    bool require_lowercase = false;     // 需要小写字母
    bool require_digit = true;          // 需要数字
    bool require_special_char = false;  // 需要特殊字符
    
    // 密码过期（0 = 不过期）
    int expire_days = 0;                
    
    // 历史密码检查（0 = 不检查）
    int history_count = 0;              // 不能与最近N个密码相同

    std::string ToString() const;
};

struct Config {
    ServerConfig server;
    MySQLConfig mysql;
    RedisConfig redis;
    LogConfig log;
    ZooKeeperConfig zookeeper;
    
    // 业务配置
    SecurityConfig security;
    SmsConfig sms;
    LoginConfig login;                  // 登录安全策略
    PasswordPolicyConfig password;      // 密码强度策略
    
    // 从 YAML 文件加载配置
    static Config LoadFromFile(const std::string& path);
    
    // 从环境变量覆盖配置
    void LoadFromEnv();

    std::string ToString() const;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/server/grpc_server.h ======================

#pragma once

#include <memory>
#include <string>
#include <atomic>
#include <thread>
#include <functional>
#include <grpcpp/grpcpp.h>
#include <grpcpp/health_check_service_interface.h>

#include "config/config.h"
#include "handlers/auth_handler.h"
#include "handlers/user_handler.h"
#include "service/auth_service.h"
#include "service/user_service.h"
#include "discovery/service_registry.h"
#include "auth/token_cleanup_task.h"

namespace user_service {

/**
 * @brief gRPC 服务器封装类
 * 
 * 提供统一的服务器生命周期管理：
 * - 初始化所有依赖组件
 * - 启动 gRPC 服务
 * - 注册到服务发现
 * - 优雅关闭
 * 
 * @example
 * @code
 *   auto config = Config::LoadFromFile("config.yaml");
 *   GrpcServer server(std::make_shared<Config>(config));
 *   
 *   if (!server.Initialize()) {
 *       return 1;
 *   }
 *   
 *   server.Run();  // 阻塞直到收到关闭信号
 * @endcode
 */
class GrpcServer {
public:
    using MySQLPool = TemplateConnectionPool<MySQLConnection>;
    
    // 关闭回调类型
    using ShutdownCallback = std::function<void()>;

    /**
     * @brief 构造函数
     * @param config 配置对象
     */
    explicit GrpcServer(std::shared_ptr<Config> config);
    
    /**
     * @brief 析构函数，确保资源释放
     */
    ~GrpcServer();

    // 禁止拷贝和移动
    GrpcServer(const GrpcServer&) = delete;
    GrpcServer& operator=(const GrpcServer&) = delete;
    GrpcServer(GrpcServer&&) = delete;
    GrpcServer& operator=(GrpcServer&&) = delete;

    /**
     * @brief 初始化所有组件
     * @return 初始化成功返回 true
     * 
     * 初始化顺序：
     * 1. MySQL 连接池
     * 2. Redis 客户端
     * 3. Repository 层
     * 4. Service 层
     * 5. Handler 层
     * 6. ZooKeeper 客户端（可选）
     */
    bool Initialize();

    /**
     * @brief 启动服务器（阻塞）
     * 
     * 调用后会阻塞直到：
     * - 收到 SIGINT/SIGTERM 信号
     * - 调用 Shutdown() 方法
     */
    void Run();

    /**
     * @brief 异步启动服务器（非阻塞）
     * @return 启动成功返回 true
     */
    bool Start();

    /**
     * @brief 请求关闭服务器
     * @param deadline 关闭超时时间，默认 5 秒
     */
    void Shutdown(std::chrono::milliseconds deadline = std::chrono::milliseconds(5000));

    /**
     * @brief 等待服务器关闭
     */
    void Wait();

    /**
     * @brief 检查服务器是否正在运行
     */
    bool IsRunning() const { return running_.load(); }

    /**
     * @brief 获取监听地址
     */
    std::string GetAddress() const;

    /**
     * @brief 设置关闭回调
     */
    void SetShutdownCallback(ShutdownCallback callback) {
        shutdown_callback_ = std::move(callback);
    }

    // ==================== 组件访问器（用于测试或扩展）====================
    
    std::shared_ptr<AuthService> GetAuthService() const { return auth_service_; }
    std::shared_ptr<UserService> GetUserService() const { return user_service_; }
    std::shared_ptr<Config> GetConfig() const { return config_; }

private:
    /**
     * @brief 初始化基础设施（MySQL、Redis）
     */
    bool InitInfrastructure();

    /**
     * @brief 初始化 Repository 层
     */
    bool InitRepositories();

    /**
     * @brief 初始化 Service 层
     */
    bool InitServices();

    /**
     * @brief 初始化 Handler 层
     */
    bool InitHandlers();

    /**
     * @brief 初始化服务发现
     */
    bool InitServiceDiscovery();

    /**
     * @brief 注册到 ZooKeeper
     */
    bool RegisterToZooKeeper();

    /**
     * @brief 从 ZooKeeper 注销
     */
    void UnregisterFromZooKeeper();

    /**
     * @brief 关闭监控线程
     */
    void ShutdownMonitor();

private:
    // 配置
    std::shared_ptr<Config> config_;

    // gRPC 服务器
    std::unique_ptr<grpc::Server> server_;
    std::atomic<bool> running_{false};
    std::atomic<bool> shutdown_requested_{false};

    // 基础设施
    std::shared_ptr<MySQLPool> mysql_pool_;
    std::shared_ptr<RedisClient> redis_client_;

    // Repository 层
    std::shared_ptr<UserDB> user_db_;
    std::shared_ptr<TokenRepository> token_repo_;

    // Service 层
    std::shared_ptr<JwtService> jwt_service_;
    std::shared_ptr<SmsService> sms_service_;
    std::shared_ptr<AuthService> auth_service_;
    std::shared_ptr<UserService> user_service_;

    // Handler 层
    std::shared_ptr<Authenticator> authenticator_;
    std::unique_ptr<AuthHandler> auth_handler_;
    std::unique_ptr<UserHandler> user_handler_;

    // 服务发现
    std::shared_ptr<ZooKeeperClient> zk_client_;
    std::shared_ptr<ServiceRegistry> service_registry_;

    // 后台任务
    std::shared_ptr<TokenCleanupTask> token_cleanup_task_;

    // 回调
    ShutdownCallback shutdown_callback_;

    // 监控线程
    std::thread shutdown_monitor_thread_;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/server/server_builder.h ======================

#pragma once

#include <memory>
#include <string>
#include <functional>
#include <optional>
#include "server/grpc_server.h"
#include "config/config.h"

namespace user_service {

/**
 * @brief 服务器构建器（Builder 模式）
 * 
 * 提供流畅的 API 来配置和创建 gRPC 服务器，支持：
 * - 从配置文件/对象加载配置
 * - 运行时覆盖配置项
 * - ZooKeeper 服务注册
 * - 环境变量覆盖
 * 
 * ============================================================================
 * 架构说明
 * ============================================================================
 * 
 * 在微服务架构中，通常有多个服务：
 * 
 *   ┌─────────────────────────────────────────────────────────────────────────┐
 *   │                          ZooKeeper                                      │
 *   │                                                                         │
 *   │   /services                                                             │
 *   │       ├── /auth-service                    ← 认证服务注册路径            │
 *   │       │       ├── 192.168.1.10:50051       ← 实例1（临时节点）           │
 *   │       │       └── 192.168.1.11:50051       ← 实例2（临时节点）           │
 *   │       │                                                                 │
 *   │       ├── /user-service                    ← 用户服务注册路径            │
 *   │       │       ├── 192.168.1.10:50052       ← 实例1                      │
 *   │       │       └── 192.168.1.12:50052       ← 实例2                      │
 *   │       │                                                                 │
 *   │       └── /order-service                   ← 其他服务...                 │
 *   │               └── ...                                                   │
 *   └─────────────────────────────────────────────────────────────────────────┘
 * 
 * 每个服务可以有多个实例（水平扩展），通过 ServerBuilder 配置：
 * - service_name: 决定注册到哪个路径（如 "auth-service" 或 "user-service"）
 * - host:port: 决定实例节点的名称
 * 
 * ============================================================================
 * 使用示例
 * ============================================================================
 * 
 * @example 示例1：启动认证服务（auth-service）
 * @code
 *   // auth_service_main.cpp
 *   auto server = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .WithPort(50051)                           // gRPC 监听端口
 *       .WithServiceName("auth-service")           // ← 注册为 auth-service
 *       .EnableServiceDiscovery(true)              // 启用 ZooKeeper 注册
 *       .Build();
 *   
 *   // 会在 ZooKeeper 创建：/services/auth-service/192.168.1.10:50051
 *   server->Run();
 * @endcode
 * 
 * @example 示例2：启动用户服务（user-service）
 * @code
 *   // user_service_main.cpp
 *   auto server = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .WithPort(50052)                           // 不同端口
 *       .WithServiceName("user-service")           // ← 注册为 user-service
 *       .EnableServiceDiscovery(true)
 *       .Build();
 *   
 *   // 会在 ZooKeeper 创建：/services/user-service/192.168.1.10:50052
 *   server->Run();
 * @endcode
 * 
 * @example 示例3：同一服务的多实例部署
 * @code
 *   // 实例1（机器A）
 *   auto server1 = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .WithHost("192.168.1.10")
 *       .WithPort(50051)
 *       .WithServiceName("user-service")
 *       .Build();
 *   
 *   // 实例2（机器B）
 *   auto server2 = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .WithHost("192.168.1.11")
 *       .WithPort(50051)
 *       .WithServiceName("user-service")
 *       .Build();
 *   
 *   // ZooKeeper 中会有：
 *   // /services/user-service/192.168.1.10:50051
 *   // /services/user-service/192.168.1.11:50051
 * @endcode
 * 
 * @example 示例4：Docker/K8s 环境（通过环境变量配置）
 * @code
 *   // 环境变量：
 *   //   SERVICE_NAME=user-service
 *   //   GRPC_PORT=50051
 *   //   ZK_HOSTS=zookeeper:2181
 *   
 *   auto server = ServerBuilder()
 *       .WithConfigFile("/app/config.yaml")
 *       .LoadFromEnvironment()                     // ← 环境变量会覆盖配置文件
 *       .Build();
 * @endcode
 * 
 * @example 示例5：开发模式（禁用服务发现）
 * @code
 *   auto server = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .EnableServiceDiscovery(false)             // ← 不连接 ZooKeeper
 *       .Build();
 * @endcode
 * 
 * @example 示例6：设置关闭回调（用于资源清理）
 * @code
 *   auto server = ServerBuilder()
 *       .WithConfigFile("config.yaml")
 *       .OnShutdown([]() {
 *           LOG_INFO("Server is shutting down, cleaning up...");
 *           // 清理资源、发送告警等
 *       })
 *       .Build();
 * @endcode
 * 
 * ============================================================================
 * 配置优先级（从低到高）
 * ============================================================================
 * 
 *   1. 配置文件默认值（config.yaml）
 *   2. 环境变量覆盖（LoadFromEnvironment）
 *   3. Builder 方法覆盖（WithPort、WithServiceName 等）
 * 
 * 即：WithPort(50052) 会覆盖环境变量和配置文件中的端口设置
 */
class ServerBuilder {
public:
    ServerBuilder() = default;

    // ========================================================================
    // 配置加载方法
    // ========================================================================

    /**
     * @brief 从 YAML 配置文件加载配置
     * 
     * @param path 配置文件路径（支持相对路径和绝对路径）
     * @return ServerBuilder& 返回自身，支持链式调用
     * 
     * @throws std::runtime_error 配置文件不存在或解析失败
     * 
     * @note 配置文件格式示例（config.yaml）：
     * @code{.yaml}
     *   server:
     *     host: "0.0.0.0"
     *     grpc_port: 50051
     *   
     *   zookeeper:
     *     enabled: true
     *     hosts: "127.0.0.1:2181"
     *     root_path: "/services"
     *     service_name: "user-service"    # ← 服务名称
     *     register_self: true             # ← 是否注册到 ZK
     *     weight: 100                     # ← 负载均衡权重
     * @endcode
     * 
     * @example
     * @code
     *   // 相对路径
     *   builder.WithConfigFile("configs/config.yaml");
     *   
     *   // 绝对路径
     *   builder.WithConfigFile("/etc/user-service/config.yaml");
     *   
     *   // Docker 环境
     *   builder.WithConfigFile("/app/configs/config.docker.yaml");
     * @endcode
     */
    ServerBuilder& WithConfigFile(const std::string& path);

    /**
     * @brief 使用已加载的配置对象
     * 
     * @param config 配置对象智能指针
     * @return ServerBuilder& 返回自身
     * 
     * @note 适用于：
     *   - 需要在代码中动态修改配置
     *   - 多个服务共享配置对象
     *   - 单元测试中注入 mock 配置
     * 
     * @example
     * @code
     *   // 动态创建配置
     *   auto config = std::make_shared<Config>();
     *   config->server.grpc_port = 50051;
     *   config->zookeeper.service_name = "auth-service";
     *   
     *   auto server = ServerBuilder()
     *       .WithConfig(config)
     *       .Build();
     * @endcode
     */
    ServerBuilder& WithConfig(std::shared_ptr<Config> config);

    /**
     * @brief 从环境变量加载配置（覆盖配置文件）
     * 
     * @return ServerBuilder& 返回自身
     * 
     * @note 支持的环境变量：
     * 
     *   | 环境变量              | 作用                  | 示例                    |
     *   |-----------------------|-----------------------|-------------------------|
     *   | MYSQL_HOST            | MySQL 主机            | mysql                   |
     *   | MYSQL_PASSWORD        | MySQL 密码            | root123                 |
     *   | REDIS_HOST            | Redis 主机            | redis                   |
     *   | ZK_HOSTS              | ZooKeeper 地址        | zk1:2181,zk2:2181       |
     *   | ZK_ROOT_PATH          | 服务根路径            | /services               |
     *   | ZK_SERVICE_NAME       | 服务名称 ★            | auth-service            |
     *   | ZK_ENABLED            | 启用服务发现          | true                    |
     *   | ZK_REGISTER_SELF      | 注册自身              | true                    |
     *   | ZK_WEIGHT             | 负载均衡权重          | 100                     |
     *   | JWT_SECRET            | JWT 密钥              | your-secret-key         |
     * 
     * @example Docker Compose 配置
     * @code{.yaml}
     *   # docker-compose.yml
     *   services:
     *     auth-service:
     *       environment:
     *         - ZK_SERVICE_NAME=auth-service    # ← 设置服务名
     *         - ZK_HOSTS=zookeeper:2181
     *         - ZK_ENABLED=true
     *     
     *     user-service:
     *       environment:
     *         - ZK_SERVICE_NAME=user-service    # ← 不同服务名
     *         - ZK_HOSTS=zookeeper:2181
     *         - ZK_ENABLED=true
     * @endcode
     * 
     * @example Kubernetes Deployment
     * @code{.yaml}
     *   # k8s-deployment.yaml
     *   spec:
     *     containers:
     *     - name: user-service
     *       env:
     *       - name: ZK_SERVICE_NAME
     *         value: "user-service"
     *       - name: ZK_HOSTS
     *         value: "zk-headless.default.svc.cluster.local:2181"
     *       - name: POD_IP
     *         valueFrom:
     *           fieldRef:
     *             fieldPath: status.podIP
     * @endcode
     */
    ServerBuilder& LoadFromEnvironment();

    // ========================================================================
    // 服务器配置方法
    // ========================================================================

    /**
     * @brief 覆盖 gRPC 监听端口
     * 
     * @param port 端口号（1-65535）
     * @return ServerBuilder& 返回自身
     * 
     * @note 此设置会覆盖配置文件和环境变量中的端口
     * 
     * @example 不同服务使用不同端口
     * @code
     *   // auth-service 使用 50051
     *   auto auth_server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .WithPort(50051)
     *       .WithServiceName("auth-service")
     *       .Build();
     *   
     *   // user-service 使用 50052
     *   auto user_server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .WithPort(50052)
     *       .WithServiceName("user-service")
     *       .Build();
     * @endcode
     */
    ServerBuilder& WithPort(int port);

    /**
     * @brief 覆盖监听地址
     * 
     * @param host 主机地址
     * @return ServerBuilder& 返回自身
     * 
     * @note 常用值：
     *   - "0.0.0.0": 监听所有网卡（Docker/K8s 推荐）
     *   - "127.0.0.1": 仅本地访问（开发模式）
     *   - "192.168.1.10": 指定网卡 IP
     * 
     * @warning 在 Docker 中必须使用 "0.0.0.0"，否则无法从容器外访问
     * 
     * @example
     * @code
     *   // Docker 环境
     *   builder.WithHost("0.0.0.0");
     *   
     *   // 本地开发
     *   builder.WithHost("127.0.0.1");
     *   
     *   // 指定 IP（多网卡场景）
     *   builder.WithHost("10.0.0.5");
     * @endcode
     */
    ServerBuilder& WithHost(const std::string& host);

    // ========================================================================
    // 服务发现配置方法（ZooKeeper）
    // ========================================================================

    /**
     * @brief 启用或禁用服务发现（ZooKeeper 注册）
     * 
     * @param enable true=启用，false=禁用
     * @return ServerBuilder& 返回自身
     * 
     * @note 禁用服务发现的场景：
     *   - 本地开发/调试
     *   - 单机部署
     *   - 使用其他服务发现机制（如 K8s Service）
     * 
     * @example
     * @code
     *   // 开发模式：不需要 ZooKeeper
     *   auto dev_server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .EnableServiceDiscovery(false)
     *       .Build();
     *   
     *   // 生产模式：启用 ZooKeeper
     *   auto prod_server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .EnableServiceDiscovery(true)
     *       .Build();
     * @endcode
     */
    ServerBuilder& EnableServiceDiscovery(bool enable);

    /**
     * @brief 设置服务名称（ZooKeeper 注册路径）★ 关键配置
     * 
     * @param name 服务名称，如 "auth-service"、"user-service"
     * @return ServerBuilder& 返回自身
     * 
     * @note 服务名称决定了：
     *   1. ZooKeeper 中的注册路径：/services/{service_name}/
     *   2. 客户端通过服务名称发现此服务
     *   3. 监控/日志中的服务标识
     * 
     * @warning 
     *   - 同一类服务的所有实例必须使用相同的服务名称
     *   - 不同类服务必须使用不同的服务名称
     * 
     * @example 完整的多服务部署示例
     * @code
     *   // ==================== auth_service/main.cpp ====================
     *   int main() {
     *       auto server = ServerBuilder()
     *           .WithConfigFile("config.yaml")
     *           .WithPort(50051)
     *           .WithServiceName("auth-service")      // ← 认证服务
     *           .EnableServiceDiscovery(true)
     *           .Build();
     *       
     *       server->Initialize();
     *       server->Run();
     *       // ZooKeeper: /services/auth-service/192.168.1.10:50051
     *   }
     *   
     *   // ==================== user_service/main.cpp ====================
     *   int main() {
     *       auto server = ServerBuilder()
     *           .WithConfigFile("config.yaml")
     *           .WithPort(50052)
     *           .WithServiceName("user-service")      // ← 用户服务
     *           .EnableServiceDiscovery(true)
     *           .Build();
     *       
     *       server->Initialize();
     *       server->Run();
     *       // ZooKeeper: /services/user-service/192.168.1.10:50052
     *   }
     *   
     *   // ==================== order_service/main.cpp ====================
     *   int main() {
     *       auto server = ServerBuilder()
     *           .WithConfigFile("config.yaml")
     *           .WithPort(50053)
     *           .WithServiceName("order-service")     // ← 订单服务
     *           .EnableServiceDiscovery(true)
     *           .Build();
     *       
     *       server->Initialize();
     *       server->Run();
     *       // ZooKeeper: /services/order-service/192.168.1.10:50053
     *   }
     * @endcode
     * 
     * @example 服务名称命名规范
     * @code
     *   // ✅ 推荐：小写字母 + 连字符
     *   .WithServiceName("auth-service")
     *   .WithServiceName("user-service")
     *   .WithServiceName("order-service")
     *   .WithServiceName("payment-gateway")
     *   
     *   // ❌ 不推荐
     *   .WithServiceName("AuthService")     // 大小写混用
     *   .WithServiceName("user_service")    // 下划线
     *   .WithServiceName("user.service")    // 点号（ZK 路径分隔符）
     * @endcode
     */
    ServerBuilder& WithServiceName(const std::string& name);

    // ========================================================================
    // 生命周期回调
    // ========================================================================

    /**
     * @brief 设置服务器关闭回调
     * 
     * @param callback 关闭时执行的回调函数
     * @return ServerBuilder& 返回自身
     * 
     * @note 回调触发时机：
     *   1. 收到 SIGINT/SIGTERM 信号
     *   2. 调用 server->Shutdown()
     *   3. ZooKeeper 注销完成后
     *   4. gRPC 服务器停止前
     * 
     * @note 回调中适合做的事情：
     *   - 记录日志
     *   - 发送告警通知
     *   - 清理临时资源
     *   - 完成进行中的请求（graceful shutdown）
     * 
     * @warning 回调中不要做耗时操作，避免阻塞关闭流程
     * 
     * @example
     * @code
     *   auto server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .OnShutdown([]() {
     *           LOG_INFO("=== Server Shutdown ===");
     *           
     *           // 发送钉钉/飞书告警
     *           NotifyOps("user-service is shutting down");
     *           
     *           // 等待进行中的请求完成（可选）
     *           std::this_thread::sleep_for(std::chrono::seconds(2));
     *       })
     *       .Build();
     * @endcode
     */
    ServerBuilder& OnShutdown(GrpcServer::ShutdownCallback callback);

    // ========================================================================
    // 构建方法
    // ========================================================================

    /**
     * @brief 构建 GrpcServer 实例
     * 
     * @return std::unique_ptr<GrpcServer> 服务器实例
     * 
     * @throws std::runtime_error 配置未设置或配置无效
     * 
     * @note 构建过程：
     *   1. 检查配置是否已加载
     *   2. 应用环境变量覆盖（如果 LoadFromEnvironment 被调用）
     *   3. 应用 Builder 方法设置的覆盖值
     *   4. 创建 GrpcServer 实例
     *   5. 设置关闭回调
     * 
     * @note Build() 后需要手动调用：
     *   - server->Initialize(): 初始化所有组件
     *   - server->Run(): 启动服务器（阻塞）
     * 
     * @example 完整启动流程
     * @code
     *   // 1. 构建服务器
     *   auto server = ServerBuilder()
     *       .WithConfigFile("config.yaml")
     *       .WithServiceName("user-service")
     *       .Build();
     *   
     *   if (!server) {
     *       std::cerr << "Failed to build server" << std::endl;
     *       return 1;
     *   }
     *   
     *   // 2. 初始化组件（MySQL、Redis、ZK 等）
     *   if (!server->Initialize()) {
     *       std::cerr << "Failed to initialize server" << std::endl;
     *       return 1;
     *   }
     *   
     *   // 3. 启动服务器（阻塞，直到收到关闭信号）
     *   server->Run();
     *   
     *   return 0;
     * @endcode
     */
    std::unique_ptr<GrpcServer> Build();

private:
    /// 配置对象（从文件加载或外部传入）
    std::shared_ptr<Config> config_;
    
    /// 端口覆盖值（优先级最高）
    std::optional<int> port_override_;
    
    /// 主机地址覆盖值
    std::optional<std::string> host_override_;
    
    /// 服务发现开关覆盖值
    std::optional<bool> service_discovery_override_;
    
    /// 服务名称覆盖值（决定 ZK 注册路径）
    std::optional<std::string> service_name_override_;
    
    /// 关闭回调函数
    GrpcServer::ShutdownCallback shutdown_callback_;
    
    /// 是否从环境变量加载配置
    bool load_env_ = false;
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/client/client_options.h ======================

#pragma once

#include <string>
#include <chrono>
#include <memory>
#include <grpcpp/grpcpp.h>

namespace user_service {

/**
 * @brief 客户端配置选项
 */
struct ClientOptions {
    // 连接目标
    std::string target;                             // 服务地址，如 "localhost:50051"
    
    // 超时设置
    std::chrono::milliseconds timeout{5000};        // 默认超时 5 秒
    std::chrono::milliseconds connect_timeout{3000}; // 连接超时 3 秒
    
    // 重试策略
    int max_retries = 3;                            // 最大重试次数
    std::chrono::milliseconds retry_interval{100};  // 重试间隔
    
    // 认证
    std::string access_token;                       // Bearer Token（可选）
    
    // TLS 配置
    bool use_tls = false;
    std::string ca_cert_path;
    std::string client_cert_path;
    std::string client_key_path;
    
    // 连接池
    int max_connections = 10;                       // 最大连接数
    
    /**
     * @brief 创建 gRPC Channel Credentials
     */
    std::shared_ptr<grpc::ChannelCredentials> CreateCredentials() const {
        if (use_tls && !ca_cert_path.empty()) {
            grpc::SslCredentialsOptions ssl_opts;
            // 读取证书文件... (略)
            return grpc::SslCredentials(ssl_opts);
        }
        return grpc::InsecureChannelCredentials();
    }
    
    /**
     * @brief 创建 gRPC Channel Arguments
     */
    grpc::ChannelArguments CreateChannelArgs() const {
        grpc::ChannelArguments args;
        args.SetMaxReceiveMessageSize(4 * 1024 * 1024);  // 4MB
        args.SetMaxSendMessageSize(4 * 1024 * 1024);
        return args;
    }
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/client/user_client.h ======================

#pragma once

#include <memory>
#include <string>
#include <optional>
#include <grpcpp/grpcpp.h>

#include "client/client_options.h"
#include "common/result.h"
#include "entity/user_entity.h"
#include "entity/page.h"
#include "pb_user/user.grpc.pb.h"

namespace user_service {

/**
 * @brief 用户服务客户端
 * 
 * 提供用户管理操作的封装，所有接口都需要认证（Access Token）
 * 
 * @example
 * @code
 *   UserClient client("localhost:50051");
 *   client.SetAccessToken("eyJhbGciOi...");
 *   
 *   auto result = client.GetCurrentUser();
 *   if (result.IsOk()) {
 *       std::cout << "Hello, " << result.Value().display_name << std::endl;
 *   }
 * @endcode
 */
class UserClient {
public:
    /**
     * @brief 构造函数（简单版本）
     */
    explicit UserClient(const std::string& target);

    /**
     * @brief 构造函数（完整配置）
     */
    explicit UserClient(const ClientOptions& options);

    /**
     * @brief 构造函数（使用已有 Channel）
     */
    explicit UserClient(std::shared_ptr<grpc::Channel> channel);

    virtual ~UserClient() = default;

    // ==================== 当前用户操作 ====================

    /**
     * @brief 获取当前用户信息
     */
    virtual Result<UserEntity> GetCurrentUser();

    /**
     * @brief 更新用户信息
     * @param display_name 新昵称（可选）
     */
    virtual Result<UserEntity> UpdateUser(std::optional<std::string> display_name);

    /**
     * @brief 修改密码
     */
    virtual Result<void> ChangePassword(
        const std::string& old_password,
        const std::string& new_password
    );

    /**
     * @brief 注销账号
     * @param verify_code 验证码（确认身份）
     */
    virtual Result<void> DeleteUser(const std::string& verify_code);

    // ==================== 管理员操作 ====================

    /**
     * @brief 获取指定用户（需要管理员权限）
     */
    virtual Result<UserEntity> GetUser(const std::string& user_id);

    /**
     * @brief 获取用户列表（需要管理员权限）
     */
    virtual Result<std::pair<std::vector<UserEntity>, PageResult>> ListUsers(
        std::optional<std::string> mobile_filter = std::nullopt,
        std::optional<bool> disabled_filter = std::nullopt,
        int32_t page = 1,
        int32_t page_size = 20
    );

    // ==================== 认证配置 ====================

    /**
     * @brief 设置 Access Token（必须调用，否则请求会被拒绝）
     */
    void SetAccessToken(const std::string& token) {
        access_token_ = token;
    }

    /**
     * @brief 设置超时时间
     */
    void SetTimeout(std::chrono::milliseconds timeout) {
        timeout_ = timeout;
    }

protected:
    /**
     * @brief 创建带认证信息的 ClientContext
     */
    std::unique_ptr<grpc::ClientContext> CreateContext() const;

private:
    std::shared_ptr<grpc::Channel> channel_;
    std::unique_ptr<pb_user::UserService::Stub> stub_;
    std::string access_token_;
    std::chrono::milliseconds timeout_{5000};
};

} // namespace user_service


-----------------------------------------------------


// ====================== ./include/client/auth_client.h ======================

#pragma once

#include <memory>
#include <string>
#include <grpcpp/grpcpp.h>

#include "client/client_options.h"
#include "common/result.h"
#include "common/auth_type.h"
#include "entity/user_entity.h"
#include "pb_auth/auth.grpc.pb.h"

namespace user_service {

/**
 * @brief 认证服务客户端
 * 
 * 提供认证相关操作的封装，包括：
 * - 发送验证码
 * - 注册/登录
 * - Token 刷新
 * - 登出
 * 
 * @example
 * @code
 *   AuthClient client("localhost:50051");
 *   
 *   // 发送验证码
 *   auto result = client.SendVerifyCode("13800138000", SmsScene::Register);
 *   
 *   // 注册
 *   auto reg_result = client.Register("13800138000", "123456", "Password123");
 *   if (reg_result.IsOk()) {
 *       auto& auth = reg_result.Value();
 *       std::cout << "User ID: " << auth.user.uuid << std::endl;
 *       std::cout << "Access Token: " << auth.tokens.access_token << std::endl;
 *   }
 * @endcode
 */
class AuthClient {
public:
    /**
     * @brief 构造函数（简单版本）
     * @param target 服务地址，如 "localhost:50051"
     */
    explicit AuthClient(const std::string& target);

    /**
     * @brief 构造函数（完整配置）
     * @param options 客户端配置选项
     */
    explicit AuthClient(const ClientOptions& options);

    /**
     * @brief 构造函数（使用已有 Channel）
     * @param channel gRPC Channel
     */
    explicit AuthClient(std::shared_ptr<grpc::Channel> channel);

    virtual ~AuthClient() = default;

    // ==================== 验证码 ====================

    /**
     * @brief 发送验证码
     * @param mobile 手机号
     * @param scene 场景（注册/登录/重置密码）
     * @return 成功返回重试间隔（秒）
     */
    virtual Result<int32_t> SendVerifyCode(const std::string& mobile, SmsScene scene);

    // ==================== 注册 ====================

    /**
     * @brief 用户注册
     * @param mobile 手机号
     * @param verify_code 验证码
     * @param password 密码
     * @param display_name 昵称（可选）
     * @return 成功返回用户信息和 Token
     */
    virtual Result<AuthResult> Register(
        const std::string& mobile,
        const std::string& verify_code,
        const std::string& password,
        const std::string& display_name = ""
    );

    // ==================== 登录 ====================

    /**
     * @brief 密码登录
     */
    virtual Result<AuthResult> LoginByPassword(
        const std::string& mobile,
        const std::string& password
    );

    /**
     * @brief 验证码登录
     */
    virtual Result<AuthResult> LoginByCode(
        const std::string& mobile,
        const std::string& verify_code
    );

    // ==================== Token 管理 ====================

    /**
     * @brief 刷新 Token
     * @param refresh_token 刷新令牌
     * @return 成功返回新的 Token 对
     */
    virtual Result<TokenPair> RefreshToken(const std::string& refresh_token);

    /**
     * @brief 登出
     * @param refresh_token 刷新令牌
     */
    virtual Result<void> Logout(const std::string& refresh_token);

    // ==================== 密码管理 ====================

    /**
     * @brief 重置密码
     */
    virtual Result<void> ResetPassword(
        const std::string& mobile,
        const std::string& verify_code,
        const std::string& new_password
    );

    // ==================== Token 验证（内部服务用）====================

    /**
     * @brief 验证 Access Token
     */
    virtual Result<TokenValidationResult> ValidateToken(const std::string& access_token);

    // ==================== 配置 ====================

    /**
     * @brief 设置默认超时时间
     */
    void SetTimeout(std::chrono::milliseconds timeout) {
        timeout_ = timeout;
    }

protected:
    /**
     * @brief 创建带超时的 ClientContext
     */
    std::unique_ptr<grpc::ClientContext> CreateContext() const;

    /**
     * @brief 从 gRPC Status 和 Proto Result 创建 Result
     */
    template<typename T>
    Result<T> HandleResponse(
        const grpc::Status& status,
        const pb_common::Result& proto_result,
        std::function<T()> extractor
    );

private:
    std::shared_ptr<grpc::Channel> channel_;
    std::unique_ptr<pb_auth::AuthService::Stub> stub_;
    std::chrono::milliseconds timeout_{5000};
};

} // namespace user_service


-----------------------------------------------------


